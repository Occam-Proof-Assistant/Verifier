"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    nodeAsString: function() {
        return nodeAsString;
    },
    nodesAsString: function() {
        return nodesAsString;
    },
    termNodeFromTermString: function() {
        return termNodeFromTermString;
    },
    labelNodeFromLabelString: function() {
        return labelNodeFromLabelString;
    },
    statementNodeFromStatementString: function() {
        return statementNodeFromStatementString;
    },
    metastatementNodeFromMetastatementString: function() {
        return metastatementNodeFromMetastatementString;
    }
});
var _query = require("../utilities/query");
var _constants = require("../constants");
var _ruleNames = require("../ruleNames");
var termNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/term!"), statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement!"), metastatementNodeQuery = (0, _query.nodeQuery)("/unqualifiedMetastatement/metastatement!");
function nodeAsString(node, tokens) {
    var string = null;
    if (node !== null) {
        var nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
            var terminalNode = node, content = terminalNode.getContent();
            string = content; ///
        } else {
            var nonTerminalNode = node, firstSignificantToken = nonTerminalNode.getFirstSignificantToken(), lastSignificantToken = nonTerminalNode.getLastSignificantToken(), firstSignificantTokenIndex = tokens.indexOf(firstSignificantToken), lastSignificantTokenIndex = tokens.indexOf(lastSignificantToken), start = firstSignificantTokenIndex, end = lastSignificantTokenIndex + 1;
            tokens = tokens.slice(start, end); ///
            string = tokens.reduce(function(string, token) {
                var content = token.getContent();
                string = "".concat(string).concat(content);
                return string;
            }, _constants.EMPTY_STRING);
        }
    }
    if (string !== null) {
        string = string.replace(/[\r\n]/, _constants.EMPTY_STRING);
    }
    return string;
}
function nodesAsString(nodes, tokens) {
    var string = nodes.reduce(function(string, node) {
        var nodeString = nodeAsString(node, tokens);
        string = string === _constants.EMPTY_STRING ? nodeString : "".concat(string).concat(_constants.COMMA).concat(nodeString);
        return string;
    }, _constants.EMPTY_STRING);
    return string;
}
function termNodeFromTermString(termString, releaseContext) {
    var ruleName = _ruleNames.CONSTRUCTOR_DECLARATIONRULE_NAME, content = "Constructor ".concat(termString, "\n"), node = releaseContext.nodeFromContentAndRuleName(content, ruleName), constructorDeclarationNode = node, termNode = termNodeQuery(constructorDeclarationNode);
    return termNode;
}
function labelNodeFromLabelString(labelString, releaseContext) {
    var content = labelString, ruleName = _ruleNames.LABEL_RULE_NAME, node = releaseContext.nodeFromContentAndRuleName(content, ruleName), labelNode = node; ///
    return labelNode;
}
function statementNodeFromStatementString(statementString, releaseContext) {
    var ruleName = _ruleNames.UNQUALIFIED_STATEMENT_RULE_NAME, content = "".concat(statementString, "\n"), node = releaseContext.nodeFromContentAndRuleName(content, ruleName), unqualifiedStatementNode = node, statementNode = statementNodeQuery(unqualifiedStatementNode);
    return statementNode;
}
function metastatementNodeFromMetastatementString(metastatementString, releaseContext) {
    var ruleName = _ruleNames.UNQUALIFIED_METASTATEMENT_RULE_NAME, content = "".concat(metastatementString, "\n"), node = releaseContext.nodeFromContentAndRuleName(content, ruleName), unqualifiedMetastatementNode = node, metastatementNode = metastatementNodeQuery(unqualifiedMetastatementNode);
    return metastatementNode;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvc3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBDT01NQSwgRU1QVFlfU1RSSU5HIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTEFCRUxfUlVMRV9OQU1FLCBVTlFVQUxJRklFRF9TVEFURU1FTlRfUlVMRV9OQU1FLCBDT05TVFJVQ1RPUl9ERUNMQVJBVElPTlJVTEVfTkFNRSwgVU5RVUFMSUZJRURfTUVUQVNUQVRFTUVOVF9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvY29uc3RydWN0b3JEZWNsYXJhdGlvbi90ZXJtIVwiKSxcbiAgICAgIHN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi91bnF1YWxpZmllZFN0YXRlbWVudC9zdGF0ZW1lbnQhXCIpLFxuICAgICAgbWV0YXN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi91bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnQvbWV0YXN0YXRlbWVudCFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBub2RlQXNTdHJpbmcobm9kZSwgdG9rZW5zKSB7XG4gIGxldCBzdHJpbmcgPSBudWxsO1xuXG4gIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgICAgICBjb250ZW50ID0gdGVybWluYWxOb2RlLmdldENvbnRlbnQoKTtcblxuICAgICAgc3RyaW5nID0gY29udGVudDsgLy8vXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vblRlcm1pbmFsTm9kZSA9IG5vZGUsIC8vL1xuICAgICAgICAgICAgZmlyc3RTaWduaWZpY2FudFRva2VuID0gbm9uVGVybWluYWxOb2RlLmdldEZpcnN0U2lnbmlmaWNhbnRUb2tlbigpLFxuICAgICAgICAgICAgbGFzdFNpZ25pZmljYW50VG9rZW4gPSBub25UZXJtaW5hbE5vZGUuZ2V0TGFzdFNpZ25pZmljYW50VG9rZW4oKSxcbiAgICAgICAgICAgIGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4ID0gdG9rZW5zLmluZGV4T2YoZmlyc3RTaWduaWZpY2FudFRva2VuKSxcbiAgICAgICAgICAgIGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggPSB0b2tlbnMuaW5kZXhPZihsYXN0U2lnbmlmaWNhbnRUb2tlbiksXG4gICAgICAgICAgICBzdGFydCA9IGZpcnN0U2lnbmlmaWNhbnRUb2tlbkluZGV4LCAvLy9cbiAgICAgICAgICAgIGVuZCA9IGxhc3RTaWduaWZpY2FudFRva2VuSW5kZXggKyAxO1xuXG4gICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7ICAvLy9cblxuICAgICAgc3RyaW5nID0gdG9rZW5zLnJlZHVjZSgoc3RyaW5nLCB0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdG9rZW4uZ2V0Q29udGVudCgpO1xuXG4gICAgICAgIHN0cmluZyA9IGAke3N0cmluZ30ke2NvbnRlbnR9YDtcblxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfSwgRU1QVFlfU1RSSU5HKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaW5nICE9PSBudWxsKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1tcXHJcXG5dLywgRU1QVFlfU1RSSU5HKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVzQXNTdHJpbmcobm9kZXMsIHRva2Vucykge1xuICBjb25zdCBzdHJpbmcgPSBub2Rlcy5yZWR1Y2UoKHN0cmluZywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IG5vZGVTdHJpbmcgPSBub2RlQXNTdHJpbmcobm9kZSwgdG9rZW5zKTtcblxuICAgIHN0cmluZyA9IChzdHJpbmcgPT09IEVNUFRZX1NUUklORykgP1xuICAgICAgICAgICAgICAgbm9kZVN0cmluZyA6XG4gICAgICAgICAgICAgICAgYCR7c3RyaW5nfSR7Q09NTUF9JHtub2RlU3RyaW5nfWA7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LCBFTVBUWV9TVFJJTkcpO1xuXG4gIHJldHVybiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtTm9kZUZyb21UZXJtU3RyaW5nKHRlcm1TdHJpbmcsIHJlbGVhc2VDb250ZXh0KSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gQ09OU1RSVUNUT1JfREVDTEFSQVRJT05SVUxFX05BTUUsXG4gICAgICAgIGNvbnRlbnQgPSBgQ29uc3RydWN0b3IgJHt0ZXJtU3RyaW5nfVxuYCxcbiAgICAgICAgbm9kZSA9IHJlbGVhc2VDb250ZXh0Lm5vZGVGcm9tQ29udGVudEFuZFJ1bGVOYW1lKGNvbnRlbnQsIHJ1bGVOYW1lKSxcbiAgICAgICAgY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKTtcblxuICByZXR1cm4gdGVybU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbE5vZGVGcm9tTGFiZWxTdHJpbmcobGFiZWxTdHJpbmcsIHJlbGVhc2VDb250ZXh0KSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBsYWJlbFN0cmluZywgLy8vXG4gICAgICAgIHJ1bGVOYW1lID0gTEFCRUxfUlVMRV9OQU1FLFxuICAgICAgICBub2RlID0gcmVsZWFzZUNvbnRleHQubm9kZUZyb21Db250ZW50QW5kUnVsZU5hbWUoY29udGVudCwgcnVsZU5hbWUpLFxuICAgICAgICBsYWJlbE5vZGUgPSBub2RlOyAvLy9cblxuICByZXR1cm4gbGFiZWxOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmcoc3RhdGVtZW50U3RyaW5nLCByZWxlYXNlQ29udGV4dCkge1xuICBjb25zdCBydWxlTmFtZSA9IFVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUsXG4gICAgICAgIGNvbnRlbnQgPSBgJHtzdGF0ZW1lbnRTdHJpbmd9XG5gLFxuICAgICAgICBub2RlID0gcmVsZWFzZUNvbnRleHQubm9kZUZyb21Db250ZW50QW5kUnVsZU5hbWUoY29udGVudCwgcnVsZU5hbWUpLFxuICAgICAgICB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUgPSBub2RlLCAgLy8vXG4gICAgICAgIHN0YXRlbWVudE5vZGUgPSBzdGF0ZW1lbnROb2RlUXVlcnkodW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlKTtcblxuICByZXR1cm4gc3RhdGVtZW50Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFzdGF0ZW1lbnROb2RlRnJvbU1ldGFzdGF0ZW1lbnRTdHJpbmcobWV0YXN0YXRlbWVudFN0cmluZywgcmVsZWFzZUNvbnRleHQpIHtcbiAgY29uc3QgcnVsZU5hbWUgPSBVTlFVQUxJRklFRF9NRVRBU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgY29udGVudCA9IGAke21ldGFzdGF0ZW1lbnRTdHJpbmd9XG5gLFxuICAgICAgICBub2RlID0gcmVsZWFzZUNvbnRleHQubm9kZUZyb21Db250ZW50QW5kUnVsZU5hbWUoY29udGVudCwgcnVsZU5hbWUpLFxuICAgICAgICB1bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnROb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICBtZXRhc3RhdGVtZW50Tm9kZSA9IG1ldGFzdGF0ZW1lbnROb2RlUXVlcnkodW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIG1ldGFzdGF0ZW1lbnROb2RlO1xufVxuIl0sIm5hbWVzIjpbIm5vZGVBc1N0cmluZyIsIm5vZGVzQXNTdHJpbmciLCJ0ZXJtTm9kZUZyb21UZXJtU3RyaW5nIiwibGFiZWxOb2RlRnJvbUxhYmVsU3RyaW5nIiwic3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmciLCJtZXRhc3RhdGVtZW50Tm9kZUZyb21NZXRhc3RhdGVtZW50U3RyaW5nIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInN0YXRlbWVudE5vZGVRdWVyeSIsIm1ldGFzdGF0ZW1lbnROb2RlUXVlcnkiLCJub2RlIiwidG9rZW5zIiwic3RyaW5nIiwibm9kZVRlcm1pbmFsTm9kZSIsImlzVGVybWluYWxOb2RlIiwidGVybWluYWxOb2RlIiwiY29udGVudCIsImdldENvbnRlbnQiLCJub25UZXJtaW5hbE5vZGUiLCJmaXJzdFNpZ25pZmljYW50VG9rZW4iLCJnZXRGaXJzdFNpZ25pZmljYW50VG9rZW4iLCJsYXN0U2lnbmlmaWNhbnRUb2tlbiIsImdldExhc3RTaWduaWZpY2FudFRva2VuIiwiZmlyc3RTaWduaWZpY2FudFRva2VuSW5kZXgiLCJpbmRleE9mIiwibGFzdFNpZ25pZmljYW50VG9rZW5JbmRleCIsInN0YXJ0IiwiZW5kIiwic2xpY2UiLCJyZWR1Y2UiLCJ0b2tlbiIsIkVNUFRZX1NUUklORyIsInJlcGxhY2UiLCJub2RlcyIsIm5vZGVTdHJpbmciLCJDT01NQSIsInRlcm1TdHJpbmciLCJyZWxlYXNlQ29udGV4dCIsInJ1bGVOYW1lIiwiQ09OU1RSVUNUT1JfREVDTEFSQVRJT05SVUxFX05BTUUiLCJub2RlRnJvbUNvbnRlbnRBbmRSdWxlTmFtZSIsImNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlIiwidGVybU5vZGUiLCJsYWJlbFN0cmluZyIsIkxBQkVMX1JVTEVfTkFNRSIsImxhYmVsTm9kZSIsInN0YXRlbWVudFN0cmluZyIsIlVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUiLCJ1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUiLCJzdGF0ZW1lbnROb2RlIiwibWV0YXN0YXRlbWVudFN0cmluZyIsIlVOUVVBTElGSUVEX01FVEFTVEFURU1FTlRfUlVMRV9OQU1FIiwidW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50Tm9kZSIsIm1ldGFzdGF0ZW1lbnROb2RlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7SUFVZ0JBLFlBQVk7ZUFBWkE7O0lBdUNBQyxhQUFhO2VBQWJBOztJQWNBQyxzQkFBc0I7ZUFBdEJBOztJQVdBQyx3QkFBd0I7ZUFBeEJBOztJQVNBQyxnQ0FBZ0M7ZUFBaENBOztJQVdBQyx3Q0FBd0M7ZUFBeENBOzs7cUJBNUZVO3lCQUNVO3lCQUNvRztBQUV4SSxJQUFNQyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsa0NBQzFCQyxxQkFBcUJELElBQUFBLGdCQUFTLEVBQUMscUNBQy9CRSx5QkFBeUJGLElBQUFBLGdCQUFTLEVBQUM7QUFFbEMsU0FBU1AsYUFBYVUsSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDekMsSUFBSUMsU0FBUyxJQUFJO0lBRWpCLElBQUlGLFNBQVMsSUFBSSxFQUFFO1FBQ2pCLElBQU1HLG1CQUFtQkgsS0FBS0ksY0FBYztRQUU1QyxJQUFJRCxrQkFBa0I7WUFDcEIsSUFBTUUsZUFBZUwsTUFDZk0sVUFBVUQsYUFBYUUsVUFBVTtZQUV2Q0wsU0FBU0ksU0FBUyxHQUFHO1FBQ3ZCLE9BQU87WUFDTCxJQUFNRSxrQkFBa0JSLE1BQ2xCUyx3QkFBd0JELGdCQUFnQkUsd0JBQXdCLElBQ2hFQyx1QkFBdUJILGdCQUFnQkksdUJBQXVCLElBQzlEQyw2QkFBNkJaLE9BQU9hLE9BQU8sQ0FBQ0wsd0JBQzVDTSw0QkFBNEJkLE9BQU9hLE9BQU8sQ0FBQ0gsdUJBQzNDSyxRQUFRSCw0QkFDUkksTUFBTUYsNEJBQTRCO1lBRXhDZCxTQUFTQSxPQUFPaUIsS0FBSyxDQUFDRixPQUFPQyxNQUFPLEdBQUc7WUFFdkNmLFNBQVNELE9BQU9rQixNQUFNLENBQUMsU0FBQ2pCLFFBQVFrQixPQUFVO2dCQUN4QyxJQUFNZCxVQUFVYyxNQUFNYixVQUFVO2dCQUVoQ0wsU0FBUyxBQUFDLEdBQVdJLE9BQVRKLFFBQWlCLE9BQVJJO2dCQUVyQixPQUFPSjtZQUNULEdBQUdtQix1QkFBWTtRQUNqQixDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUluQixXQUFXLElBQUksRUFBRTtRQUNuQkEsU0FBU0EsT0FBT29CLE9BQU8sQ0FBQyxVQUFVRCx1QkFBWTtJQUNoRCxDQUFDO0lBRUQsT0FBT25CO0FBQ1Q7QUFFTyxTQUFTWCxjQUFjZ0MsS0FBSyxFQUFFdEIsTUFBTSxFQUFFO0lBQzNDLElBQU1DLFNBQVNxQixNQUFNSixNQUFNLENBQUMsU0FBQ2pCLFFBQVFGLE1BQVM7UUFDNUMsSUFBTXdCLGFBQWFsQyxhQUFhVSxNQUFNQztRQUV0Q0MsU0FBUyxBQUFDQSxXQUFXbUIsdUJBQVksR0FDdEJHLGFBQ0MsQUFBQyxHQUFXQyxPQUFUdkIsUUFBaUJzQixPQUFSQyxnQkFBSyxFQUFjLE9BQVhELFdBQVk7UUFFNUMsT0FBT3RCO0lBQ1QsR0FBR21CLHVCQUFZO0lBRWYsT0FBT25CO0FBQ1Q7QUFFTyxTQUFTVix1QkFBdUJrQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTtJQUNqRSxJQUFNQyxXQUFXQywyQ0FBZ0MsRUFDM0N2QixVQUFVLEFBQUMsZUFBeUIsT0FBWG9CLFlBQVcsT0FFcEMxQixPQUFPMkIsZUFBZUcsMEJBQTBCLENBQUN4QixTQUFTc0IsV0FDMURHLDZCQUE2Qi9CLE1BQzdCZ0MsV0FBV3BDLGNBQWNtQztJQUUvQixPQUFPQztBQUNUO0FBRU8sU0FBU3ZDLHlCQUF5QndDLFdBQVcsRUFBRU4sY0FBYyxFQUFFO0lBQ3BFLElBQU1yQixVQUFVMkIsYUFDVkwsV0FBV00sMEJBQWUsRUFDMUJsQyxPQUFPMkIsZUFBZUcsMEJBQTBCLENBQUN4QixTQUFTc0IsV0FDMURPLFlBQVluQyxNQUFNLEdBQUc7SUFFM0IsT0FBT21DO0FBQ1Q7QUFFTyxTQUFTekMsaUNBQWlDMEMsZUFBZSxFQUFFVCxjQUFjLEVBQUU7SUFDaEYsSUFBTUMsV0FBV1MsMENBQStCLEVBQzFDL0IsVUFBVSxBQUFDLEdBQWtCLE9BQWhCOEIsaUJBQWdCLE9BRTdCcEMsT0FBTzJCLGVBQWVHLDBCQUEwQixDQUFDeEIsU0FBU3NCLFdBQzFEVSwyQkFBMkJ0QyxNQUMzQnVDLGdCQUFnQnpDLG1CQUFtQndDO0lBRXpDLE9BQU9DO0FBQ1Q7QUFFTyxTQUFTNUMseUNBQXlDNkMsbUJBQW1CLEVBQUViLGNBQWMsRUFBRTtJQUM1RixJQUFNQyxXQUFXYSw4Q0FBbUMsRUFDOUNuQyxVQUFVLEFBQUMsR0FBc0IsT0FBcEJrQyxxQkFBb0IsT0FFakN4QyxPQUFPMkIsZUFBZUcsMEJBQTBCLENBQUN4QixTQUFTc0IsV0FDMURjLCtCQUErQjFDLE1BQy9CMkMsb0JBQW9CNUMsdUJBQXVCMkM7SUFFakQsT0FBT0M7QUFDVCJ9