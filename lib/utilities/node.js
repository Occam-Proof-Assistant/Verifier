"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    constructorDeclarationNodeFromConstructorDeclarationTokens: function() {
        return constructorDeclarationNodeFromConstructorDeclarationTokens;
    },
    statementNodeFromStatementString: function() {
        return statementNodeFromStatementString;
    },
    statementNodeFromUnqualifiedStatementTokens: function() {
        return statementNodeFromUnqualifiedStatementTokens;
    },
    termNodeFromConstructorDeclarationTokens: function() {
        return termNodeFromConstructorDeclarationTokens;
    },
    unqualifiedStatementNodeFromUnqualifiedStatementTokens: function() {
        return unqualifiedStatementNodeFromUnqualifiedStatementTokens;
    }
});
var _occamcustomgrammars = require("occam-custom-grammars");
var _query = require("../utilities/query");
var _customGrammar = require("./customGrammar");
var _tokens = require("../utilities/tokens");
var _ruleNames = require("../ruleNames");
var florenceParserFromCombinedCustomGrammar = _occamcustomgrammars.parsersUtilities.florenceParserFromCombinedCustomGrammar;
var combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromNothing)(), florenceParser = florenceParserFromCombinedCustomGrammar(combinedCustomGrammar);
var termNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/term!"), statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement!");
function statementNodeFromStatementString(statementString, lexer, parser) {
    var unqualifiedStatementTokens = (0, _tokens.unqualifiedStatementTokensFromStatementString)(statementString, lexer), statementNode = statementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser);
    return statementNode;
}
function termNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser) {
    var termNode = null;
    var constructorDeclarationNode = constructorDeclarationNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser);
    if (constructorDeclarationNode !== null) {
        termNode = termNodeQuery(constructorDeclarationNode);
    }
    return termNode;
}
function statementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser) {
    var statementNode = null;
    var unqualifiedStatementNode = unqualifiedStatementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser);
    if (unqualifiedStatementNode !== null) {
        statementNode = statementNodeQuery(unqualifiedStatementNode);
    }
    return statementNode;
}
function unqualifiedStatementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser) {
    var ruleName = _ruleNames.UNQUALIFIED_STATEMENT_RULE_NAME, unqualifiedStatementNode = nodeFromTokensRuleNameAndParser(unqualifiedStatementTokens, ruleName, parser);
    return unqualifiedStatementNode;
}
function constructorDeclarationNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser) {
    var ruleName = _ruleNames.CONSTRUCTOR_DECLARATION_RULE_NAME, constructorDeclarationNode = nodeFromTokensRuleNameAndParser(constructorDeclarationTokens, ruleName, parser);
    return constructorDeclarationNode;
}
function nodeFromTokensRuleNameAndParser(tokens, ruleName) {
    var parser = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : florenceParser;
    var ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
    return node;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFyc2Vyc1V0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1jdXN0b20tZ3JhbW1hcnNcIjtcblxuaW1wb3J0IHsgbm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbU5vdGhpbmcgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyXCI7XG5pbXBvcnQgeyB1bnF1YWxpZmllZFN0YXRlbWVudFRva2Vuc0Zyb21TdGF0ZW1lbnRTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3Rva2Vuc1wiO1xuaW1wb3J0IHsgVU5RVUFMSUZJRURfU1RBVEVNRU5UX1JVTEVfTkFNRSwgQ09OU1RSVUNUT1JfREVDTEFSQVRJT05fUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB7IGZsb3JlbmNlUGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hciB9ID0gcGFyc2Vyc1V0aWxpdGllcztcblxuY29uc3QgY29tYmluZWRDdXN0b21HcmFtbWFyID0gY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbU5vdGhpbmcoKSxcbiAgICAgIGZsb3JlbmNlUGFyc2VyID0gZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKGNvbWJpbmVkQ3VzdG9tR3JhbW1hcik7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvY29uc3RydWN0b3JEZWNsYXJhdGlvbi90ZXJtIVwiKSxcbiAgICAgIHN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi91bnF1YWxpZmllZFN0YXRlbWVudC9zdGF0ZW1lbnQhXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmcoc3RhdGVtZW50U3RyaW5nLCBsZXhlciwgcGFyc2VyKSB7XG4gIGNvbnN0IHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zID0gdW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnNGcm9tU3RhdGVtZW50U3RyaW5nKHN0YXRlbWVudFN0cmluZywgbGV4ZXIpLFxuICAgICAgICBzdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50Tm9kZUZyb21VbnF1YWxpZmllZFN0YXRlbWVudFRva2Vucyh1bnF1YWxpZmllZFN0YXRlbWVudFRva2VucywgcGFyc2VyKTtcblxuICByZXR1cm4gc3RhdGVtZW50Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlcm1Ob2RlRnJvbUNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMoY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucywgcGFyc2VyKSB7XG4gIGxldCB0ZXJtTm9kZSA9IG51bGw7XG5cbiAgY29uc3QgY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUgPSBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZUZyb21Db25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMsIHBhcnNlcik7XG5cbiAgaWYgKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlICE9PSBudWxsKSB7XG4gICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKTtcbiAgfVxuXG4gIHJldHVybiB0ZXJtTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlbWVudE5vZGVGcm9tVW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnModW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMsIHBhcnNlcikge1xuICBsZXQgc3RhdGVtZW50Tm9kZSA9IG51bGw7XG5cbiAgY29uc3QgdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlID0gdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlRnJvbVVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zKHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zLCBwYXJzZXIpO1xuXG4gIGlmICh1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUgIT09IG51bGwpIHtcbiAgICBzdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50Tm9kZVF1ZXJ5KHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZUZyb21VbnF1YWxpZmllZFN0YXRlbWVudFRva2Vucyh1bnF1YWxpZmllZFN0YXRlbWVudFRva2VucywgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gVU5RVUFMSUZJRURfU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlID0gbm9kZUZyb21Ub2tlbnNSdWxlTmFtZUFuZFBhcnNlcih1bnF1YWxpZmllZFN0YXRlbWVudFRva2VucywgcnVsZU5hbWUsIHBhcnNlcik7XG5cbiAgcmV0dXJuIHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlRnJvbUNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMoY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucywgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gQ09OU1RSVUNUT1JfREVDTEFSQVRJT05fUlVMRV9OQU1FLFxuICAgICAgICBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIoY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucywgcnVsZU5hbWUsIHBhcnNlcik7XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlO1xufVxuXG5mdW5jdGlvbiBub2RlRnJvbVRva2Vuc1J1bGVOYW1lQW5kUGFyc2VyKHRva2VucywgcnVsZU5hbWUsIHBhcnNlciA9IGZsb3JlbmNlUGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVNYXAgPSBwYXJzZXIuZ2V0UnVsZU1hcCgpLFxuICAgICAgICBydWxlID0gcnVsZU1hcFtydWxlTmFtZV0sXG4gICAgICAgIG5vZGUgPSBwYXJzZXIucGFyc2UodG9rZW5zLCBydWxlKTtcblxuICByZXR1cm4gbm9kZTtcbn1cbiJdLCJuYW1lcyI6WyJjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZUZyb21Db25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zIiwic3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmciLCJzdGF0ZW1lbnROb2RlRnJvbVVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zIiwidGVybU5vZGVGcm9tQ29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyIsInVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZUZyb21VbnF1YWxpZmllZFN0YXRlbWVudFRva2VucyIsImZsb3JlbmNlUGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hciIsInBhcnNlcnNVdGlsaXRpZXMiLCJjb21iaW5lZEN1c3RvbUdyYW1tYXIiLCJjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tTm90aGluZyIsImZsb3JlbmNlUGFyc2VyIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInN0YXRlbWVudE5vZGVRdWVyeSIsInN0YXRlbWVudFN0cmluZyIsImxleGVyIiwicGFyc2VyIiwidW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMiLCJ1bnF1YWxpZmllZFN0YXRlbWVudFRva2Vuc0Zyb21TdGF0ZW1lbnRTdHJpbmciLCJzdGF0ZW1lbnROb2RlIiwiY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyIsInRlcm1Ob2RlIiwiY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUiLCJ1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUiLCJydWxlTmFtZSIsIlVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUiLCJub2RlRnJvbVRva2Vuc1J1bGVOYW1lQW5kUGFyc2VyIiwiQ09OU1RSVUNUT1JfREVDTEFSQVRJT05fUlVMRV9OQU1FIiwidG9rZW5zIiwicnVsZU1hcCIsImdldFJ1bGVNYXAiLCJydWxlIiwibm9kZSIsInBhcnNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7SUF1RGdCQSwwREFBMEQ7ZUFBMURBOztJQXRDQUMsZ0NBQWdDO2VBQWhDQTs7SUFtQkFDLDJDQUEyQztlQUEzQ0E7O0lBWkFDLHdDQUF3QztlQUF4Q0E7O0lBd0JBQyxzREFBc0Q7ZUFBdERBOzs7bUNBOUNpQjtxQkFFUDs2QkFDdUI7c0JBQ2E7eUJBQ3FCO0FBRW5GLElBQU0sQUFBRUMsMENBQTRDQyxxQ0FBZ0IsQ0FBNUREO0FBRVIsSUFBTUUsd0JBQXdCQyxJQUFBQSwrQ0FBZ0MsS0FDeERDLGlCQUFpQkosd0NBQXdDRTtBQUUvRCxJQUFNRyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsa0NBQzFCQyxxQkFBcUJELElBQUFBLGdCQUFTLEVBQUM7QUFFOUIsU0FBU1YsaUNBQWlDWSxlQUFlLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUM3RSxJQUFNQyw2QkFBNkJDLElBQUFBLHFEQUE2QyxFQUFDSixpQkFBaUJDLFFBQzVGSSxnQkFBZ0JoQiw0Q0FBNENjLDRCQUE0QkQ7SUFFOUYsT0FBT0c7QUFDVDtBQUVPLFNBQVNmLHlDQUF5Q2dCLDRCQUE0QixFQUFFSixNQUFNO0lBQzNGLElBQUlLLFdBQVc7SUFFZixJQUFNQyw2QkFBNkJyQiwyREFBMkRtQiw4QkFBOEJKO0lBRTVILElBQUlNLCtCQUErQixNQUFNO1FBQ3ZDRCxXQUFXVixjQUFjVztJQUMzQjtJQUVBLE9BQU9EO0FBQ1Q7QUFFTyxTQUFTbEIsNENBQTRDYywwQkFBMEIsRUFBRUQsTUFBTTtJQUM1RixJQUFJRyxnQkFBZ0I7SUFFcEIsSUFBTUksMkJBQTJCbEIsdURBQXVEWSw0QkFBNEJEO0lBRXBILElBQUlPLDZCQUE2QixNQUFNO1FBQ3JDSixnQkFBZ0JOLG1CQUFtQlU7SUFDckM7SUFFQSxPQUFPSjtBQUNUO0FBRU8sU0FBU2QsdURBQXVEWSwwQkFBMEIsRUFBRUQsTUFBTTtJQUN2RyxJQUFNUSxXQUFXQywwQ0FBK0IsRUFDMUNGLDJCQUEyQkcsZ0NBQWdDVCw0QkFBNEJPLFVBQVVSO0lBRXZHLE9BQU9PO0FBQ1Q7QUFFTyxTQUFTdEIsMkRBQTJEbUIsNEJBQTRCLEVBQUVKLE1BQU07SUFDN0csSUFBTVEsV0FBV0csNENBQWlDLEVBQzVDTCw2QkFBNkJJLGdDQUFnQ04sOEJBQThCSSxVQUFVUjtJQUUzRyxPQUFPTTtBQUNUO0FBRUEsU0FBU0ksZ0NBQWdDRSxNQUFNLEVBQUVKLFFBQVE7UUFBRVIsU0FBQUEsaUVBQVNOO0lBQ2xFLElBQU1tQixVQUFVYixPQUFPYyxVQUFVLElBQzNCQyxPQUFPRixPQUFPLENBQUNMLFNBQVMsRUFDeEJRLE9BQU9oQixPQUFPaUIsS0FBSyxDQUFDTCxRQUFRRztJQUVsQyxPQUFPQztBQUNUIn0=