"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    constructorDeclarationTokensFromTermString: function() {
        return constructorDeclarationTokensFromTermString;
    },
    labelNodeFromLabelString: function() {
        return labelNodeFromLabelString;
    },
    labelTokensFromLabelString: function() {
        return labelTokensFromLabelString;
    },
    metaTypeNodeFromMetavariableString: function() {
        return metaTypeNodeFromMetavariableString;
    },
    metastatementNodeFromMetastatementString: function() {
        return metastatementNodeFromMetastatementString;
    },
    metavariableDeclarationTokensFromMetavariableString: function() {
        return metavariableDeclarationTokensFromMetavariableString;
    },
    metavariableNodeFromMetavariableString: function() {
        return metavariableNodeFromMetavariableString;
    },
    statementNodeFromStatementString: function() {
        return statementNodeFromStatementString;
    },
    termNodeFromTermString: function() {
        return termNodeFromTermString;
    },
    typeNodeFromVariableString: function() {
        return typeNodeFromVariableString;
    },
    unqualifiedMetastatementTokensFromMetastatementString: function() {
        return unqualifiedMetastatementTokensFromMetastatementString;
    },
    unqualifiedStatementTokensFromStatementString: function() {
        return unqualifiedStatementTokensFromStatementString;
    },
    variableDeclarationTokensFromVariableString: function() {
        return variableDeclarationTokensFromVariableString;
    },
    variableNodeFromVariableString: function() {
        return variableNodeFromVariableString;
    }
});
var _occamcustomgrammars = require("occam-custom-grammars");
var _query = require("../utilities/query");
var _ruleNames = require("../ruleNames");
var _customGrammar = require("./customGrammar");
var florenceLexerFromCombinedCustomGrammar = _occamcustomgrammars.lexersUtilities.florenceLexerFromCombinedCustomGrammar, florenceParserFromCombinedCustomGrammar = _occamcustomgrammars.parsersUtilities.florenceParserFromCombinedCustomGrammar;
var combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromNothing)(), florenceLexer = florenceLexerFromCombinedCustomGrammar(combinedCustomGrammar), florenceParser = florenceParserFromCombinedCustomGrammar(combinedCustomGrammar);
var termNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/term!"), typeNodeQuery = (0, _query.nodeQuery)("/variableDeclaration/type!"), variableNodeQuery = (0, _query.nodeQuery)("/variableDeclaration/variable!"), metaTypeNodeQuery = (0, _query.nodeQuery)("/metavariableDeclaration/metaType!"), statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement!"), metavariableNodeQuery = (0, _query.nodeQuery)("/metavariableDeclaration/metavariable!"), metastatementNodeQuery = (0, _query.nodeQuery)("/unqualifiedMetastatement/metastatement!");
function labelTokensFromLabelString(labelString, lexer) {
    var labelContent = "".concat(labelString), labelTokens = tokensFromContentAndLexer(labelContent, lexer);
    return labelTokens;
}
function constructorDeclarationTokensFromTermString(termString, lexer) {
    var constructorDeclarationContent = "Constructor ".concat(termString, "\n"), constructorDeclarationTokens = tokensFromContentAndLexer(constructorDeclarationContent, lexer);
    return constructorDeclarationTokens;
}
function variableDeclarationTokensFromVariableString(variableString, lexer) {
    var variableDeclarationContent = "Variable ".concat(variableString, "\n"), variableDeclarationTokens = tokensFromContentAndLexer(variableDeclarationContent, lexer);
    return variableDeclarationTokens;
}
function unqualifiedStatementTokensFromStatementString(statementString, lexer) {
    var unqualifiedStatementContent = "".concat(statementString, "\n"), unqualifiedStatementTokens = tokensFromContentAndLexer(unqualifiedStatementContent, lexer);
    return unqualifiedStatementTokens;
}
function metavariableDeclarationTokensFromMetavariableString(metavariableString, lexer) {
    var metavariableDeclarationContent = "Metavariable ".concat(metavariableString, "\n"), metavariableDeclarationTokens = tokensFromContentAndLexer(metavariableDeclarationContent, lexer);
    return metavariableDeclarationTokens;
}
function unqualifiedMetastatementTokensFromMetastatementString(metastatementString, lexer) {
    var unqualifiedMetastatementContent = "".concat(metastatementString, "\n"), unqualifiedMetastatementTokens = tokensFromContentAndLexer(unqualifiedMetastatementContent, lexer);
    return unqualifiedMetastatementTokens;
}
function termNodeFromTermString(termString, lexer, parser) {
    var ruleName = _ruleNames.CONSTRUCTOR_DECLARATION_RULE_NAME, constructorDeclarationTokens = constructorDeclarationTokensFromTermString(termString, lexer, parser), constructorDeclarationNode = nodeFromTokensRuleNameAndParser(constructorDeclarationTokens, ruleName, parser), termNode = termNodeQuery(constructorDeclarationNode);
    return termNode;
}
function labelNodeFromLabelString(labelString, lexer, parser) {
    var ruleName = _ruleNames.LABEL_RULE_NAME, labelTokens = labelTokensFromLabelString(labelString, lexer), labelNode = nodeFromTokensRuleNameAndParser(labelTokens, ruleName, parser);
    return labelNode;
}
function typeNodeFromVariableString(variableString, lexer, parser) {
    var ruleName = _ruleNames.TYPE_RULE_NAME, variableDeclarationTokens = variableDeclarationTokensFromVariableString(variableString, lexer), typeDeclarationNode = nodeFromTokensRuleNameAndParser(variableDeclarationTokens, ruleName, parser), typeNode = typeNodeQuery(typeDeclarationNode);
    return typeNode;
}
function variableNodeFromVariableString(variableString, lexer, parser) {
    var ruleName = _ruleNames.VARIABLE_RULE_NAME, variableTDeclarationTokens = variableDeclarationTokensFromVariableString(variableString, lexer), variableDeclarationNode = nodeFromTokensRuleNameAndParser(variableTDeclarationTokens, ruleName, parser), variableNode = variableNodeQuery(variableDeclarationNode);
    return variableNode;
}
function statementNodeFromStatementString(statementString, lexer, parser) {
    var ruleName = _ruleNames.UNQUALIFIED_STATEMENT_RULE_NAME, unqualifiedStatementTokens = unqualifiedStatementTokensFromStatementString(statementString, lexer), unqualifiedStatementNode = nodeFromTokensRuleNameAndParser(unqualifiedStatementTokens, ruleName, parser), statementNode = statementNodeQuery(unqualifiedStatementNode);
    return statementNode;
}
function metaTypeNodeFromMetavariableString(metavariableString, lexer, parser) {
    var ruleName = _ruleNames.META_TYPE_RULE_NAME, metavariableDeclarationTokens = metavariableDeclarationTokensFromMetavariableString(metavariableString, lexer), metaTypeDeclarationNode = nodeFromTokensRuleNameAndParser(metavariableDeclarationTokens, ruleName, parser), metaTypeNode = metaTypeNodeQuery(metaTypeDeclarationNode);
    return metaTypeNode;
}
function metavariableNodeFromMetavariableString(metavariableString, lexer, parser) {
    var ruleName = _ruleNames.METAVARIABLE_RULE_NAME, metavariableDeclarationTokens = metavariableDeclarationTokensFromMetavariableString(metavariableString, lexer), metavariableDeclarationNode = nodeFromTokensRuleNameAndParser(metavariableDeclarationTokens, ruleName, parser), metavariableNode = metavariableNodeQuery(metavariableDeclarationNode);
    return metavariableNode;
}
function metastatementNodeFromMetastatementString(metastatementString, lexer, parser) {
    var ruleName = _ruleNames.UNQUALIFIED_METASTATEMENT_RULE_NAME, unqualifiedMetastatementTokens = unqualifiedMetastatementTokensFromMetastatementString(metastatementString, lexer), unqualifiedMetastatementNode = nodeFromTokensRuleNameAndParser(unqualifiedMetastatementTokens, ruleName, parser), metastatementNode = metastatementNodeQuery(unqualifiedMetastatementNode);
    return metastatementNode;
}
function tokensFromContentAndLexer(content) {
    var lexer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : florenceLexer;
    var tokens = lexer.tokenise(content);
    return tokens;
}
function nodeFromTokensRuleNameAndParser(tokens, ruleName) {
    var parser = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : florenceParser;
    var ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
    return node;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgbGV4ZXJzVXRpbGl0aWVzLCBwYXJzZXJzVXRpbGl0aWVzIH0gZnJvbSBcIm9jY2FtLWN1c3RvbS1ncmFtbWFyc1wiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBUWVBFX1JVTEVfTkFNRSxcbiAgICAgICAgIExBQkVMX1JVTEVfTkFNRSxcbiAgICAgICAgIFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgIE1FVEFfVFlQRV9SVUxFX05BTUUsXG4gICAgICAgICBNRVRBVkFSSUFCTEVfUlVMRV9OQU1FLFxuICAgICAgICAgVU5RVUFMSUZJRURfU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgIENPTlNUUlVDVE9SX0RFQ0xBUkFUSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgIFVOUVVBTElGSUVEX01FVEFTVEFURU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5pbXBvcnQgeyBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tTm90aGluZyB9IGZyb20gXCIuL2N1c3RvbUdyYW1tYXJcIjtcblxuY29uc3QgeyBmbG9yZW5jZUxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hciB9ID0gbGV4ZXJzVXRpbGl0aWVzLFxuICAgICAgeyBmbG9yZW5jZVBhcnNlckZyb21Db21iaW5lZEN1c3RvbUdyYW1tYXIgfSA9IHBhcnNlcnNVdGlsaXRpZXM7XG5cbmNvbnN0IGNvbWJpbmVkQ3VzdG9tR3JhbW1hciA9IGNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nKCksXG4gICAgICBmbG9yZW5jZUxleGVyID0gZmxvcmVuY2VMZXhlckZyb21Db21iaW5lZEN1c3RvbUdyYW1tYXIoY29tYmluZWRDdXN0b21HcmFtbWFyKSxcbiAgICAgIGZsb3JlbmNlUGFyc2VyID0gZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyKGNvbWJpbmVkQ3VzdG9tR3JhbW1hcik7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvY29uc3RydWN0b3JEZWNsYXJhdGlvbi90ZXJtIVwiKSxcbiAgICAgIHR5cGVOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdmFyaWFibGVEZWNsYXJhdGlvbi90eXBlIVwiKSxcbiAgICAgIHZhcmlhYmxlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3ZhcmlhYmxlRGVjbGFyYXRpb24vdmFyaWFibGUhXCIpLFxuICAgICAgbWV0YVR5cGVOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvbWV0YXZhcmlhYmxlRGVjbGFyYXRpb24vbWV0YVR5cGUhXCIpLFxuICAgICAgc3RhdGVtZW50Tm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3VucXVhbGlmaWVkU3RhdGVtZW50L3N0YXRlbWVudCFcIiksXG4gICAgICBtZXRhdmFyaWFibGVOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvbWV0YXZhcmlhYmxlRGVjbGFyYXRpb24vbWV0YXZhcmlhYmxlIVwiKSxcbiAgICAgIG1ldGFzdGF0ZW1lbnROb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50L21ldGFzdGF0ZW1lbnQhXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxUb2tlbnNGcm9tTGFiZWxTdHJpbmcobGFiZWxTdHJpbmcsIGxleGVyKSB7XG4gIGNvbnN0IGxhYmVsQ29udGVudCA9IGAke2xhYmVsU3RyaW5nfWAsXG4gICAgICAgIGxhYmVsVG9rZW5zID0gdG9rZW5zRnJvbUNvbnRlbnRBbmRMZXhlcihsYWJlbENvbnRlbnQsIGxleGVyKTtcblxuICByZXR1cm4gbGFiZWxUb2tlbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zRnJvbVRlcm1TdHJpbmcodGVybVN0cmluZywgbGV4ZXIpIHtcbiAgY29uc3QgY29uc3RydWN0b3JEZWNsYXJhdGlvbkNvbnRlbnQgPSBgQ29uc3RydWN0b3IgJHt0ZXJtU3RyaW5nfVxuYCxcbiAgICAgICAgY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyA9IHRva2Vuc0Zyb21Db250ZW50QW5kTGV4ZXIoY29uc3RydWN0b3JEZWNsYXJhdGlvbkNvbnRlbnQsIGxleGVyKTtcblxuICByZXR1cm4gY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2Vucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRpb25Ub2tlbnNGcm9tVmFyaWFibGVTdHJpbmcodmFyaWFibGVTdHJpbmcsIGxleGVyKSB7XG4gIGNvbnN0IHZhcmlhYmxlRGVjbGFyYXRpb25Db250ZW50ID0gYFZhcmlhYmxlICR7dmFyaWFibGVTdHJpbmd9XG5gLFxuICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zID0gdG9rZW5zRnJvbUNvbnRlbnRBbmRMZXhlcih2YXJpYWJsZURlY2xhcmF0aW9uQ29udGVudCwgbGV4ZXIpO1xuXG4gIHJldHVybiB2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnNGcm9tU3RhdGVtZW50U3RyaW5nKHN0YXRlbWVudFN0cmluZywgbGV4ZXIpIHtcbiAgY29uc3QgdW5xdWFsaWZpZWRTdGF0ZW1lbnRDb250ZW50ID0gYCR7c3RhdGVtZW50U3RyaW5nfVxuYCxcbiAgICAgICAgdW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMgPSB0b2tlbnNGcm9tQ29udGVudEFuZExleGVyKHVucXVhbGlmaWVkU3RhdGVtZW50Q29udGVudCwgbGV4ZXIpO1xuXG4gIHJldHVybiB1bnF1YWxpZmllZFN0YXRlbWVudFRva2Vucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zRnJvbU1ldGF2YXJpYWJsZVN0cmluZyhtZXRhdmFyaWFibGVTdHJpbmcsIGxleGVyKSB7XG4gIGNvbnN0IG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uQ29udGVudCA9IGBNZXRhdmFyaWFibGUgJHttZXRhdmFyaWFibGVTdHJpbmd9XG5gLFxuICAgICAgICBtZXRhdmFyaWFibGVEZWNsYXJhdGlvblRva2VucyA9IHRva2Vuc0Zyb21Db250ZW50QW5kTGV4ZXIobWV0YXZhcmlhYmxlRGVjbGFyYXRpb25Db250ZW50LCBsZXhlcik7XG5cbiAgcmV0dXJuIG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50VG9rZW5zRnJvbU1ldGFzdGF0ZW1lbnRTdHJpbmcobWV0YXN0YXRlbWVudFN0cmluZywgbGV4ZXIpIHtcbiAgY29uc3QgdW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50Q29udGVudCA9IGAke21ldGFzdGF0ZW1lbnRTdHJpbmd9XG5gLFxuICAgICAgICB1bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnRUb2tlbnMgPSB0b2tlbnNGcm9tQ29udGVudEFuZExleGVyKHVucXVhbGlmaWVkTWV0YXN0YXRlbWVudENvbnRlbnQsIGxleGVyKTtcblxuICByZXR1cm4gdW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50VG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVybU5vZGVGcm9tVGVybVN0cmluZyh0ZXJtU3RyaW5nLCBsZXhlciwgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gQ09OU1RSVUNUT1JfREVDTEFSQVRJT05fUlVMRV9OQU1FLFxuICAgICAgICBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zID0gY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2Vuc0Zyb21UZXJtU3RyaW5nKHRlcm1TdHJpbmcsIGxleGVyLCBwYXJzZXIpLFxuICAgICAgICBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIoY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucywgcnVsZU5hbWUsIHBhcnNlciksXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeShjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSk7XG5cbiAgcmV0dXJuIHRlcm1Ob2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxOb2RlRnJvbUxhYmVsU3RyaW5nKGxhYmVsU3RyaW5nLCBsZXhlciwgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gTEFCRUxfUlVMRV9OQU1FLFxuICAgICAgICBsYWJlbFRva2VucyA9IGxhYmVsVG9rZW5zRnJvbUxhYmVsU3RyaW5nKGxhYmVsU3RyaW5nLCBsZXhlciksXG4gICAgICAgIGxhYmVsTm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIobGFiZWxUb2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIpO1xuXG4gIHJldHVybiBsYWJlbE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlTm9kZUZyb21WYXJpYWJsZVN0cmluZyh2YXJpYWJsZVN0cmluZywgbGV4ZXIsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IFRZUEVfUlVMRV9OQU1FLFxuICAgICAgICB2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zID0gdmFyaWFibGVEZWNsYXJhdGlvblRva2Vuc0Zyb21WYXJpYWJsZVN0cmluZyh2YXJpYWJsZVN0cmluZywgbGV4ZXIpLFxuICAgICAgICB0eXBlRGVjbGFyYXRpb25Ob2RlID0gbm9kZUZyb21Ub2tlbnNSdWxlTmFtZUFuZFBhcnNlcih2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zLCBydWxlTmFtZSwgcGFyc2VyKSxcbiAgICAgICAgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVEZWNsYXJhdGlvbk5vZGUpO1xuXG4gIHJldHVybiB0eXBlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhcmlhYmxlTm9kZUZyb21WYXJpYWJsZVN0cmluZyh2YXJpYWJsZVN0cmluZywgbGV4ZXIsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IFZBUklBQkxFX1JVTEVfTkFNRSxcbiAgICAgICAgdmFyaWFibGVURGVjbGFyYXRpb25Ub2tlbnMgPSB2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zRnJvbVZhcmlhYmxlU3RyaW5nKHZhcmlhYmxlU3RyaW5nLCBsZXhlciksXG4gICAgICAgIHZhcmlhYmxlRGVjbGFyYXRpb25Ob2RlID0gbm9kZUZyb21Ub2tlbnNSdWxlTmFtZUFuZFBhcnNlcih2YXJpYWJsZVREZWNsYXJhdGlvblRva2VucywgcnVsZU5hbWUsIHBhcnNlciksXG4gICAgICAgIHZhcmlhYmxlTm9kZSA9IHZhcmlhYmxlTm9kZVF1ZXJ5KHZhcmlhYmxlRGVjbGFyYXRpb25Ob2RlKTtcblxuICByZXR1cm4gdmFyaWFibGVOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmcoc3RhdGVtZW50U3RyaW5nLCBsZXhlciwgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gVU5RVUFMSUZJRURfU1RBVEVNRU5UX1JVTEVfTkFNRSxcbiAgICAgICAgdW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMgPSB1bnF1YWxpZmllZFN0YXRlbWVudFRva2Vuc0Zyb21TdGF0ZW1lbnRTdHJpbmcoc3RhdGVtZW50U3RyaW5nLCBsZXhlciksXG4gICAgICAgIHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIodW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIpLFxuICAgICAgICBzdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50Tm9kZVF1ZXJ5KHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHN0YXRlbWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXRhVHlwZU5vZGVGcm9tTWV0YXZhcmlhYmxlU3RyaW5nKG1ldGF2YXJpYWJsZVN0cmluZywgbGV4ZXIsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IE1FVEFfVFlQRV9SVUxFX05BTUUsXG4gICAgICAgIG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zID0gbWV0YXZhcmlhYmxlRGVjbGFyYXRpb25Ub2tlbnNGcm9tTWV0YXZhcmlhYmxlU3RyaW5nKG1ldGF2YXJpYWJsZVN0cmluZywgbGV4ZXIpLFxuICAgICAgICBtZXRhVHlwZURlY2xhcmF0aW9uTm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIobWV0YXZhcmlhYmxlRGVjbGFyYXRpb25Ub2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIpLFxuICAgICAgICBtZXRhVHlwZU5vZGUgPSBtZXRhVHlwZU5vZGVRdWVyeShtZXRhVHlwZURlY2xhcmF0aW9uTm9kZSk7XG5cbiAgcmV0dXJuIG1ldGFUeXBlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGF2YXJpYWJsZU5vZGVGcm9tTWV0YXZhcmlhYmxlU3RyaW5nKG1ldGF2YXJpYWJsZVN0cmluZywgbGV4ZXIsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IE1FVEFWQVJJQUJMRV9SVUxFX05BTUUsXG4gICAgICAgIG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zID0gbWV0YXZhcmlhYmxlRGVjbGFyYXRpb25Ub2tlbnNGcm9tTWV0YXZhcmlhYmxlU3RyaW5nKG1ldGF2YXJpYWJsZVN0cmluZywgbGV4ZXIpLFxuICAgICAgICBtZXRhdmFyaWFibGVEZWNsYXJhdGlvbk5vZGUgPSBub2RlRnJvbVRva2Vuc1J1bGVOYW1lQW5kUGFyc2VyKG1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zLCBydWxlTmFtZSwgcGFyc2VyKSxcbiAgICAgICAgbWV0YXZhcmlhYmxlTm9kZSA9IG1ldGF2YXJpYWJsZU5vZGVRdWVyeShtZXRhdmFyaWFibGVEZWNsYXJhdGlvbk5vZGUpO1xuXG4gIHJldHVybiBtZXRhdmFyaWFibGVOb2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWV0YXN0YXRlbWVudE5vZGVGcm9tTWV0YXN0YXRlbWVudFN0cmluZyhtZXRhc3RhdGVtZW50U3RyaW5nLCBsZXhlciwgcGFyc2VyKSB7XG4gIGNvbnN0IHJ1bGVOYW1lID0gVU5RVUFMSUZJRURfTUVUQVNUQVRFTUVOVF9SVUxFX05BTUUsXG4gICAgICAgIHVucXVhbGlmaWVkTWV0YXN0YXRlbWVudFRva2VucyA9IHVucXVhbGlmaWVkTWV0YXN0YXRlbWVudFRva2Vuc0Zyb21NZXRhc3RhdGVtZW50U3RyaW5nKG1ldGFzdGF0ZW1lbnRTdHJpbmcsIGxleGVyKSxcbiAgICAgICAgdW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50Tm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIodW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50VG9rZW5zLCBydWxlTmFtZSwgcGFyc2VyKSxcbiAgICAgICAgbWV0YXN0YXRlbWVudE5vZGUgPSBtZXRhc3RhdGVtZW50Tm9kZVF1ZXJ5KHVucXVhbGlmaWVkTWV0YXN0YXRlbWVudE5vZGUpO1xuXG4gIHJldHVybiBtZXRhc3RhdGVtZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gdG9rZW5zRnJvbUNvbnRlbnRBbmRMZXhlcihjb250ZW50LCBsZXhlciA9IGZsb3JlbmNlTGV4ZXIpIHtcbiAgY29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pc2UoY29udGVudCk7XG5cbiAgcmV0dXJuIHRva2Vucztcbn1cblxuZnVuY3Rpb24gbm9kZUZyb21Ub2tlbnNSdWxlTmFtZUFuZFBhcnNlcih0b2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIgPSBmbG9yZW5jZVBhcnNlcikge1xuICBjb25zdCBydWxlTWFwID0gcGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgICAgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICBub2RlID0gcGFyc2VyLnBhcnNlKHRva2VucywgcnVsZSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4iXSwibmFtZXMiOlsiY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2Vuc0Zyb21UZXJtU3RyaW5nIiwibGFiZWxOb2RlRnJvbUxhYmVsU3RyaW5nIiwibGFiZWxUb2tlbnNGcm9tTGFiZWxTdHJpbmciLCJtZXRhVHlwZU5vZGVGcm9tTWV0YXZhcmlhYmxlU3RyaW5nIiwibWV0YXN0YXRlbWVudE5vZGVGcm9tTWV0YXN0YXRlbWVudFN0cmluZyIsIm1ldGF2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zRnJvbU1ldGF2YXJpYWJsZVN0cmluZyIsIm1ldGF2YXJpYWJsZU5vZGVGcm9tTWV0YXZhcmlhYmxlU3RyaW5nIiwic3RhdGVtZW50Tm9kZUZyb21TdGF0ZW1lbnRTdHJpbmciLCJ0ZXJtTm9kZUZyb21UZXJtU3RyaW5nIiwidHlwZU5vZGVGcm9tVmFyaWFibGVTdHJpbmciLCJ1bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnRUb2tlbnNGcm9tTWV0YXN0YXRlbWVudFN0cmluZyIsInVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zRnJvbVN0YXRlbWVudFN0cmluZyIsInZhcmlhYmxlRGVjbGFyYXRpb25Ub2tlbnNGcm9tVmFyaWFibGVTdHJpbmciLCJ2YXJpYWJsZU5vZGVGcm9tVmFyaWFibGVTdHJpbmciLCJmbG9yZW5jZUxleGVyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hciIsImxleGVyc1V0aWxpdGllcyIsImZsb3JlbmNlUGFyc2VyRnJvbUNvbWJpbmVkQ3VzdG9tR3JhbW1hciIsInBhcnNlcnNVdGlsaXRpZXMiLCJjb21iaW5lZEN1c3RvbUdyYW1tYXIiLCJjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tTm90aGluZyIsImZsb3JlbmNlTGV4ZXIiLCJmbG9yZW5jZVBhcnNlciIsInRlcm1Ob2RlUXVlcnkiLCJub2RlUXVlcnkiLCJ0eXBlTm9kZVF1ZXJ5IiwidmFyaWFibGVOb2RlUXVlcnkiLCJtZXRhVHlwZU5vZGVRdWVyeSIsInN0YXRlbWVudE5vZGVRdWVyeSIsIm1ldGF2YXJpYWJsZU5vZGVRdWVyeSIsIm1ldGFzdGF0ZW1lbnROb2RlUXVlcnkiLCJsYWJlbFN0cmluZyIsImxleGVyIiwibGFiZWxDb250ZW50IiwibGFiZWxUb2tlbnMiLCJ0b2tlbnNGcm9tQ29udGVudEFuZExleGVyIiwidGVybVN0cmluZyIsImNvbnN0cnVjdG9yRGVjbGFyYXRpb25Db250ZW50IiwiY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyIsInZhcmlhYmxlU3RyaW5nIiwidmFyaWFibGVEZWNsYXJhdGlvbkNvbnRlbnQiLCJ2YXJpYWJsZURlY2xhcmF0aW9uVG9rZW5zIiwic3RhdGVtZW50U3RyaW5nIiwidW5xdWFsaWZpZWRTdGF0ZW1lbnRDb250ZW50IiwidW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMiLCJtZXRhdmFyaWFibGVTdHJpbmciLCJtZXRhdmFyaWFibGVEZWNsYXJhdGlvbkNvbnRlbnQiLCJtZXRhdmFyaWFibGVEZWNsYXJhdGlvblRva2VucyIsIm1ldGFzdGF0ZW1lbnRTdHJpbmciLCJ1bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnRDb250ZW50IiwidW5xdWFsaWZpZWRNZXRhc3RhdGVtZW50VG9rZW5zIiwicGFyc2VyIiwicnVsZU5hbWUiLCJDT05TVFJVQ1RPUl9ERUNMQVJBVElPTl9SVUxFX05BTUUiLCJjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSIsIm5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIiLCJ0ZXJtTm9kZSIsIkxBQkVMX1JVTEVfTkFNRSIsImxhYmVsTm9kZSIsIlRZUEVfUlVMRV9OQU1FIiwidHlwZURlY2xhcmF0aW9uTm9kZSIsInR5cGVOb2RlIiwiVkFSSUFCTEVfUlVMRV9OQU1FIiwidmFyaWFibGVURGVjbGFyYXRpb25Ub2tlbnMiLCJ2YXJpYWJsZURlY2xhcmF0aW9uTm9kZSIsInZhcmlhYmxlTm9kZSIsIlVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUiLCJ1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUiLCJzdGF0ZW1lbnROb2RlIiwiTUVUQV9UWVBFX1JVTEVfTkFNRSIsIm1ldGFUeXBlRGVjbGFyYXRpb25Ob2RlIiwibWV0YVR5cGVOb2RlIiwiTUVUQVZBUklBQkxFX1JVTEVfTkFNRSIsIm1ldGF2YXJpYWJsZURlY2xhcmF0aW9uTm9kZSIsIm1ldGF2YXJpYWJsZU5vZGUiLCJVTlFVQUxJRklFRF9NRVRBU1RBVEVNRU5UX1JVTEVfTkFNRSIsInVucXVhbGlmaWVkTWV0YXN0YXRlbWVudE5vZGUiLCJtZXRhc3RhdGVtZW50Tm9kZSIsImNvbnRlbnQiLCJ0b2tlbnMiLCJ0b2tlbmlzZSIsInJ1bGVNYXAiLCJnZXRSdWxlTWFwIiwicnVsZSIsIm5vZGUiLCJwYXJzZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0lBc0NnQkEsMENBQTBDO2VBQTFDQTs7SUFpREFDLHdCQUF3QjtlQUF4QkE7O0lBeERBQywwQkFBMEI7ZUFBMUJBOztJQTJGQUMsa0NBQWtDO2VBQWxDQTs7SUFrQkFDLHdDQUF3QztlQUF4Q0E7O0lBOUVBQyxtREFBbUQ7ZUFBbkRBOztJQXFFQUMsc0NBQXNDO2VBQXRDQTs7SUFsQkFDLGdDQUFnQztlQUFoQ0E7O0lBbkNBQyxzQkFBc0I7ZUFBdEJBOztJQWlCQUMsMEJBQTBCO2VBQTFCQTs7SUF6QkFDLHFEQUFxRDtlQUFyREE7O0lBaEJBQyw2Q0FBNkM7ZUFBN0NBOztJQVJBQywyQ0FBMkM7ZUFBM0NBOztJQTBEQUMsOEJBQThCO2VBQTlCQTs7O21DQXRHa0M7cUJBRXhCO3lCQVEwQjs2QkFFSDtBQUVqRCxJQUFNLEFBQUVDLHlDQUEyQ0Msb0NBQWUsQ0FBMURELHdDQUNGLEFBQUVFLDBDQUE0Q0MscUNBQWdCLENBQTVERDtBQUVSLElBQU1FLHdCQUF3QkMsSUFBQUEsK0NBQWdDLEtBQ3hEQyxnQkFBZ0JOLHVDQUF1Q0ksd0JBQ3ZERyxpQkFBaUJMLHdDQUF3Q0U7QUFFL0QsSUFBTUksZ0JBQWdCQyxJQUFBQSxnQkFBUyxFQUFDLGtDQUMxQkMsZ0JBQWdCRCxJQUFBQSxnQkFBUyxFQUFDLCtCQUMxQkUsb0JBQW9CRixJQUFBQSxn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