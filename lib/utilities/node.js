"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    constructorDeclarationNodeFromConstructorDeclarationTokens: function() {
        return constructorDeclarationNodeFromConstructorDeclarationTokens;
    },
    statementNodeFromStatementString: function() {
        return statementNodeFromStatementString;
    },
    statementNodeFromUnqualifiedStatementTokens: function() {
        return statementNodeFromUnqualifiedStatementTokens;
    },
    termNodeFromConstructorDeclarationTokens: function() {
        return termNodeFromConstructorDeclarationTokens;
    },
    termNodeFromTermString: function() {
        return termNodeFromTermString;
    },
    unqualifiedStatementNodeFromUnqualifiedStatementTokens: function() {
        return unqualifiedStatementNodeFromUnqualifiedStatementTokens;
    }
});
var _occamcustomgrammars = require("occam-custom-grammars");
var _query = require("../utilities/query");
var _customGrammar = require("./customGrammar");
var _ruleNames = require("../ruleNames");
var _tokens = require("../utilities/tokens");
var florenceParserFromCombinedCustomGrammar = _occamcustomgrammars.parsersUtilities.florenceParserFromCombinedCustomGrammar;
var combinedCustomGrammar = (0, _customGrammar.combinedCustomGrammarFromNothing)(), florenceParser = florenceParserFromCombinedCustomGrammar(combinedCustomGrammar);
var termNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/term!"), statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement!");
function termNodeFromTermString(termString, lexer, parser) {
    var constructorDeclarationTokens = (0, _tokens.constructorDeclarationTokensFromTermString)(termString, lexer), termNode = termNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser);
    return termNode;
}
function statementNodeFromStatementString(statementString, lexer, parser) {
    var unqualifiedStatementTokens = (0, _tokens.unqualifiedStatementTokensFromStatementString)(statementString, lexer), statementNode = statementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser);
    return statementNode;
}
function termNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser) {
    var constructorDeclarationNode = constructorDeclarationNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser), termNode = termNodeQuery(constructorDeclarationNode);
    return termNode;
}
function statementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser) {
    var unqualifiedStatementNode = unqualifiedStatementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser), statementNode = statementNodeQuery(unqualifiedStatementNode);
    return statementNode;
}
function unqualifiedStatementNodeFromUnqualifiedStatementTokens(unqualifiedStatementTokens, parser) {
    var ruleName = _ruleNames.UNQUALIFIED_STATEMENT_RULE_NAME, unqualifiedStatementNode = nodeFromTokensRuleNameAndParser(unqualifiedStatementTokens, ruleName, parser);
    return unqualifiedStatementNode;
}
function constructorDeclarationNodeFromConstructorDeclarationTokens(constructorDeclarationTokens, parser) {
    var ruleName = _ruleNames.CONSTRUCTOR_DECLARATION_RULE_NAME, constructorDeclarationNode = nodeFromTokensRuleNameAndParser(constructorDeclarationTokens, ruleName, parser);
    return constructorDeclarationNode;
}
function nodeFromTokensRuleNameAndParser(tokens, ruleName) {
    var parser = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : florenceParser;
    var ruleMap = parser.getRuleMap(), rule = ruleMap[ruleName], node = parser.parse(tokens, rule);
    return node;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGFyc2Vyc1V0aWxpdGllcyB9IGZyb20gXCJvY2NhbS1jdXN0b20tZ3JhbW1hcnNcIjtcblxuaW1wb3J0IHsgbm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgY29tYmluZWRDdXN0b21HcmFtbWFyRnJvbU5vdGhpbmcgfSBmcm9tIFwiLi9jdXN0b21HcmFtbWFyXCI7XG5pbXBvcnQgeyBVTlFVQUxJRklFRF9TVEFURU1FTlRfUlVMRV9OQU1FLCBDT05TVFJVQ1RPUl9ERUNMQVJBVElPTl9SVUxFX05BTUUgfSBmcm9tIFwiLi4vcnVsZU5hbWVzXCI7XG5pbXBvcnQgeyBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zRnJvbVRlcm1TdHJpbmcsIHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zRnJvbVN0YXRlbWVudFN0cmluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvdG9rZW5zXCI7XG5cbmNvbnN0IHsgZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyIH0gPSBwYXJzZXJzVXRpbGl0aWVzO1xuXG5jb25zdCBjb21iaW5lZEN1c3RvbUdyYW1tYXIgPSBjb21iaW5lZEN1c3RvbUdyYW1tYXJGcm9tTm90aGluZygpLFxuICAgICAgZmxvcmVuY2VQYXJzZXIgPSBmbG9yZW5jZVBhcnNlckZyb21Db21iaW5lZEN1c3RvbUdyYW1tYXIoY29tYmluZWRDdXN0b21HcmFtbWFyKTtcblxuY29uc3QgdGVybU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9jb25zdHJ1Y3RvckRlY2xhcmF0aW9uL3Rlcm0hXCIpLFxuICAgICAgc3RhdGVtZW50Tm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3VucXVhbGlmaWVkU3RhdGVtZW50L3N0YXRlbWVudCFcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtTm9kZUZyb21UZXJtU3RyaW5nKHRlcm1TdHJpbmcsIGxleGVyLCBwYXJzZXIpIHtcbiAgY29uc3QgY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyA9IGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnNGcm9tVGVybVN0cmluZyh0ZXJtU3RyaW5nLCBsZXhlciksXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVGcm9tQ29uc3RydWN0b3JEZWNsYXJhdGlvblRva2Vucyhjb25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zLCBwYXJzZXIpO1xuXG4gIHJldHVybiB0ZXJtTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlbWVudE5vZGVGcm9tU3RhdGVtZW50U3RyaW5nKHN0YXRlbWVudFN0cmluZywgbGV4ZXIsIHBhcnNlcikge1xuICBjb25zdCB1bnF1YWxpZmllZFN0YXRlbWVudFRva2VucyA9IHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zRnJvbVN0YXRlbWVudFN0cmluZyhzdGF0ZW1lbnRTdHJpbmcsIGxleGVyKSxcbiAgICAgICAgc3RhdGVtZW50Tm9kZSA9IHN0YXRlbWVudE5vZGVGcm9tVW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnModW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMsIHBhcnNlcik7XG5cbiAgcmV0dXJuIHN0YXRlbWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtTm9kZUZyb21Db25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMsIHBhcnNlcikge1xuICBjb25zdCBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSA9IGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlRnJvbUNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMoY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucywgcGFyc2VyKSxcbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKTtcblxuICByZXR1cm4gdGVybU5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZW1lbnROb2RlRnJvbVVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zKHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zLCBwYXJzZXIpIHtcbiAgY29uc3QgdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlID0gdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlRnJvbVVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zKHVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zLCBwYXJzZXIpLFxuICAgICAgICBzdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50Tm9kZVF1ZXJ5KHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHN0YXRlbWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGVGcm9tVW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnModW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IFVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUsXG4gICAgICAgIHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSA9IG5vZGVGcm9tVG9rZW5zUnVsZU5hbWVBbmRQYXJzZXIodW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIpO1xuXG4gIHJldHVybiB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZUZyb21Db25zdHJ1Y3RvckRlY2xhcmF0aW9uVG9rZW5zKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMsIHBhcnNlcikge1xuICBjb25zdCBydWxlTmFtZSA9IENPTlNUUlVDVE9SX0RFQ0xBUkFUSU9OX1JVTEVfTkFNRSxcbiAgICAgICAgY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUgPSBub2RlRnJvbVRva2Vuc1J1bGVOYW1lQW5kUGFyc2VyKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIpO1xuXG4gIHJldHVybiBjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZTtcbn1cblxuZnVuY3Rpb24gbm9kZUZyb21Ub2tlbnNSdWxlTmFtZUFuZFBhcnNlcih0b2tlbnMsIHJ1bGVOYW1lLCBwYXJzZXIgPSBmbG9yZW5jZVBhcnNlcikge1xuICBjb25zdCBydWxlTWFwID0gcGFyc2VyLmdldFJ1bGVNYXAoKSxcbiAgICAgICAgcnVsZSA9IHJ1bGVNYXBbcnVsZU5hbWVdLFxuICAgICAgICBub2RlID0gcGFyc2VyLnBhcnNlKHRva2VucywgcnVsZSk7XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4iXSwibmFtZXMiOlsiY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGVGcm9tQ29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyIsInN0YXRlbWVudE5vZGVGcm9tU3RhdGVtZW50U3RyaW5nIiwic3RhdGVtZW50Tm9kZUZyb21VbnF1YWxpZmllZFN0YXRlbWVudFRva2VucyIsInRlcm1Ob2RlRnJvbUNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnMiLCJ0ZXJtTm9kZUZyb21UZXJtU3RyaW5nIiwidW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlRnJvbVVucXVhbGlmaWVkU3RhdGVtZW50VG9rZW5zIiwiZmxvcmVuY2VQYXJzZXJGcm9tQ29tYmluZWRDdXN0b21HcmFtbWFyIiwicGFyc2Vyc1V0aWxpdGllcyIsImNvbWJpbmVkQ3VzdG9tR3JhbW1hciIsImNvbWJpbmVkQ3VzdG9tR3JhbW1hckZyb21Ob3RoaW5nIiwiZmxvcmVuY2VQYXJzZXIiLCJ0ZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5Iiwic3RhdGVtZW50Tm9kZVF1ZXJ5IiwidGVybVN0cmluZyIsImxleGVyIiwicGFyc2VyIiwiY29uc3RydWN0b3JEZWNsYXJhdGlvblRva2VucyIsImNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ub2tlbnNGcm9tVGVybVN0cmluZyIsInRlcm1Ob2RlIiwic3RhdGVtZW50U3RyaW5nIiwidW5xdWFsaWZpZWRTdGF0ZW1lbnRUb2tlbnMiLCJ1bnF1YWxpZmllZFN0YXRlbWVudFRva2Vuc0Zyb21TdGF0ZW1lbnRTdHJpbmciLCJzdGF0ZW1lbnROb2RlIiwiY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUiLCJ1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUiLCJydWxlTmFtZSIsIlVOUVVBTElGSUVEX1NUQVRFTUVOVF9SVUxFX05BTUUiLCJub2RlRnJvbVRva2Vuc1J1bGVOYW1lQW5kUGFyc2VyIiwiQ09OU1RSVUNUT1JfREVDTEFSQVRJT05fUlVMRV9OQU1FIiwidG9rZW5zIiwicnVsZU1hcCIsImdldFJ1bGVNYXAiLCJydWxlIiwibm9kZSIsInBhcnNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7SUFvRGdCQSwwREFBMEQ7ZUFBMURBOztJQTVCQUMsZ0NBQWdDO2VBQWhDQTs7SUFjQUMsMkNBQTJDO2VBQTNDQTs7SUFQQUMsd0NBQXdDO2VBQXhDQTs7SUFkQUMsc0JBQXNCO2VBQXRCQTs7SUE0QkFDLHNEQUFzRDtlQUF0REE7OzttQ0EzQ2lCO3FCQUVQOzZCQUN1Qjt5QkFDa0M7c0JBQ3VCO0FBRTFHLElBQU0sQUFBRUMsMENBQTRDQyxxQ0FBZ0IsQ0FBNUREO0FBRVIsSUFBTUUsd0JBQXdCQyxJQUFBQSwrQ0FBZ0MsS0FDeERDLGlCQUFpQkosd0NBQXdDRTtBQUUvRCxJQUFNRyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsa0NBQzFCQyxxQkFBcUJELElBQUFBLGdCQUFTLEVBQUM7QUFFOUIsU0FBU1IsdUJBQXVCVSxVQUFVLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUM5RCxJQUFNQywrQkFBK0JDLElBQUFBLGtEQUEwQyxFQUFDSixZQUFZQyxRQUN0RkksV0FBV2hCLHlDQUF5Q2MsOEJBQThCRDtJQUV4RixPQUFPRztBQUNUO0FBRU8sU0FBU2xCLGlDQUFpQ21CLGVBQWUsRUFBRUwsS0FBSyxFQUFFQyxNQUFNO0lBQzdFLElBQU1LLDZCQUE2QkMsSUFBQUEscURBQTZDLEVBQUNGLGlCQUFpQkwsUUFDNUZRLGdCQUFnQnJCLDRDQUE0Q21CLDRCQUE0Qkw7SUFFOUYsT0FBT087QUFDVDtBQUVPLFNBQVNwQix5Q0FBeUNjLDRCQUE0QixFQUFFRCxNQUFNO0lBQzNGLElBQU1RLDZCQUE2QnhCLDJEQUEyRGlCLDhCQUE4QkQsU0FDdEhHLFdBQVdSLGNBQWNhO0lBRS9CLE9BQU9MO0FBQ1Q7QUFFTyxTQUFTakIsNENBQTRDbUIsMEJBQTBCLEVBQUVMLE1BQU07SUFDNUYsSUFBTVMsMkJBQTJCcEIsdURBQXVEZ0IsNEJBQTRCTCxTQUM5R08sZ0JBQWdCVixtQkFBbUJZO0lBRXpDLE9BQU9GO0FBQ1Q7QUFFTyxTQUFTbEIsdURBQXVEZ0IsMEJBQTBCLEVBQUVMLE1BQU07SUFDdkcsSUFBTVUsV0FBV0MsMENBQStCLEVBQzFDRiwyQkFBMkJHLGdDQUFnQ1AsNEJBQTRCSyxVQUFVVjtJQUV2RyxPQUFPUztBQUNUO0FBRU8sU0FBU3pCLDJEQUEyRGlCLDRCQUE0QixFQUFFRCxNQUFNO0lBQzdHLElBQU1VLFdBQVdHLDRDQUFpQyxFQUM1Q0wsNkJBQTZCSSxnQ0FBZ0NYLDhCQUE4QlMsVUFBVVY7SUFFM0csT0FBT1E7QUFDVDtBQUVBLFNBQVNJLGdDQUFnQ0UsTUFBTSxFQUFFSixRQUFRO1FBQUVWLFNBQUFBLGlFQUFTTjtJQUNsRSxJQUFNcUIsVUFBVWYsT0FBT2dCLFVBQVUsSUFDM0JDLE9BQU9GLE9BQU8sQ0FBQ0wsU0FBUyxFQUN4QlEsT0FBT2xCLE9BQU9tQixLQUFLLENBQUNMLFFBQVFHO0lBRWxDLE9BQU9DO0FBQ1QifQ==