"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    checkCyclicDependencyExists: function() {
        return checkCyclicDependencyExists;
    },
    checkReleaseMatchesShortenedVersion: function() {
        return checkReleaseMatchesShortenedVersion;
    },
    default: function() {
        return _default;
    }
});
var _necessary = require("necessary");
var first = _necessary.arrayUtilities.first;
function checkCyclicDependencyExists(name, dependentNames, releaseContext) {
    var dependentNamesIncludesName = dependentNames.includes(name), cyclicDependencyExists = dependentNamesIncludesName; ///
    if (cyclicDependencyExists) {
        var firstDependentName = first(dependentNames), dependencyNames = dependentNames.concat(firstDependentName), dependencyNamesString = dependencyNames.join("' -> '");
        releaseContext.error("There is a cyclic dependency: '".concat(dependencyNamesString, "'."));
    }
    return cyclicDependencyExists;
}
function checkReleaseMatchesShortenedVersion(releaseContext, shortenedVersion) {
    var release = releaseContext.getRelease(), releaseMatchesShortedVersion = release.matchShortenedVersion(shortenedVersion);
    if (!releaseMatchesShortedVersion) {
        var name = releaseContext.getName(), version = releaseContext.getVersion(), versionString = version.toString(), shortenedVersionString = shortenedVersion.toString();
        releaseContext.error("The '".concat(name, "' package's version of ").concat(versionString, " does not match the dependency's shortened version of ").concat(shortenedVersionString, "."));
    }
    return releaseMatchesShortedVersion;
}
var _default = {
    checkCyclicDependencyExists: checkCyclicDependencyExists,
    checkReleaseMatchesShortenedVersion: checkReleaseMatchesShortenedVersion
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvdmVyaWZpY2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBhcnJheVV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuY29uc3QgeyBmaXJzdCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0N5Y2xpY0RlcGVuZGVuY3lFeGlzdHMobmFtZSwgZGVwZW5kZW50TmFtZXMsIHJlbGVhc2VDb250ZXh0KSB7XG4gIGNvbnN0IGRlcGVuZGVudE5hbWVzSW5jbHVkZXNOYW1lID0gZGVwZW5kZW50TmFtZXMuaW5jbHVkZXMobmFtZSksXG4gICAgICAgIGN5Y2xpY0RlcGVuZGVuY3lFeGlzdHMgPSBkZXBlbmRlbnROYW1lc0luY2x1ZGVzTmFtZTsgIC8vL1xuXG4gIGlmIChjeWNsaWNEZXBlbmRlbmN5RXhpc3RzKSB7XG4gICAgY29uc3QgZmlyc3REZXBlbmRlbnROYW1lID0gZmlyc3QoZGVwZW5kZW50TmFtZXMpLFxuICAgICAgICAgIGRlcGVuZGVuY3lOYW1lcyA9IGRlcGVuZGVudE5hbWVzLmNvbmNhdChmaXJzdERlcGVuZGVudE5hbWUpLFxuICAgICAgICAgIGRlcGVuZGVuY3lOYW1lc1N0cmluZyA9IGRlcGVuZGVuY3lOYW1lcy5qb2luKGAnIC0+ICdgKTtcblxuICAgIHJlbGVhc2VDb250ZXh0LmVycm9yKGBUaGVyZSBpcyBhIGN5Y2xpYyBkZXBlbmRlbmN5OiAnJHtkZXBlbmRlbmN5TmFtZXNTdHJpbmd9Jy5gKTtcbiAgfVxuXG4gIHJldHVybiBjeWNsaWNEZXBlbmRlbmN5RXhpc3RzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZWxlYXNlTWF0Y2hlc1Nob3J0ZW5lZFZlcnNpb24ocmVsZWFzZUNvbnRleHQsIHNob3J0ZW5lZFZlcnNpb24pIHtcbiAgY29uc3QgcmVsZWFzZSA9IHJlbGVhc2VDb250ZXh0LmdldFJlbGVhc2UoKSxcbiAgICAgICAgcmVsZWFzZU1hdGNoZXNTaG9ydGVkVmVyc2lvbiA9IHJlbGVhc2UubWF0Y2hTaG9ydGVuZWRWZXJzaW9uKHNob3J0ZW5lZFZlcnNpb24pO1xuXG4gIGlmICghcmVsZWFzZU1hdGNoZXNTaG9ydGVkVmVyc2lvbikge1xuICAgIGNvbnN0IG5hbWUgPSByZWxlYXNlQ29udGV4dC5nZXROYW1lKCksXG4gICAgICAgICAgdmVyc2lvbiA9IHJlbGVhc2VDb250ZXh0LmdldFZlcnNpb24oKSxcbiAgICAgICAgICB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAgIHNob3J0ZW5lZFZlcnNpb25TdHJpbmcgPSBzaG9ydGVuZWRWZXJzaW9uLnRvU3RyaW5nKCk7XG5cbiAgICByZWxlYXNlQ29udGV4dC5lcnJvcihgVGhlICcke25hbWV9JyBwYWNrYWdlJ3MgdmVyc2lvbiBvZiAke3ZlcnNpb25TdHJpbmd9IGRvZXMgbm90IG1hdGNoIHRoZSBkZXBlbmRlbmN5J3Mgc2hvcnRlbmVkIHZlcnNpb24gb2YgJHtzaG9ydGVuZWRWZXJzaW9uU3RyaW5nfS5gKTtcbiAgfVxuXG4gIHJldHVybiByZWxlYXNlTWF0Y2hlc1Nob3J0ZWRWZXJzaW9uO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNoZWNrQ3ljbGljRGVwZW5kZW5jeUV4aXN0cyxcbiAgY2hlY2tSZWxlYXNlTWF0Y2hlc1Nob3J0ZW5lZFZlcnNpb25cbn07XG4iXSwibmFtZXMiOlsiY2hlY2tDeWNsaWNEZXBlbmRlbmN5RXhpc3RzIiwiY2hlY2tSZWxlYXNlTWF0Y2hlc1Nob3J0ZW5lZFZlcnNpb24iLCJmaXJzdCIsImFycmF5VXRpbGl0aWVzIiwibmFtZSIsImRlcGVuZGVudE5hbWVzIiwicmVsZWFzZUNvbnRleHQiLCJkZXBlbmRlbnROYW1lc0luY2x1ZGVzTmFtZSIsImluY2x1ZGVzIiwiY3ljbGljRGVwZW5kZW5jeUV4aXN0cyIsImZpcnN0RGVwZW5kZW50TmFtZSIsImRlcGVuZGVuY3lOYW1lcyIsImNvbmNhdCIsImRlcGVuZGVuY3lOYW1lc1N0cmluZyIsImpvaW4iLCJlcnJvciIsInNob3J0ZW5lZFZlcnNpb24iLCJyZWxlYXNlIiwiZ2V0UmVsZWFzZSIsInJlbGVhc2VNYXRjaGVzU2hvcnRlZFZlcnNpb24iLCJtYXRjaFNob3J0ZW5lZFZlcnNpb24iLCJnZXROYW1lIiwidmVyc2lvbiIsImdldFZlcnNpb24iLCJ2ZXJzaW9uU3RyaW5nIiwidG9TdHJpbmciLCJzaG9ydGVuZWRWZXJzaW9uU3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7SUFNZ0JBLDJCQUEyQjtlQUEzQkE7O0lBZUFDLG1DQUFtQztlQUFuQ0E7O0lBZ0JoQixPQUdFO2VBSEY7Ozt5QkFuQytCO0FBRS9CLElBQU0sQUFBRUMsUUFBVUMseUJBQWMsQ0FBeEJEO0FBRUQsU0FBU0YsNEJBQTRCSSxJQUFJLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFO0lBQ2hGLElBQU1DLDZCQUE2QkYsZUFBZUcsUUFBUSxDQUFDSixPQUNyREsseUJBQXlCRiw0QkFBNkIsR0FBRztJQUUvRCxJQUFJRSx3QkFBd0I7UUFDMUIsSUFBTUMscUJBQXFCUixNQUFNRyxpQkFDM0JNLGtCQUFrQk4sZUFBZU8sTUFBTSxDQUFDRixxQkFDeENHLHdCQUF3QkYsZ0JBQWdCRyxJQUFJLENBQUU7UUFFcERSLGVBQWVTLEtBQUssQ0FBQyxBQUFDLGtDQUF1RCxPQUF0QkYsdUJBQXNCO0lBQy9FLENBQUM7SUFFRCxPQUFPSjtBQUNUO0FBRU8sU0FBU1Isb0NBQW9DSyxjQUFjLEVBQUVVLGdCQUFnQixFQUFFO0lBQ3BGLElBQU1DLFVBQVVYLGVBQWVZLFVBQVUsSUFDbkNDLCtCQUErQkYsUUFBUUcscUJBQXFCLENBQUNKO0lBRW5FLElBQUksQ0FBQ0csOEJBQThCO1FBQ2pDLElBQU1mLE9BQU9FLGVBQWVlLE9BQU8sSUFDN0JDLFVBQVVoQixlQUFlaUIsVUFBVSxJQUNuQ0MsZ0JBQWdCRixRQUFRRyxRQUFRLElBQ2hDQyx5QkFBeUJWLGlCQUFpQlMsUUFBUTtRQUV4RG5CLGVBQWVTLEtBQUssQ0FBQyxBQUFDLFFBQXFDUyxPQUE5QnBCLE1BQUssMkJBQStGc0IsT0FBdEVGLGVBQWMsMERBQStFLE9BQXZCRSx3QkFBdUI7SUFDMUosQ0FBQztJQUVELE9BQU9QO0FBQ1Q7SUFFQSxXQUFlO0lBQ2JuQiw2QkFBQUE7SUFDQUMscUNBQUFBO0FBQ0YifQ==