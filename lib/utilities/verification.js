"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    stripBracketsFromStatement: function() {
        return stripBracketsFromStatement;
    },
    subproofAssertionFromStatement: function() {
        return subproofAssertionFromStatement;
    }
});
var _shim = /*#__PURE__*/ _interop_require_default(require("../shim"));
var _local = /*#__PURE__*/ _interop_require_default(require("../context/local"));
var _subproof = /*#__PURE__*/ _interop_require_default(require("../assertion/subproof"));
var _brackets = require("../utilities/brackets");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function stripBracketsFromStatement(statement, context) {
    var statementNode = statement.getNode(), bracketedStatementChildNode = (0, _brackets.bracketedStatementChildNodeFromStatementNode)(statementNode);
    if (bracketedStatementChildNode !== null) {
        var statementTokens = statement.getTokens(), tokens = statementTokens, localContext = _local.default.fromContextAndTokens(context, tokens);
        context = localContext; ///
        var Statement = _shim.default.Statement, statementNode1 = bracketedStatementChildNode; ///
        statement = Statement.fromStatementNode(statementNode1, context);
    }
    return statement;
}
function subproofAssertionFromStatement(statement, context) {
    var statementTokens = statement.getTokens(), tokens = statementTokens, localContext = _local.default.fromContextAndTokens(context, tokens);
    context = localContext; ///
    var statementNode = statement.getNode(), subproofAssertion = _subproof.default.fromStatementNode(statementNode, context);
    return subproofAssertion;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvdmVyaWZpY2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgc2hpbSBmcm9tIFwiLi4vc2hpbVwiO1xuaW1wb3J0IExvY2FsQ29udGV4dCBmcm9tIFwiLi4vY29udGV4dC9sb2NhbFwiO1xuaW1wb3J0IFN1YnByb29mQXNzZXJ0aW9uIGZyb20gXCIuLi9hc3NlcnRpb24vc3VicHJvb2ZcIjtcblxuaW1wb3J0IHsgYnJhY2tldGVkU3RhdGVtZW50Q2hpbGROb2RlRnJvbVN0YXRlbWVudE5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2JyYWNrZXRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEJyYWNrZXRzRnJvbVN0YXRlbWVudChzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3Qgc3RhdGVtZW50Tm9kZSA9IHN0YXRlbWVudC5nZXROb2RlKCksXG4gICAgICAgIGJyYWNrZXRlZFN0YXRlbWVudENoaWxkTm9kZSA9IGJyYWNrZXRlZFN0YXRlbWVudENoaWxkTm9kZUZyb21TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmIChicmFja2V0ZWRTdGF0ZW1lbnRDaGlsZE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRUb2tlbnMgPSBzdGF0ZW1lbnQuZ2V0VG9rZW5zKCksXG4gICAgICAgICAgdG9rZW5zID0gc3RhdGVtZW50VG9rZW5zLCAvLy9cbiAgICAgICAgICBsb2NhbENvbnRleHQgPSBMb2NhbENvbnRleHQuZnJvbUNvbnRleHRBbmRUb2tlbnMoY29udGV4dCwgdG9rZW5zKTtcblxuICAgIGNvbnRleHQgPSBsb2NhbENvbnRleHQ7IC8vL1xuXG4gICAgY29uc3QgeyBTdGF0ZW1lbnQgfSA9IHNoaW0sXG4gICAgICAgICAgc3RhdGVtZW50Tm9kZSA9IGJyYWNrZXRlZFN0YXRlbWVudENoaWxkTm9kZTsgIC8vL1xuXG4gICAgc3RhdGVtZW50ID0gU3RhdGVtZW50LmZyb21TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnByb29mQXNzZXJ0aW9uRnJvbVN0YXRlbWVudChzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3Qgc3RhdGVtZW50VG9rZW5zID0gc3RhdGVtZW50LmdldFRva2VucygpLFxuICAgICAgICB0b2tlbnMgPSBzdGF0ZW1lbnRUb2tlbnMsIC8vL1xuICAgICAgICBsb2NhbENvbnRleHQgPSBMb2NhbENvbnRleHQuZnJvbUNvbnRleHRBbmRUb2tlbnMoY29udGV4dCwgdG9rZW5zKTtcblxuICBjb250ZXh0ID0gbG9jYWxDb250ZXh0OyAvLy9cblxuICBjb25zdCBzdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50LmdldE5vZGUoKSxcbiAgICAgICAgc3VicHJvb2ZBc3NlcnRpb24gPSBTdWJwcm9vZkFzc2VydGlvbi5mcm9tU3RhdGVtZW50Tm9kZShzdGF0ZW1lbnROb2RlLCBjb250ZXh0KTtcblxuICByZXR1cm4gc3VicHJvb2ZBc3NlcnRpb247XG59XG4iXSwibmFtZXMiOlsic3RyaXBCcmFja2V0c0Zyb21TdGF0ZW1lbnQiLCJzdWJwcm9vZkFzc2VydGlvbkZyb21TdGF0ZW1lbnQiLCJzdGF0ZW1lbnQiLCJjb250ZXh0Iiwic3RhdGVtZW50Tm9kZSIsImdldE5vZGUiLCJicmFja2V0ZWRTdGF0ZW1lbnRDaGlsZE5vZGUiLCJicmFja2V0ZWRTdGF0ZW1lbnRDaGlsZE5vZGVGcm9tU3RhdGVtZW50Tm9kZSIsInN0YXRlbWVudFRva2VucyIsImdldFRva2VucyIsInRva2VucyIsImxvY2FsQ29udGV4dCIsIkxvY2FsQ29udGV4dCIsImZyb21Db250ZXh0QW5kVG9rZW5zIiwiU3RhdGVtZW50Iiwic2hpbSIsImZyb21TdGF0ZW1lbnROb2RlIiwic3VicHJvb2ZBc3NlcnRpb24iLCJTdWJwcm9vZkFzc2VydGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0lBUWdCQSwwQkFBMEI7ZUFBMUJBOztJQW9CQUMsOEJBQThCO2VBQTlCQTs7OzJEQTFCQzs0REFDUTsrREFDSzt3QkFFK0I7Ozs7OztBQUV0RCxTQUFTRCwyQkFBMkJFLFNBQVMsRUFBRUMsT0FBTztJQUMzRCxJQUFNQyxnQkFBZ0JGLFVBQVVHLE9BQU8sSUFDakNDLDhCQUE4QkMsSUFBQUEsc0RBQTRDLEVBQUNIO0lBRWpGLElBQUlFLGdDQUFnQyxNQUFNO1FBQ3hDLElBQU1FLGtCQUFrQk4sVUFBVU8sU0FBUyxJQUNyQ0MsU0FBU0YsaUJBQ1RHLGVBQWVDLGNBQVksQ0FBQ0Msb0JBQW9CLENBQUNWLFNBQVNPO1FBRWhFUCxVQUFVUSxjQUFjLEdBQUc7UUFFM0IsSUFBTSxBQUFFRyxZQUFjQyxhQUFJLENBQWxCRCxXQUNGVixpQkFBZ0JFLDZCQUE4QixHQUFHO1FBRXZESixZQUFZWSxVQUFVRSxpQkFBaUIsQ0FBQ1osZ0JBQWVEO0lBQ3pEO0lBRUEsT0FBT0Q7QUFDVDtBQUVPLFNBQVNELCtCQUErQkMsU0FBUyxFQUFFQyxPQUFPO0lBQy9ELElBQU1LLGtCQUFrQk4sVUFBVU8sU0FBUyxJQUNyQ0MsU0FBU0YsaUJBQ1RHLGVBQWVDLGNBQVksQ0FBQ0Msb0JBQW9CLENBQUNWLFNBQVNPO0lBRWhFUCxVQUFVUSxjQUFjLEdBQUc7SUFFM0IsSUFBTVAsZ0JBQWdCRixVQUFVRyxPQUFPLElBQ2pDWSxvQkFBb0JDLGlCQUFpQixDQUFDRixpQkFBaUIsQ0FBQ1osZUFBZUQ7SUFFN0UsT0FBT2M7QUFDVCJ9