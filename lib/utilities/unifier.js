"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    areTerminalNodeMapsEqual: function() {
        return areTerminalNodeMapsEqual;
    },
    terminalNodeMapFromNodes: function() {
        return terminalNodeMapFromNodes;
    }
});
var _necessary = require("necessary");
var match = _necessary.arrayUtilities.match;
function terminalNodeMapFromNodes(nodes) {
    var terminalNodeMap = {};
    nodes.forEach(function(node, index) {
        var nodeTerminalNode = node.isTerminalNode();
        if (nodeTerminalNode) {
            var terminalNode = node; //
            terminalNodeMap[index] = terminalNode;
        }
    });
    return terminalNodeMap;
}
function areTerminalNodeMapsEqual(generalTerminalNodeMap, specificTerminalNodeMap) {
    var terminalNodeMapsEqual = false;
    var generalIndexes = Object.keys(generalTerminalNodeMap), specificIndexes = Object.keys(specificTerminalNodeMap), terminalNodeMapKeysMatch = match(generalIndexes, specificIndexes, function(generalIndex, specificIndex) {
        if (generalIndex === specificIndex) {
            return true;
        }
    });
    if (terminalNodeMapKeysMatch) {
        var generalTerminalNodes = Object.values(generalTerminalNodeMap), specificTerminalNodes = Object.values(specificTerminalNodeMap), terminalNodeMapValuesMatch = match(generalTerminalNodes, specificTerminalNodes, function(generalTerminalNode, specficTerminalNode) {
            var generalTerminalNodeMatchesSpecificTerminalNode = generalTerminalNode.match(specficTerminalNode);
            if (generalTerminalNodeMatchesSpecificTerminalNode) {
                return true;
            }
        });
        terminalNodeMapsEqual = terminalNodeMapValuesMatch; ///
    }
    return terminalNodeMapsEqual;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvdW5pZmllci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgYXJyYXlVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmNvbnN0IHsgbWF0Y2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVybWluYWxOb2RlTWFwRnJvbU5vZGVzKG5vZGVzKSB7XG4gIGNvbnN0IHRlcm1pbmFsTm9kZU1hcCA9IHt9O1xuXG4gIG5vZGVzLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgbm9kZVRlcm1pbmFsTm9kZSA9IG5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICAgIGlmIChub2RlVGVybWluYWxOb2RlKSB7XG4gICAgICBjb25zdCB0ZXJtaW5hbE5vZGUgPSBub2RlOyAgLy9cblxuICAgICAgdGVybWluYWxOb2RlTWFwW2luZGV4XSA9IHRlcm1pbmFsTm9kZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXJtaW5hbE5vZGVNYXA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVUZXJtaW5hbE5vZGVNYXBzRXF1YWwoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCwgc3BlY2lmaWNUZXJtaW5hbE5vZGVNYXApIHtcbiAgbGV0IHRlcm1pbmFsTm9kZU1hcHNFcXVhbCA9IGZhbHNlO1xuXG4gIGNvbnN0IGdlbmVyYWxJbmRleGVzID0gT2JqZWN0LmtleXMoZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCksIC8vL1xuICAgICAgICBzcGVjaWZpY0luZGV4ZXMgPSBPYmplY3Qua2V5cyhzcGVjaWZpY1Rlcm1pbmFsTm9kZU1hcCksIC8vL1xuICAgICAgICB0ZXJtaW5hbE5vZGVNYXBLZXlzTWF0Y2ggPSBtYXRjaChnZW5lcmFsSW5kZXhlcywgc3BlY2lmaWNJbmRleGVzLCAoZ2VuZXJhbEluZGV4LCBzcGVjaWZpY0luZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGdlbmVyYWxJbmRleCA9PT0gc3BlY2lmaWNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICBpZiAodGVybWluYWxOb2RlTWFwS2V5c01hdGNoKSB7XG4gICAgY29uc3QgZ2VuZXJhbFRlcm1pbmFsTm9kZXMgPSBPYmplY3QudmFsdWVzKGdlbmVyYWxUZXJtaW5hbE5vZGVNYXApLCAvLy9cbiAgICAgICAgICBzcGVjaWZpY1Rlcm1pbmFsTm9kZXMgPSBPYmplY3QudmFsdWVzKHNwZWNpZmljVGVybWluYWxOb2RlTWFwKSwgLy8vXG4gICAgICAgICAgdGVybWluYWxOb2RlTWFwVmFsdWVzTWF0Y2ggPSBtYXRjaChnZW5lcmFsVGVybWluYWxOb2Rlcywgc3BlY2lmaWNUZXJtaW5hbE5vZGVzLCAoZ2VuZXJhbFRlcm1pbmFsTm9kZSwgc3BlY2ZpY1Rlcm1pbmFsTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhbFRlcm1pbmFsTm9kZU1hdGNoZXNTcGVjaWZpY1Rlcm1pbmFsTm9kZSA9IGdlbmVyYWxUZXJtaW5hbE5vZGUubWF0Y2goc3BlY2ZpY1Rlcm1pbmFsTm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChnZW5lcmFsVGVybWluYWxOb2RlTWF0Y2hlc1NwZWNpZmljVGVybWluYWxOb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgdGVybWluYWxOb2RlTWFwc0VxdWFsID0gdGVybWluYWxOb2RlTWFwVmFsdWVzTWF0Y2g7IC8vL1xuICB9XG5cbiAgcmV0dXJuIHRlcm1pbmFsTm9kZU1hcHNFcXVhbDtcbn1cbiJdLCJuYW1lcyI6WyJhcmVUZXJtaW5hbE5vZGVNYXBzRXF1YWwiLCJ0ZXJtaW5hbE5vZGVNYXBGcm9tTm9kZXMiLCJtYXRjaCIsImFycmF5VXRpbGl0aWVzIiwibm9kZXMiLCJ0ZXJtaW5hbE5vZGVNYXAiLCJmb3JFYWNoIiwibm9kZSIsImluZGV4Iiwibm9kZVRlcm1pbmFsTm9kZSIsImlzVGVybWluYWxOb2RlIiwidGVybWluYWxOb2RlIiwiZ2VuZXJhbFRlcm1pbmFsTm9kZU1hcCIsInNwZWNpZmljVGVybWluYWxOb2RlTWFwIiwidGVybWluYWxOb2RlTWFwc0VxdWFsIiwiZ2VuZXJhbEluZGV4ZXMiLCJPYmplY3QiLCJrZXlzIiwic3BlY2lmaWNJbmRleGVzIiwidGVybWluYWxOb2RlTWFwS2V5c01hdGNoIiwiZ2VuZXJhbEluZGV4Iiwic3BlY2lmaWNJbmRleCIsImdlbmVyYWxUZXJtaW5hbE5vZGVzIiwidmFsdWVzIiwic3BlY2lmaWNUZXJtaW5hbE5vZGVzIiwidGVybWluYWxOb2RlTWFwVmFsdWVzTWF0Y2giLCJnZW5lcmFsVGVybWluYWxOb2RlIiwic3BlY2ZpY1Rlcm1pbmFsTm9kZSIsImdlbmVyYWxUZXJtaW5hbE5vZGVNYXRjaGVzU3BlY2lmaWNUZXJtaW5hbE5vZGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQXNCZ0JBLHdCQUF3QjtlQUF4QkE7O0lBaEJBQyx3QkFBd0I7ZUFBeEJBOzs7eUJBSmU7QUFFL0IsSUFBTSxBQUFFQyxRQUFVQyx5QkFBYyxDQUF4QkQ7QUFFRCxTQUFTRCx5QkFBeUJHLEtBQUs7SUFDNUMsSUFBTUMsa0JBQWtCLENBQUM7SUFFekJELE1BQU1FLE9BQU8sQ0FBQyxTQUFDQyxNQUFNQztRQUNuQixJQUFNQyxtQkFBbUJGLEtBQUtHLGNBQWM7UUFFNUMsSUFBSUQsa0JBQWtCO1lBQ3BCLElBQU1FLGVBQWVKLE1BQU8sRUFBRTtZQUU5QkYsZUFBZSxDQUFDRyxNQUFNLEdBQUdHO1FBQzNCO0lBQ0Y7SUFFQSxPQUFPTjtBQUNUO0FBRU8sU0FBU0wseUJBQXlCWSxzQkFBc0IsRUFBRUMsdUJBQXVCO0lBQ3RGLElBQUlDLHdCQUF3QjtJQUU1QixJQUFNQyxpQkFBaUJDLE9BQU9DLElBQUksQ0FBQ0wseUJBQzdCTSxrQkFBa0JGLE9BQU9DLElBQUksQ0FBQ0osMEJBQzlCTSwyQkFBMkJqQixNQUFNYSxnQkFBZ0JHLGlCQUFpQixTQUFDRSxjQUFjQztRQUMvRSxJQUFJRCxpQkFBaUJDLGVBQWU7WUFDbEMsT0FBTztRQUNUO0lBQ0Y7SUFFTixJQUFJRiwwQkFBMEI7UUFDNUIsSUFBTUcsdUJBQXVCTixPQUFPTyxNQUFNLENBQUNYLHlCQUNyQ1ksd0JBQXdCUixPQUFPTyxNQUFNLENBQUNWLDBCQUN0Q1ksNkJBQTZCdkIsTUFBTW9CLHNCQUFzQkUsdUJBQXVCLFNBQUNFLHFCQUFxQkM7WUFDcEcsSUFBTUMsaURBQWlERixvQkFBb0J4QixLQUFLLENBQUN5QjtZQUVqRixJQUFJQyxnREFBZ0Q7Z0JBQ2xELE9BQU87WUFDVDtRQUNGO1FBRU5kLHdCQUF3QlcsNEJBQTRCLEdBQUc7SUFDekQ7SUFFQSxPQUFPWDtBQUNUIn0=