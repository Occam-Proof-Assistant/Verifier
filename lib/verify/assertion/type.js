"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyTypeAssertion;
    }
});
var _variable = /*#__PURE__*/ _interopRequireDefault(require("../../variable"));
var _type = /*#__PURE__*/ _interopRequireDefault(require("../../assertion/type"));
var _array = require("../../utilities/array");
var _query = require("../../utilities/query");
var _term = require("../../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type");
function verifyTypeAssertion(typeAssertionNode, assertions, derived, proofContext) {
    var typeAssertionVerified = false;
    var typeAssertionString = proofContext.nodeAsString(typeAssertionNode);
    proofContext.debug("Verifying the '".concat(typeAssertionString, "' type assertion..."), typeAssertionNode);
    var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
    if (!typePresent) {
        proofContext.error("The ".concat(typeName, " type is not present."), typeAssertionNode);
    } else {
        if (!typeAssertionVerified) {
            var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, assertions, derived, proofContext);
            typeAssertionVerified = variableTypeAssertionVerified; ///
        }
        if (!typeAssertionVerified) {
            var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, proofContext);
            typeAssertionVerified = termTypeAssertionVerified; ///
        }
    }
    if (typeAssertionVerified) {
        proofContext.info("Verified the '".concat(typeAssertionString, "' statement type assertion."), typeAssertionNode);
    }
    return typeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, assertions, derived, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode), termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
    if (termVerifiedAsVariable) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName);
        if (assertedType === null) {
            proofContext.error("The '".concat(assertedTypeName, "' asserted type is not present."), typeAssertionNode);
        } else {
            var firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType();
            if (derived) {
                var variableTypeEqualToOrSubTypeOfAssertedType = variableType.isEqualToOrSubTypeOf(assertedType);
                if (!variableTypeEqualToOrSubTypeOfAssertedType) {
                    var assertedTypeName1 = assertedType.getName(), variableTypeName = variableType.getName();
                    proofContext.error("The '".concat(variableName, "' variable's '").concat(variableTypeName, "' type is not equal to or a sub-type of the '").concat(assertedTypeName1, "' asserted type."), typeAssertionNode);
                } else {
                    variableTypeAssertionVerified = true;
                }
            } else {
                var assertedTypeEqualToOrSubTypeOfVariableType = assertedType.isEqualToOrSubTypeOf(variableType);
                if (!assertedTypeEqualToOrSubTypeOfVariableType) {
                    var assertedTypeName2 = assertedType.getName(), variableTypeName1 = variableType.getName();
                    proofContext.error("The '".concat(assertedTypeName2, "' asserted type is not equal to or a sub-type of the '").concat(variableName, "' variable's '").concat(variableTypeName1, "' type."), typeAssertionNode);
                } else {
                    var type = assertedType, name = variableName, variable1 = _variable.default.fromTypeAndName(type, name), typeAssertion = _type.default.fromVariable(variable1), assertion = typeAssertion; ///
                    assertions.push(assertion);
                    variableTypeAssertionVerified = true;
                }
            }
        }
    }
    return variableTypeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName);
        if (assertedType === null) {
            proofContext.error("The '".concat(assertedTypeName, "' asserted type is not present."), typeAssertionNode);
        } else {
            var firstType = (0, _array.first)(types), termType = firstType, termTypeIsEqualToAssertedType = termType.isEqualTo(assertedType);
            if (!termTypeIsEqualToAssertedType) {
                var termString = proofContext.nodeAsString(termNode), termTypeName = termType.getName(), assertedTypeName1 = assertedType.getName();
                proofContext.error("The '".concat(assertedTypeName1, "' asserted type is not equal to the '").concat(termString, "' term's '").concat(termTypeName, "' type."), typeAssertionNode);
            } else {
                termTypeAssertionVerified = true;
            }
        }
    }
    return termTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvYXNzZXJ0aW9uL3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBWYXJpYWJsZSBmcm9tIFwiLi4vLi4vdmFyaWFibGVcIjtcbmltcG9ydCBUeXBlQXNzZXJ0aW9uIGZyb20gXCIuLi8uLi9hc3NlcnRpb24vdHlwZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG5vZGVRdWVyeSwgdHlwZU5hbWVGcm9tVHlwZU5vZGUgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyB2ZXJpZnlUZXJtQXNWYXJpYWJsZSwgdmVyaWZ5VGVybUFnYWluc3RDb25zdHJ1Y3RvcnMgfSBmcm9tIFwiLi4vLi4vdmVyaWZ5L3Rlcm1cIjtcblxuY29uc3QgdGVybU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlQXNzZXJ0aW9uL3Rlcm1cIiksXG4gICAgICB0eXBlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3R5cGVBc3NlcnRpb24vdHlwZVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5VHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzZXJ0aW9ucywgZGVyaXZlZCwgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlQXNzZXJ0aW9uU3RyaW5nID0gcHJvb2ZDb250ZXh0Lm5vZGVBc1N0cmluZyh0eXBlQXNzZXJ0aW9uTm9kZSk7XG5cbiAgcHJvb2ZDb250ZXh0LmRlYnVnKGBWZXJpZnlpbmcgdGhlICcke3R5cGVBc3NlcnRpb25TdHJpbmd9JyB0eXBlIGFzc2VydGlvbi4uLmAsIHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgdHlwZVByZXNlbnQgPSBwcm9vZkNvbnRleHQuaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUodHlwZU5hbWUpO1xuXG4gIGlmICghdHlwZVByZXNlbnQpIHtcbiAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAke3R5cGVOYW1lfSB0eXBlIGlzIG5vdCBwcmVzZW50LmAsIHR5cGVBc3NlcnRpb25Ob2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVBc3NlcnRpb25WZXJpZmllZCkge1xuICAgICAgY29uc3QgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIGRlcml2ZWQsIHByb29mQ29udGV4dCk7XG5cbiAgICAgIHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkOyAgLy8vXG4gICAgfVxuXG4gICAgaWYgKCF0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcHJvb2ZDb250ZXh0KTtcblxuICAgICAgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZDsgIC8vL1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICBwcm9vZkNvbnRleHQuaW5mbyhgVmVyaWZpZWQgdGhlICcke3R5cGVBc3NlcnRpb25TdHJpbmd9JyBzdGF0ZW1lbnQgdHlwZSBhc3NlcnRpb24uYCwgdHlwZUFzc2VydGlvbk5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBhc3NlcnRpb25zLCBkZXJpdmVkLCBwcm9vZkNvbnRleHQpIHtcbiAgbGV0IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgY29udGV4dCA9IHByb29mQ29udGV4dCwgLy8vXG4gICAgICAgIHZhcmlhYmxlcyA9IFtdLFxuICAgICAgICB0ZXJtTm9kZSA9IHRlcm1Ob2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICB0ZXJtVmVyaWZpZWRBc1ZhcmlhYmxlID0gdmVyaWZ5VGVybUFzVmFyaWFibGUodGVybU5vZGUsIHZhcmlhYmxlcywgY29udGV4dCk7XG5cbiAgaWYgKHRlcm1WZXJpZmllZEFzVmFyaWFibGUpIHtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICAgIGFzc2VydGVkVHlwZU5hbWUgPSB0eXBlTmFtZSwgIC8vL1xuICAgICAgICAgIGFzc2VydGVkVHlwZSA9IHByb29mQ29udGV4dC5maW5kVHlwZUJ5VHlwZU5hbWUoYXNzZXJ0ZWRUeXBlTmFtZSk7XG5cbiAgICBpZiAoYXNzZXJ0ZWRUeXBlID09PSBudWxsKSB7XG4gICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAnJHthc3NlcnRlZFR5cGVOYW1lfScgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgcHJlc2VudC5gLCB0eXBlQXNzZXJ0aW9uTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0VmFyaWFibGUgPSBmaXJzdCh2YXJpYWJsZXMpLFxuICAgICAgICAgICAgdmFyaWFibGUgPSBmaXJzdFZhcmlhYmxlLCAvLy9cbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IHZhcmlhYmxlLmdldFR5cGUoKTtcblxuICAgICAgaWYgKGRlcml2ZWQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVUeXBlRXF1YWxUb09yU3ViVHlwZU9mQXNzZXJ0ZWRUeXBlID0gdmFyaWFibGVUeXBlLmlzRXF1YWxUb09yU3ViVHlwZU9mKGFzc2VydGVkVHlwZSk7XG5cbiAgICAgICAgaWYgKCF2YXJpYWJsZVR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZBc3NlcnRlZFR5cGUpIHtcbiAgICAgICAgICBjb25zdCBhc3NlcnRlZFR5cGVOYW1lID0gYXNzZXJ0ZWRUeXBlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVR5cGVOYW1lID0gdmFyaWFibGVUeXBlLmdldE5hbWUoKTtcblxuICAgICAgICAgIHByb29mQ29udGV4dC5lcnJvcihgVGhlICcke3ZhcmlhYmxlTmFtZX0nIHZhcmlhYmxlJ3MgJyR7dmFyaWFibGVUeXBlTmFtZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvIG9yIGEgc3ViLXR5cGUgb2YgdGhlICcke2Fzc2VydGVkVHlwZU5hbWV9JyBhc3NlcnRlZCB0eXBlLmAsIHR5cGVBc3NlcnRpb25Ob2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSA9IGFzc2VydGVkVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih2YXJpYWJsZVR5cGUpO1xuXG4gICAgICAgIGlmICghYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlKSB7XG4gICAgICAgICAgY29uc3QgYXNzZXJ0ZWRUeXBlTmFtZSA9IGFzc2VydGVkVHlwZS5nZXROYW1lKCksXG4gICAgICAgICAgICAgICAgdmFyaWFibGVUeXBlTmFtZSA9IHZhcmlhYmxlVHlwZS5nZXROYW1lKCk7XG5cbiAgICAgICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAnJHthc3NlcnRlZFR5cGVOYW1lfScgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gb3IgYSBzdWItdHlwZSBvZiB0aGUgJyR7dmFyaWFibGVOYW1lfScgdmFyaWFibGUncyAnJHt2YXJpYWJsZVR5cGVOYW1lfScgdHlwZS5gLCB0eXBlQXNzZXJ0aW9uTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGFzc2VydGVkVHlwZSwgIC8vL1xuICAgICAgICAgICAgICAgIG5hbWUgPSB2YXJpYWJsZU5hbWUsICAvLy9cbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IFZhcmlhYmxlLmZyb21UeXBlQW5kTmFtZSh0eXBlLCBuYW1lKSxcbiAgICAgICAgICAgICAgICB0eXBlQXNzZXJ0aW9uID0gVHlwZUFzc2VydGlvbi5mcm9tVmFyaWFibGUodmFyaWFibGUpLFxuICAgICAgICAgICAgICAgIGFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb247ICAvLy9cblxuICAgICAgICAgIGFzc2VydGlvbnMucHVzaChhc3NlcnRpb24pO1xuXG4gICAgICAgICAgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZXMgPSBbXSxcbiAgICAgICAgY29udGV4dCA9IHByb29mQ29udGV4dCwgLy8vXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMgPSB2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyh0ZXJtTm9kZSwgdHlwZXMsIGNvbnRleHQpO1xuXG4gIGlmICh0ZXJtVmVyaWZpZWRBZ2FpbnN0Q29uc3RydWN0b3JzKSB7XG4gICAgY29uc3QgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gdHlwZU5hbWUsICAvLy9cbiAgICAgICAgICBhc3NlcnRlZFR5cGUgPSBwcm9vZkNvbnRleHQuZmluZFR5cGVCeVR5cGVOYW1lKGFzc2VydGVkVHlwZU5hbWUpO1xuXG4gICAgaWYgKGFzc2VydGVkVHlwZSA9PT0gbnVsbCkge1xuICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgJyR7YXNzZXJ0ZWRUeXBlTmFtZX0nIGFzc2VydGVkIHR5cGUgaXMgbm90IHByZXNlbnQuYCwgdHlwZUFzc2VydGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaXJzdFR5cGUgPSBmaXJzdCh0eXBlcyksXG4gICAgICAgICAgICB0ZXJtVHlwZSA9IGZpcnN0VHlwZSwgLy8vXG4gICAgICAgICAgICB0ZXJtVHlwZUlzRXF1YWxUb0Fzc2VydGVkVHlwZSA9IHRlcm1UeXBlLmlzRXF1YWxUbyhhc3NlcnRlZFR5cGUpO1xuXG4gICAgICBpZiAoIXRlcm1UeXBlSXNFcXVhbFRvQXNzZXJ0ZWRUeXBlKSB7XG4gICAgICAgIGNvbnN0IHRlcm1TdHJpbmcgPSBwcm9vZkNvbnRleHQubm9kZUFzU3RyaW5nKHRlcm1Ob2RlKSxcbiAgICAgICAgICAgICAgdGVybVR5cGVOYW1lID0gdGVybVR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gYXNzZXJ0ZWRUeXBlLmdldE5hbWUoKTtcblxuICAgICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAnJHthc3NlcnRlZFR5cGVOYW1lfScgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGVOYW1lfScgdHlwZS5gLCB0eXBlQXNzZXJ0aW9uTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cblxuIl0sIm5hbWVzIjpbInZlcmlmeVR5cGVBc3NlcnRpb24iLCJ0ZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidHlwZU5vZGVRdWVyeSIsInR5cGVBc3NlcnRpb25Ob2RlIiwiYXNzZXJ0aW9ucyIsImRlcml2ZWQiLCJwcm9vZkNvbnRleHQiLCJ0eXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJ0eXBlQXNzZXJ0aW9uU3RyaW5nIiwibm9kZUFzU3RyaW5nIiwiZGVidWciLCJ0eXBlTm9kZSIsInR5cGVOYW1lIiwidHlwZU5hbWVGcm9tVHlwZU5vZGUiLCJ0eXBlUHJlc2VudCIsImlzVHlwZVByZXNlbnRCeVR5cGVOYW1lIiwiZXJyb3IiLCJ2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVZhcmlhYmxlVHlwZUFzc2VydGlvbiIsInRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJ2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbiIsImluZm8iLCJjb250ZXh0IiwidmFyaWFibGVzIiwidGVybU5vZGUiLCJ0ZXJtVmVyaWZpZWRBc1ZhcmlhYmxlIiwidmVyaWZ5VGVybUFzVmFyaWFibGUiLCJhc3NlcnRlZFR5cGVOYW1lIiwiYXNzZXJ0ZWRUeXBlIiwiZmluZFR5cGVCeVR5cGVOYW1lIiwiZmlyc3RWYXJpYWJsZSIsImZpcnN0IiwidmFyaWFibGUiLCJ2YXJpYWJsZU5hbWUiLCJnZXROYW1lIiwidmFyaWFibGVUeXBlIiwiZ2V0VHlwZSIsInZhcmlhYmxlVHlwZUVxdWFsVG9PclN1YlR5cGVPZkFzc2VydGVkVHlwZSIsImlzRXF1YWxUb09yU3ViVHlwZU9mIiwidmFyaWFibGVUeXBlTmFtZSIsImFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSIsInR5cGUiLCJuYW1lIiwiVmFyaWFibGUiLCJmcm9tVHlwZUFuZE5hbWUiLCJ0eXBlQXNzZXJ0aW9uIiwiVHlwZUFzc2VydGlvbiIsImZyb21WYXJpYWJsZSIsImFzc2VydGlvbiIsInB1c2giLCJ0eXBlcyIsInRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMiLCJ2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyIsImZpcnN0VHlwZSIsInRlcm1UeXBlIiwidGVybVR5cGVJc0VxdWFsVG9Bc3NlcnRlZFR5cGUiLCJpc0VxdWFsVG8iLCJ0ZXJtU3RyaW5nIiwidGVybVR5cGVOYW1lIl0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFZQTs7O2VBQXdCQTs7OzZEQVZIO3lEQUNLO3FCQUVKO3FCQUMwQjtvQkFDb0I7Ozs7OztBQUVwRSxJQUFNQyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsd0JBQzFCQyxnQkFBZ0JELElBQUFBLGdCQUFTLEVBQUM7QUFFakIsU0FBU0Ysb0JBQW9CSSxpQkFBaUIsRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLFlBQVksRUFBRTtJQUNoRyxJQUFJQyx3QkFBd0IsS0FBSztJQUVqQyxJQUFNQyxzQkFBc0JGLGFBQWFHLFlBQVksQ0FBQ047SUFFdERHLGFBQWFJLEtBQUssQ0FBQyxBQUFDLGtCQUFxQyxPQUFwQkYscUJBQW9CLHdCQUFzQkw7SUFFL0UsSUFBTVEsV0FBV1QsY0FBY0Msb0JBQ3pCUyxXQUFXQyxJQUFBQSwyQkFBb0IsRUFBQ0YsV0FDaENHLGNBQWNSLGFBQWFTLHVCQUF1QixDQUFDSDtJQUV6RCxJQUFJLENBQUNFLGFB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