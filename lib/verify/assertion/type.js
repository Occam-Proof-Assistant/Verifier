"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyTypeAssertion;
    }
});
var _type = /*#__PURE__*/ _interopRequireDefault(require("../../assertion/type"));
var _array = require("../../utilities/array");
var _string = require("../../utilities/string");
var _query = require("../../utilities/query");
var _term = require("../../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type");
function verifyTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var typeAssertionVerified = false;
    proofContext.begin(typeAssertionNode);
    var typeAssertionString = proofContext.nodeAsString(typeAssertionNode);
    proofContext.debug("Verifying the '".concat(typeAssertionString, "' type assertion..."));
    var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
    if (!typePresent) {
        proofContext.error("The ".concat(typeName, " type is not present."));
    } else {
        if (!typeAssertionVerified) {
            var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, assertions, proofContext);
            typeAssertionVerified = variableTypeAssertionVerified; ///
        }
        if (!typeAssertionVerified) {
            var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, assertions, proofContext);
            typeAssertionVerified = termTypeAssertionVerified; ///
        }
    }
    if (typeAssertionVerified) {
        proofContext.info("Verified the '".concat(typeAssertionString, "' statement type assertion."));
    }
    typeAssertionVerified ? proofContext.complete(typeAssertionNode) : proofContext.halt(typeAssertionNode);
    return typeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode), termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
    if (termVerifiedAsVariable) {
        if (assertions === null) {
            variableTypeAssertionVerified = true;
        } else {
            var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType(), assertedTypeEqualToOrSubTypeOfVariableType = assertedType.isEqualToOrSubTypeOf(variableType);
            if (!assertedTypeEqualToOrSubTypeOfVariableType) {
                var assertedTypeName1 = assertedType.getName(), variableTypeName = variableType.getName();
                proofContext.error("The '".concat(assertedTypeName1, "' asserted type is not equal to or a sub-type of the '").concat(variableName, "' variable's '").concat(variableTypeName, "' type."));
            } else {
                var type = assertedType, typeAssertion = _type.default.fromTypeAndVariableName(type, variableName), assertion = typeAssertion; ///
                assertions.push(assertion);
                variableTypeAssertionVerified = true;
            }
        }
    }
    return variableTypeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        if (assertions === null) {
            termTypeAssertionVerified = true;
        } else {
            var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstType = (0, _array.first)(types), termType = firstType, termString = proofContext.nodeAsString(termNode), assertedTypeEqualToTermType = termType === null ? true : assertedType.isEqualTo(termType);
            if (!assertedTypeEqualToTermType) {
                var termTypeName = termType.getName(), assertedTypeName1 = assertedType.getName();
                proofContext.error("The '".concat(assertedTypeName1, "' asserted type is not equal to the '").concat(termString, "' term's '").concat(termTypeName, "' type."));
            } else {
                var type = assertedType, typeAssertion = _type.default.fromTypeAndTermNode(type, termNode), assertion = typeAssertion; ///
                assertions.push(assertion);
                termTypeAssertionVerified = true;
            }
        }
    }
    return termTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvYXNzZXJ0aW9uL3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUeXBlQXNzZXJ0aW9uIGZyb20gXCIuLi8uLi9hc3NlcnRpb24vdHlwZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG5vZGVBc1N0cmluZyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIHR5cGVOYW1lRnJvbVR5cGVOb2RlIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgdmVyaWZ5VGVybUFzVmFyaWFibGUsIHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzIH0gZnJvbSBcIi4uLy4uL3ZlcmlmeS90ZXJtXCI7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdHlwZUFzc2VydGlvbi90ZXJtXCIpLFxuICAgICAgdHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlQXNzZXJ0aW9uL3R5cGVcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIHByb29mQ29udGV4dCkge1xuICBsZXQgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgcHJvb2ZDb250ZXh0LmJlZ2luKHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICBjb25zdCB0eXBlQXNzZXJ0aW9uU3RyaW5nID0gcHJvb2ZDb250ZXh0Lm5vZGVBc1N0cmluZyh0eXBlQXNzZXJ0aW9uTm9kZSk7XG5cbiAgcHJvb2ZDb250ZXh0LmRlYnVnKGBWZXJpZnlpbmcgdGhlICcke3R5cGVBc3NlcnRpb25TdHJpbmd9JyB0eXBlIGFzc2VydGlvbi4uLmApO1xuXG4gIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICB0eXBlUHJlc2VudCA9IHByb29mQ29udGV4dC5pc1R5cGVQcmVzZW50QnlUeXBlTmFtZSh0eXBlTmFtZSk7XG5cbiAgaWYgKCF0eXBlUHJlc2VudCkge1xuICAgIHByb29mQ29udGV4dC5lcnJvcihgVGhlICR7dHlwZU5hbWV9IHR5cGUgaXMgbm90IHByZXNlbnQuYCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBhc3NlcnRpb25zLCBwcm9vZkNvbnRleHQpO1xuXG4gICAgICB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZDsgIC8vL1xuICAgIH1cblxuICAgIGlmICghdHlwZUFzc2VydGlvblZlcmlmaWVkKSB7XG4gICAgICBjb25zdCB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VGVybVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIHByb29mQ29udGV4dCk7XG5cbiAgICAgIHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7ICAvLy9cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZUFzc2VydGlvblZlcmlmaWVkKSB7XG4gICAgcHJvb2ZDb250ZXh0LmluZm8oYFZlcmlmaWVkIHRoZSAnJHt0eXBlQXNzZXJ0aW9uU3RyaW5nfScgc3RhdGVtZW50IHR5cGUgYXNzZXJ0aW9uLmApO1xuICB9XG5cbiAgdHlwZUFzc2VydGlvblZlcmlmaWVkID9cbiAgICBwcm9vZkNvbnRleHQuY29tcGxldGUodHlwZUFzc2VydGlvbk5vZGUpIDpcbiAgICAgIHByb29mQ29udGV4dC5oYWx0KHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICByZXR1cm4gdHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIHByb29mQ29udGV4dCkge1xuICBsZXQgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBjb250ZXh0ID0gcHJvb2ZDb250ZXh0LCAvLy9cbiAgICAgICAgdmFyaWFibGVzID0gW10sXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHRlcm1WZXJpZmllZEFzVmFyaWFibGUgPSB2ZXJpZnlUZXJtQXNWYXJpYWJsZSh0ZXJtTm9kZSwgdmFyaWFibGVzLCBjb250ZXh0KTtcblxuICBpZiAodGVybVZlcmlmaWVkQXNWYXJpYWJsZSkge1xuICAgIGlmIChhc3NlcnRpb25zID09PSBudWxsKSB7XG4gICAgICB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgICAgIGFzc2VydGVkVHlwZU5hbWUgPSB0eXBlTmFtZSwgIC8vL1xuICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlID0gcHJvb2ZDb250ZXh0LmZpbmRUeXBlQnlUeXBlTmFtZShhc3NlcnRlZFR5cGVOYW1lKSxcbiAgICAgICAgICAgIGZpcnN0VmFyaWFibGUgPSBmaXJzdCh2YXJpYWJsZXMpLFxuICAgICAgICAgICAgdmFyaWFibGUgPSBmaXJzdFZhcmlhYmxlLCAvLy9cbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmdldE5hbWUoKSxcbiAgICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IHZhcmlhYmxlLmdldFR5cGUoKSxcbiAgICAgICAgICAgIGFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSA9IGFzc2VydGVkVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih2YXJpYWJsZVR5cGUpO1xuXG4gICAgICBpZiAoIWFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSkge1xuICAgICAgICBjb25zdCBhc3NlcnRlZFR5cGVOYW1lID0gYXNzZXJ0ZWRUeXBlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgdmFyaWFibGVUeXBlTmFtZSA9IHZhcmlhYmxlVHlwZS5nZXROYW1lKCk7XG5cbiAgICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgJyR7YXNzZXJ0ZWRUeXBlTmFtZX0nIGFzc2VydGVkIHR5cGUgaXMgbm90IGVxdWFsIHRvIG9yIGEgc3ViLXR5cGUgb2YgdGhlICcke3ZhcmlhYmxlTmFtZX0nIHZhcmlhYmxlJ3MgJyR7dmFyaWFibGVUeXBlTmFtZX0nIHR5cGUuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlID0gYXNzZXJ0ZWRUeXBlLCAgLy8vXG4gICAgICAgICAgICAgIHR5cGVBc3NlcnRpb24gPSBUeXBlQXNzZXJ0aW9uLmZyb21UeXBlQW5kVmFyaWFibGVOYW1lKHR5cGUsIHZhcmlhYmxlTmFtZSksXG4gICAgICAgICAgICAgIGFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb247ICAvLy9cblxuICAgICAgICBhc3NlcnRpb25zLnB1c2goYXNzZXJ0aW9uKTtcblxuICAgICAgICB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzZXJ0aW9ucywgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZXMgPSBbXSxcbiAgICAgICAgY29udGV4dCA9IHByb29mQ29udGV4dCwgLy8vXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMgPSB2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyh0ZXJtTm9kZSwgdHlwZXMsIGNvbnRleHQpO1xuXG4gIGlmICh0ZXJtVmVyaWZpZWRBZ2FpbnN0Q29uc3RydWN0b3JzKSB7XG4gICAgaWYgKGFzc2VydGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICAgICAgdHlwZU5hbWUgPSB0eXBlTmFtZUZyb21UeXBlTm9kZSh0eXBlTm9kZSksXG4gICAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gdHlwZU5hbWUsICAvLy9cbiAgICAgICAgICAgIGFzc2VydGVkVHlwZSA9IHByb29mQ29udGV4dC5maW5kVHlwZUJ5VHlwZU5hbWUoYXNzZXJ0ZWRUeXBlTmFtZSksXG4gICAgICAgICAgICBmaXJzdFR5cGUgPSBmaXJzdCh0eXBlcyksXG4gICAgICAgICAgICB0ZXJtVHlwZSA9IGZpcnN0VHlwZSxcbiAgICAgICAgICAgIHRlcm1TdHJpbmcgPSBwcm9vZkNvbnRleHQubm9kZUFzU3RyaW5nKHRlcm1Ob2RlKSxcbiAgICAgICAgICAgIGFzc2VydGVkVHlwZUVxdWFsVG9UZXJtVHlwZSA9ICh0ZXJtVHlwZSA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRlZFR5cGUuaXNFcXVhbFRvKHRlcm1UeXBlKTtcblxuICAgICAgaWYgKCFhc3NlcnRlZFR5cGVFcXVhbFRvVGVybVR5cGUpIHtcbiAgICAgICAgY29uc3QgdGVybVR5cGVOYW1lID0gdGVybVR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gYXNzZXJ0ZWRUeXBlLmdldE5hbWUoKTtcblxuICAgICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAnJHthc3NlcnRlZFR5cGVOYW1lfScgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gdGhlICcke3Rlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7dGVybVR5cGVOYW1lfScgdHlwZS5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhc3NlcnRlZFR5cGUsICAvLy9cbiAgICAgICAgICAgICAgdHlwZUFzc2VydGlvbiA9IFR5cGVBc3NlcnRpb24uZnJvbVR5cGVBbmRUZXJtTm9kZSh0eXBlLCB0ZXJtTm9kZSksXG4gICAgICAgICAgICAgIGFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb247ICAvLy9cblxuICAgICAgICBhc3NlcnRpb25zLnB1c2goYXNzZXJ0aW9uKTtcblxuICAgICAgICB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cblxuIl0sIm5hbWVzIjpbInZlcmlmeVR5cGVBc3NlcnRpb24iLCJ0ZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidHlwZU5vZGVRdWVyeSIsInR5cGVBc3NlcnRpb25Ob2RlIiwiYXNzZXJ0aW9ucyIsInByb29mQ29udGV4dCIsInR5cGVBc3NlcnRpb25WZXJpZmllZCIsImJlZ2luIiwidHlwZUFzc2VydGlvblN0cmluZyIsIm5vZGVBc1N0cmluZyIsImRlYnVnIiwidHlwZU5vZGUiLCJ0eXBlTmFtZSIsInR5cGVOYW1lRnJvbVR5cGVOb2RlIiwidHlwZVByZXNlbnQiLCJpc1R5cGVQcmVzZW50QnlUeXBlTmFtZSIsImVycm9yIiwidmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJ2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24iLCJ0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VGVybVR5cGVBc3NlcnRpb24iLCJpbmZvIiwiY29tcGxldGUiLCJoYWx0IiwiY29udGV4dCIsInZhcmlhYmxlcyIsInRlcm1Ob2RlIiwidGVybVZlcmlmaWVkQXNWYXJpYWJsZSIsInZlcmlmeVRlcm1Bc1ZhcmlhYmxlIiwiYXNzZXJ0ZWRUeXBlTmFtZSIsImFzc2VydGVkVHlwZSIsImZpbmRUeXBlQnlUeXBlTmFtZSIsImZpcnN0VmFyaWFibGUiLCJmaXJzdCIsInZhcmlhYmxlIiwidmFyaWFibGVOYW1lIiwiZ2V0TmFtZSIsInZhcmlhYmxlVHlwZSIsImdldFR5cGUiLCJhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZWYXJpYWJsZVR5cGUiLCJpc0VxdWFsVG9PclN1YlR5cGVPZiIsInZhcmlhYmxlVHlwZU5hbWUiLCJ0eXBlIiwidHlwZUFzc2VydGlvbiIsIlR5cGVBc3NlcnRpb24iLCJmcm9tVHlwZUFuZFZhcmlhYmxlTmFtZSIsImFzc2VydGlvbiIsInB1c2giLCJ0eXBlcyIsInRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMiLCJ2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyIsImZpcnN0VHlwZSIsInRlcm1UeXBlIiwidGVybVN0cmluZyIsImFzc2VydGVkVHlwZUVxdWFsVG9UZXJtVHlwZSIsImlzRXF1YWxUbyIsInRlcm1UeXBlTmFtZSIsImZyb21UeXBlQW5kVGVy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