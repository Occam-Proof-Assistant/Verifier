"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyTypeAssertion;
    }
});
var _type = /*#__PURE__*/ _interopRequireDefault(require("../../assertion/type"));
var _array = require("../../utilities/array");
var _string = require("../../utilities/string");
var _query = require("../../utilities/query");
var _term = require("../../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type");
function verifyTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var typeAssertionVerified = false;
    proofContext.begin(typeAssertionNode);
    var typeAssertionString = (0, _string.nodeAsString)(typeAssertionNode);
    proofContext.debug("Verifying the '".concat(typeAssertionString, "' type assertion..."));
    var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
    if (!typePresent) {
        proofContext.error("The ".concat(typeName, " type is not present."));
    } else {
        if (!typeAssertionVerified) {
            var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, assertions, proofContext);
            typeAssertionVerified = variableTypeAssertionVerified; ///
        }
        if (!typeAssertionVerified) {
            var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, assertions, proofContext);
            typeAssertionVerified = termTypeAssertionVerified; ///
        }
    }
    if (typeAssertionVerified) {
        proofContext.info("Verified the '".concat(typeAssertionString, "' statement type assertion."));
    }
    typeAssertionVerified ? proofContext.complete(typeAssertionNode) : proofContext.halt(typeAssertionNode);
    return typeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode), termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
    if (termVerifiedAsVariable) {
        if (assertions === null) {
            variableTypeAssertionVerified = true;
        } else {
            var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType(), assertedTypeEqualToOrSubTypeOfVariableType = assertedType.isEqualToOrSubTypeOf(variableType);
            if (!assertedTypeEqualToOrSubTypeOfVariableType) {
                var assertedTypeName1 = assertedType.getName(), variableTypeName = variableType.getName();
                proofContext.error("The '".concat(assertedTypeName1, "' asserted type is not equal to or a sub-type of the '").concat(variableName, "' variable's '").concat(variableTypeName, "' type."));
            } else {
                var type = assertedType, typeAssertion = _type.default.fromTypeAndVariableName(type, variableName), assertion = typeAssertion; ///
                assertions.push(assertion);
                variableTypeAssertionVerified = true;
            }
        }
    }
    return variableTypeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, assertions, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        if (assertions === null) {
            termTypeAssertionVerified = true;
        } else {
            var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstType = (0, _array.first)(types), termType = firstType, termString = (0, _string.nodeAsString)(termNode), assertedTypeEqualToTermType = termType === null ? true : assertedType.isEqualTo(termType);
            if (!assertedTypeEqualToTermType) {
                var termTypeName = termType.getName(), assertedTypeName1 = assertedType.getName();
                proofContext.error("The '".concat(assertedTypeName1, "' asserted type is not equal to the '").concat(termString, "' term's '").concat(termTypeName, "' type."));
            } else {
                var type = assertedType, typeAssertion = _type.default.fromTypeAndTermNode(type, termNode), assertion = typeAssertion; ///
                assertions.push(assertion);
                termTypeAssertionVerified = true;
            }
        }
    }
    return termTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvYXNzZXJ0aW9uL3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBUeXBlQXNzZXJ0aW9uIGZyb20gXCIuLi8uLi9hc3NlcnRpb24vdHlwZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG5vZGVBc1N0cmluZyB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIHR5cGVOYW1lRnJvbVR5cGVOb2RlIH0gZnJvbSBcIi4uLy4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgdmVyaWZ5VGVybUFzVmFyaWFibGUsIHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzIH0gZnJvbSBcIi4uLy4uL3ZlcmlmeS90ZXJtXCI7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdHlwZUFzc2VydGlvbi90ZXJtXCIpLFxuICAgICAgdHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlQXNzZXJ0aW9uL3R5cGVcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIHByb29mQ29udGV4dCkge1xuICBsZXQgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgcHJvb2ZDb250ZXh0LmJlZ2luKHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICBjb25zdCB0eXBlQXNzZXJ0aW9uU3RyaW5nID0gbm9kZUFzU3RyaW5nKHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICBwcm9vZkNvbnRleHQuZGVidWcoYFZlcmlmeWluZyB0aGUgJyR7dHlwZUFzc2VydGlvblN0cmluZ30nIHR5cGUgYXNzZXJ0aW9uLi4uYCk7XG5cbiAgY29uc3QgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgdHlwZU5hbWUgPSB0eXBlTmFtZUZyb21UeXBlTm9kZSh0eXBlTm9kZSksXG4gICAgICAgIHR5cGVQcmVzZW50ID0gcHJvb2ZDb250ZXh0LmlzVHlwZVByZXNlbnRCeVR5cGVOYW1lKHR5cGVOYW1lKTtcblxuICBpZiAoIXR5cGVQcmVzZW50KSB7XG4gICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgJHt0eXBlTmFtZX0gdHlwZSBpcyBub3QgcHJlc2VudC5gKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVBc3NlcnRpb25WZXJpZmllZCkge1xuICAgICAgY29uc3QgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2VydGlvbnMsIHByb29mQ29udGV4dCk7XG5cbiAgICAgIHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkOyAgLy8vXG4gICAgfVxuXG4gICAgaWYgKCF0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzZXJ0aW9ucywgcHJvb2ZDb250ZXh0KTtcblxuICAgICAgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZDsgIC8vL1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICBwcm9vZkNvbnRleHQuaW5mbyhgVmVyaWZpZWQgdGhlICcke3R5cGVBc3NlcnRpb25TdHJpbmd9JyBzdGF0ZW1lbnQgdHlwZSBhc3NlcnRpb24uYCk7XG4gIH1cblxuICB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgP1xuICAgIHByb29mQ29udGV4dC5jb21wbGV0ZSh0eXBlQXNzZXJ0aW9uTm9kZSkgOlxuICAgICAgcHJvb2ZDb250ZXh0LmhhbHQodHlwZUFzc2VydGlvbk5vZGUpO1xuXG4gIHJldHVybiB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVZhcmlhYmxlVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzZXJ0aW9ucywgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBwcm9vZkNvbnRleHQsIC8vL1xuICAgICAgICB2YXJpYWJsZXMgPSBbXSxcbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgdGVybVZlcmlmaWVkQXNWYXJpYWJsZSA9IHZlcmlmeVRlcm1Bc1ZhcmlhYmxlKHRlcm1Ob2RlLCB2YXJpYWJsZXMsIGNvbnRleHQpO1xuXG4gIGlmICh0ZXJtVmVyaWZpZWRBc1ZhcmlhYmxlKSB7XG4gICAgaWYgKGFzc2VydGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlTmFtZSA9IHR5cGVOYW1lLCAgLy8vXG4gICAgICAgICAgICBhc3NlcnRlZFR5cGUgPSBwcm9vZkNvbnRleHQuZmluZFR5cGVCeVR5cGVOYW1lKGFzc2VydGVkVHlwZU5hbWUpLFxuICAgICAgICAgICAgZmlyc3RWYXJpYWJsZSA9IGZpcnN0KHZhcmlhYmxlcyksXG4gICAgICAgICAgICB2YXJpYWJsZSA9IGZpcnN0VmFyaWFibGUsIC8vL1xuICAgICAgICAgICAgdmFyaWFibGVOYW1lID0gdmFyaWFibGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgdmFyaWFibGVUeXBlID0gdmFyaWFibGUuZ2V0VHlwZSgpLFxuICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlID0gYXNzZXJ0ZWRUeXBlLmlzRXF1YWxUb09yU3ViVHlwZU9mKHZhcmlhYmxlVHlwZSk7XG5cbiAgICAgIGlmICghYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IGFzc2VydGVkVHlwZU5hbWUgPSBhc3NlcnRlZFR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICB2YXJpYWJsZVR5cGVOYW1lID0gdmFyaWFibGVUeXBlLmdldE5hbWUoKTtcblxuICAgICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSAnJHthc3NlcnRlZFR5cGVOYW1lfScgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gb3IgYSBzdWItdHlwZSBvZiB0aGUgJyR7dmFyaWFibGVOYW1lfScgdmFyaWFibGUncyAnJHt2YXJpYWJsZVR5cGVOYW1lfScgdHlwZS5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhc3NlcnRlZFR5cGUsICAvLy9cbiAgICAgICAgICAgICAgdHlwZUFzc2VydGlvbiA9IFR5cGVBc3NlcnRpb24uZnJvbVR5cGVBbmRWYXJpYWJsZU5hbWUodHlwZSwgdmFyaWFibGVOYW1lKSxcbiAgICAgICAgICAgICAgYXNzZXJ0aW9uID0gdHlwZUFzc2VydGlvbjsgIC8vL1xuXG4gICAgICAgIGFzc2VydGlvbnMucHVzaChhc3NlcnRpb24pO1xuXG4gICAgICAgIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBhc3NlcnRpb25zLCBwcm9vZkNvbnRleHQpIHtcbiAgbGV0IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlcyA9IFtdLFxuICAgICAgICBjb250ZXh0ID0gcHJvb2ZDb250ZXh0LCAvLy9cbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgdGVybVZlcmlmaWVkQWdhaW5zdENvbnN0cnVjdG9ycyA9IHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzKHRlcm1Ob2RlLCB0eXBlcywgY29udGV4dCk7XG5cbiAgaWYgKHRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMpIHtcbiAgICBpZiAoYXNzZXJ0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgICAgIGFzc2VydGVkVHlwZU5hbWUgPSB0eXBlTmFtZSwgIC8vL1xuICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlID0gcHJvb2ZDb250ZXh0LmZpbmRUeXBlQnlUeXBlTmFtZShhc3NlcnRlZFR5cGVOYW1lKSxcbiAgICAgICAgICAgIGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICAgIHRlcm1UeXBlID0gZmlyc3RUeXBlLFxuICAgICAgICAgICAgdGVybVN0cmluZyA9IG5vZGVBc1N0cmluZyh0ZXJtTm9kZSksXG4gICAgICAgICAgICBhc3NlcnRlZFR5cGVFcXVhbFRvVGVybVR5cGUgPSAodGVybVR5cGUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlLmlzRXF1YWxUbyh0ZXJtVHlwZSk7XG5cbiAgICAgIGlmICghYXNzZXJ0ZWRUeXBlRXF1YWxUb1Rlcm1UeXBlKSB7XG4gICAgICAgIGNvbnN0IHRlcm1UeXBlTmFtZSA9IHRlcm1UeXBlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlTmFtZSA9IGFzc2VydGVkVHlwZS5nZXROYW1lKCk7XG5cbiAgICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgJyR7YXNzZXJ0ZWRUeXBlTmFtZX0nIGFzc2VydGVkIHR5cGUgaXMgbm90IGVxdWFsIHRvIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSdzICcke3Rlcm1UeXBlTmFtZX0nIHR5cGUuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlID0gYXNzZXJ0ZWRUeXBlLCAgLy8vXG4gICAgICAgICAgICAgIHR5cGVBc3NlcnRpb24gPSBUeXBlQXNzZXJ0aW9uLmZyb21UeXBlQW5kVGVybU5vZGUodHlwZSwgdGVybU5vZGUpLFxuICAgICAgICAgICAgICBhc3NlcnRpb24gPSB0eXBlQXNzZXJ0aW9uOyAgLy8vXG5cbiAgICAgICAgYXNzZXJ0aW9ucy5wdXNoKGFzc2VydGlvbik7XG5cbiAgICAgICAgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlUeXBlQXNzZXJ0aW9uIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInR5cGVOb2RlUXVlcnkiLCJ0eXBlQXNzZXJ0aW9uTm9kZSIsImFzc2VydGlvbnMiLCJwcm9vZkNvbnRleHQiLCJ0eXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJiZWdpbiIsInR5cGVBc3NlcnRpb25TdHJpbmciLCJub2RlQXNTdHJpbmciLCJkZWJ1ZyIsInR5cGVOb2RlIiwidHlwZU5hbWUiLCJ0eXBlTmFtZUZyb21UeXBlTm9kZSIsInR5cGVQcmVzZW50IiwiaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUiLCJlcnJvciIsInZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uIiwidGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uIiwiaW5mbyIsImNvbXBsZXRlIiwiaGFsdCIsImNvbnRleHQiLCJ2YXJpYWJsZXMiLCJ0ZXJtTm9kZSIsInRlcm1WZXJpZmllZEFzVmFyaWFibGUiLCJ2ZXJpZnlUZXJtQXNWYXJpYWJsZSIsImFzc2VydGVkVHlwZU5hbWUiLCJhc3NlcnRlZFR5cGUiLCJmaW5kVHlwZUJ5VHlwZU5hbWUiLCJmaXJzdFZhcmlhYmxlIiwiZmlyc3QiLCJ2YXJpYWJsZSIsInZhcmlhYmxlTmFtZSIsImdldE5hbWUiLCJ2YXJpYWJsZVR5cGUiLCJnZXRUeXBlIiwiYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlIiwiaXNFcXVhbFRvT3JTdWJUeXBlT2YiLCJ2YXJpYWJsZVR5cGVOYW1lIiwidHlwZSIsInR5cGVBc3NlcnRpb24iLCJUeXBlQXNzZXJ0aW9uIiwiZnJvbVR5cGVBbmRWYXJpYWJsZU5hbWUiLCJhc3NlcnRpb24iLCJwdXNoIiwidHlwZXMiLCJ0ZXJtVmVyaWZpZWRBZ2FpbnN0Q29uc3RydWN0b3JzIiwidmVyaWZ5VGVybUFnYWluc3RDb25zdHJ1Y3RvcnMiLCJmaXJzdFR5cGUiLCJ0ZXJtVHlwZSIsInRlcm1TdHJpbmciLCJhc3NlcnRlZFR5cGVFcXVhbFRvVGVybVR5cGUiLCJpc0VxdWFsVG8iLCJ0ZXJtVHlwZU5hbWUiLCJmcm9tVHlwZUFuZFRlcm1Ob2RlIl0sIm1hcHBpbmdzIjoiQUFBQTs7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