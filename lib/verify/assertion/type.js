"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyStatementTypeAssertion;
    }
});
var _variable = /*#__PURE__*/ _interopRequireDefault(require("../../variable"));
var _array = require("../../utilities/array");
var _string = require("../../utilities/string");
var _query = require("../../utilities/query");
var _term = require("../../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type");
function verifyStatementTypeAssertion(typeAssertionNode, qualified, proofContext) {
    var typeAssertionVerified = false;
    proofContext.begin(typeAssertionNode);
    var statementString = (0, _string.nodeAsString)(typeAssertionNode);
    proofContext.debug("Verifying the '".concat(statementString, "' type assertion..."));
    var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
    if (!typePresent) {
        proofContext.error("The ".concat(typeName, " type is not present."));
    } else {
        if (!typeAssertionVerified) {
            var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, qualified, proofContext);
            typeAssertionVerified = variableTypeAssertionVerified; ///
        }
        if (!typeAssertionVerified) {
            var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, qualified, proofContext);
            typeAssertionVerified = termTypeAssertionVerified; ///
        }
    }
    if (typeAssertionVerified) {
        proofContext.info("Verified the '".concat(statementString, "' statement type assertion."));
    }
    typeAssertionVerified ? proofContext.complete(typeAssertionNode) : proofContext.halt(typeAssertionNode);
    return typeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, qualified, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode), termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
    if (termVerifiedAsVariable) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType();
        var assertedTypeEqualToOrSubTypeOfVariableType = variableType === null ? true : assertedType.isEqualToOrSubTypeOf(variableType);
        if (!assertedTypeEqualToOrSubTypeOfVariableType) {
            proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(variableName, "' variable type."));
        } else {
            if (!qualified) {
                var type = assertedType, name = variableName, variable1 = _variable.default.fromTypeAndName(type, name);
                proofContext.addVariable(variable1);
            }
            variableTypeAssertionVerified = true;
        }
    }
    return variableTypeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, qualified, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstType = (0, _array.first)(types), termType = firstType, termString = (0, _string.nodeAsString)(termNode), assertedTypeEqualToOrSubTypeOfTermType = termType === null ? true : assertedType.isEqualToOrSubTypeOf(termType);
        if (!assertedTypeEqualToOrSubTypeOfTermType) {
            proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(termString, "' term type."));
        } else {
            if (!qualified) {
                debugger;
            }
            termTypeAssertionVerified = true;
        }
    }
    return termTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvYXNzZXJ0aW9uL3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBWYXJpYWJsZSBmcm9tIFwiLi4vLi4vdmFyaWFibGVcIjtcblxuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBub2RlQXNTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuaW1wb3J0IHsgbm9kZVF1ZXJ5LCB0eXBlTmFtZUZyb21UeXBlTm9kZSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IHZlcmlmeVRlcm1Bc1ZhcmlhYmxlLCB2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyB9IGZyb20gXCIuLi8uLi92ZXJpZnkvdGVybVwiO1xuXG5jb25zdCB0ZXJtTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3R5cGVBc3NlcnRpb24vdGVybVwiKSxcbiAgICAgIHR5cGVOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdHlwZUFzc2VydGlvbi90eXBlXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBxdWFsaWZpZWQsIHByb29mQ29udGV4dCkge1xuICBsZXQgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgcHJvb2ZDb250ZXh0LmJlZ2luKHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBub2RlQXNTdHJpbmcodHlwZUFzc2VydGlvbk5vZGUpO1xuXG4gIHByb29mQ29udGV4dC5kZWJ1ZyhgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyB0eXBlIGFzc2VydGlvbi4uLmApO1xuXG4gIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICB0eXBlUHJlc2VudCA9IHByb29mQ29udGV4dC5pc1R5cGVQcmVzZW50QnlUeXBlTmFtZSh0eXBlTmFtZSk7XG5cbiAgaWYgKCF0eXBlUHJlc2VudCkge1xuICAgIHByb29mQ29udGV4dC5lcnJvcihgVGhlICR7dHlwZU5hbWV9IHR5cGUgaXMgbm90IHByZXNlbnQuYCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBxdWFsaWZpZWQsIHByb29mQ29udGV4dCk7XG5cbiAgICAgIHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkOyAgLy8vXG4gICAgfVxuXG4gICAgaWYgKCF0eXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcXVhbGlmaWVkLCBwcm9vZkNvbnRleHQpO1xuXG4gICAgICB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkOyAgLy8vXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVBc3NlcnRpb25WZXJpZmllZCkge1xuICAgIHByb29mQ29udGV4dC5pbmZvKGBWZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IHR5cGUgYXNzZXJ0aW9uLmApO1xuICB9XG5cbiAgdHlwZUFzc2VydGlvblZlcmlmaWVkID9cbiAgICBwcm9vZkNvbnRleHQuY29tcGxldGUodHlwZUFzc2VydGlvbk5vZGUpIDpcbiAgICAgIHByb29mQ29udGV4dC5oYWx0KHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICByZXR1cm4gdHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIHF1YWxpZmllZCwgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBwcm9vZkNvbnRleHQsIC8vL1xuICAgICAgICB2YXJpYWJsZXMgPSBbXSxcbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgdGVybVZlcmlmaWVkQXNWYXJpYWJsZSA9IHZlcmlmeVRlcm1Bc1ZhcmlhYmxlKHRlcm1Ob2RlLCB2YXJpYWJsZXMsIGNvbnRleHQpO1xuXG4gIGlmICh0ZXJtVmVyaWZpZWRBc1ZhcmlhYmxlKSB7XG4gICAgY29uc3QgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gdHlwZU5hbWUsICAvLy9cbiAgICAgICAgICBhc3NlcnRlZFR5cGUgPSBwcm9vZkNvbnRleHQuZmluZFR5cGVCeVR5cGVOYW1lKGFzc2VydGVkVHlwZU5hbWUpLFxuICAgICAgICAgIGZpcnN0VmFyaWFibGUgPSBmaXJzdCh2YXJpYWJsZXMpLFxuICAgICAgICAgIHZhcmlhYmxlID0gZmlyc3RWYXJpYWJsZSwgLy8vXG4gICAgICAgICAgdmFyaWFibGVOYW1lID0gdmFyaWFibGUuZ2V0TmFtZSgpLFxuICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IHZhcmlhYmxlLmdldFR5cGUoKTtcblxuICAgIGNvbnN0IGFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSA9ICh2YXJpYWJsZVR5cGUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlLmlzRXF1YWxUb09yU3ViVHlwZU9mKHZhcmlhYmxlVHlwZSk7XG5cbiAgICBpZiAoIWFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlZhcmlhYmxlVHlwZSkge1xuICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gb3IgYSBzdWItdHlwZSBvZiB0aGUgJyR7dmFyaWFibGVOYW1lfScgdmFyaWFibGUgdHlwZS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFxdWFsaWZpZWQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGFzc2VydGVkVHlwZSwgIC8vL1xuICAgICAgICAgICAgICBuYW1lID0gdmFyaWFibGVOYW1lLCAgLy8vXG4gICAgICAgICAgICAgIHZhcmlhYmxlID0gVmFyaWFibGUuZnJvbVR5cGVBbmROYW1lKHR5cGUsIG5hbWUpO1xuXG4gICAgICAgIHByb29mQ29udGV4dC5hZGRWYXJpYWJsZSh2YXJpYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBxdWFsaWZpZWQsIHByb29mQ29udGV4dCkge1xuICBsZXQgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHR5cGVzID0gW10sXG4gICAgICAgIGNvbnRleHQgPSBwcm9vZkNvbnRleHQsIC8vL1xuICAgICAgICB0ZXJtTm9kZSA9IHRlcm1Ob2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICB0ZXJtVmVyaWZpZWRBZ2FpbnN0Q29uc3RydWN0b3JzID0gdmVyaWZ5VGVybUFnYWluc3RDb25zdHJ1Y3RvcnModGVybU5vZGUsIHR5cGVzLCBjb250ZXh0KTtcblxuICBpZiAodGVybVZlcmlmaWVkQWdhaW5zdENvbnN0cnVjdG9ycykge1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgICAgdHlwZU5hbWUgPSB0eXBlTmFtZUZyb21UeXBlTm9kZSh0eXBlTm9kZSksXG4gICAgICAgICAgYXNzZXJ0ZWRUeXBlTmFtZSA9IHR5cGVOYW1lLCAgLy8vXG4gICAgICAgICAgYXNzZXJ0ZWRUeXBlID0gcHJvb2ZDb250ZXh0LmZpbmRUeXBlQnlUeXBlTmFtZShhc3NlcnRlZFR5cGVOYW1lKSxcbiAgICAgICAgICBmaXJzdFR5cGUgPSBmaXJzdCh0eXBlcyksXG4gICAgICAgICAgdGVybVR5cGUgPSBmaXJzdFR5cGUsXG4gICAgICAgICAgdGVybVN0cmluZyA9IG5vZGVBc1N0cmluZyh0ZXJtTm9kZSksXG4gICAgICAgICAgYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVGVybVR5cGUgPSAodGVybVR5cGUgPT09IG51bGwpID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6IC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydGVkVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih0ZXJtVHlwZSk7XG5cbiAgICBpZiAoIWFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlRlcm1UeXBlKSB7XG4gICAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSBhc3NlcnRlZCB0eXBlIGlzIG5vdCBlcXVhbCB0byBvciBhIHN1Yi10eXBlIG9mIHRoZSAnJHt0ZXJtU3RyaW5nfScgdGVybSB0eXBlLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXF1YWxpZmllZCkge1xuICAgICAgICBkZWJ1Z2dlclxuICAgICAgfVxuXG4gICAgICB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cblxuIl0sIm5hbWVzIjpbInZlcmlmeVN0YXRlbWVudFR5cGVBc3NlcnRpb24iLCJ0ZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidHlwZU5vZGVRdWVyeSIsInR5cGVBc3NlcnRpb25Ob2RlIiwicXVhbGlmaWVkIiwicHJvb2ZDb250ZXh0IiwidHlwZUFzc2VydGlvblZlcmlmaWVkIiwiYmVnaW4iLCJzdGF0ZW1lbnRTdHJpbmciLCJub2RlQXNTdHJpbmciLCJkZWJ1ZyIsInR5cGVOb2RlIiwidHlwZU5hbWUiLCJ0eXBlTmFtZUZyb21UeXBlTm9kZSIsInR5cGVQcmVzZW50IiwiaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUiLCJlcnJvciIsInZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uIiwidGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uIiwiaW5mbyIsImNvbXBsZXRlIiwiaGFsdCIsImNvbnRleHQiLCJ2YXJpYWJsZXMiLCJ0ZXJtTm9kZSIsInRlcm1WZXJpZmllZEFzVmFyaWFibGUiLCJ2ZXJpZnlUZXJtQXNWYXJpYWJsZSIsImFzc2VydGVkVHlwZU5hbWUiLCJhc3NlcnRlZFR5cGUiLCJmaW5kVHlwZUJ5VHlwZU5hbWUiLCJmaXJzdFZhcmlhYmxlIiwiZmlyc3QiLCJ2YXJpYWJsZSIsInZhcmlhYmxlTmFtZSIsImdldE5hbWUiLCJ2YXJpYWJsZVR5cGUiLCJnZXRUeXBlIiwiYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlIiwiaXNFcXVhbFRvT3JTdWJUeXBlT2YiLCJ0eXBlIiwibmFtZSIsIlZhcmlhYmxlIiwiZnJvbVR5cGVBbmROYW1lIiwiYWRkVmFyaWFibGUiLCJ0eXBlcyIsInRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMiLCJ2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyIsImZpcnN0VHlwZSIsInRlcm1UeXBlIiwidGVybVN0cmluZyIsImFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlRlcm1UeXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFZQTs7O2VBQXdCQTs7OzZEQVZIO3FCQUVDO3NCQUNPO3FCQUNtQjtvQkFDb0I7Ozs7OztBQUVwRSxJQUFNQyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsd0JBQzFCQyxnQkFBZ0JELElBQUFBLGdCQUFTLEVBQUM7QUFFakIsU0FBU0YsNkJBQTZCSSxpQkFBaUIsRUFBRUMsU0FBUyxFQUFFQyxZQUFZLEVBQUU7SUFDL0YsSUFBSUMsd0JBQXdCLEtBQUs7SUFFakNELGFBQWFFLEtBQUssQ0FBQ0o7SUFFbkIsSUFBTUssa0JBQWtCQyxJQUFBQSxvQkFBWSxFQUFDTjtJQUVyQ0UsYUFBYUssS0FBSyxDQUFDLEFBQUMsa0JBQWlDLE9BQWhCRixpQkFBZ0I7SUFFckQsSUFBTUcsV0FBV1QsY0FBY0Msb0JBQ3pCUyxXQUFXQyxJQUFBQSwyQkFBb0IsRUFBQ0YsV0FDaENHLGNBQWNULGFBQWFVLHVCQUF1QixDQUFDSDtJQUV6RCxJQUFJLENBQUNFLGFBQWE7UUFDaEJULGFBQWFXLEtBQUssQ0FBQyxBQUFDLE9BQWUsT0FBVEosVUFBUztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDTix1QkFBdUI7WUFDMUIsSUFBTVcsZ0NBQWdDQyw0QkFBNEJmLG1CQUFtQkMsV0FBV0M7WUFFaEdDLHdCQUF3QlcsK0JBQWdDLEdBQUc7UUFDN0QsQ0FBQztR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