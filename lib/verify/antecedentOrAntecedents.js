"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyAntecedentOrAntecedents;
    }
});
var _assertion = /*#__PURE__*/ _interopRequireDefault(require("../assertion"));
var _antecedent = /*#__PURE__*/ _interopRequireDefault(require("../antecedent"));
var _unqualified = /*#__PURE__*/ _interopRequireDefault(require("../verify/statement/unqualified"));
var _query = require("../utilities/query");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement"), unqualifiedStatementNodesQuery = (0, _query.nodesQuery)("/antecedent|antecedents/unqualifiedStatement");
function verifyAntecedentOrAntecedents(antecedentOrAntecedentsNode, antecedents, proofContext) {
    var antecedentOrAntecedentsVerified;
    proofContext.begin(antecedentOrAntecedentsNode);
    var unqualifiedStatementNodes = unqualifiedStatementNodesQuery(antecedentOrAntecedentsNode);
    antecedentOrAntecedentsVerified = unqualifiedStatementNodes.every(function(unqualifiedStatementNode) {
        var unqualifiedStatementVerified = (0, _unqualified.default)(unqualifiedStatementNode, proofContext);
        if (unqualifiedStatementVerified) {
            var statementNode = statementNodeQuery(unqualifiedStatementNode), assertion = _assertion.default.fromUnqualifiedStatementNode(unqualifiedStatementNode), antecedent = _antecedent.default.fromStatementNode(statementNode);
            antecedents.push(antecedent);
            proofContext.addAssertion(assertion);
            return true;
        }
    });
    antecedentOrAntecedentsVerified ? proofContext.complete(antecedentOrAntecedentsNode) : proofContext.halt(antecedentOrAntecedentsNode);
    return antecedentOrAntecedentsVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvYW50ZWNlZGVudE9yQW50ZWNlZGVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBBc3NlcnRpb24gZnJvbSBcIi4uL2Fzc2VydGlvblwiO1xuaW1wb3J0IEFudGVjZWRlbnQgZnJvbSBcIi4uL2FudGVjZWRlbnRcIjtcbmltcG9ydCB2ZXJpZnlVbnF1YWxpZmllZFN0YXRlbWVudCBmcm9tIFwiLi4vdmVyaWZ5L3N0YXRlbWVudC91bnF1YWxpZmllZFwiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5cbmNvbnN0IHN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi91bnF1YWxpZmllZFN0YXRlbWVudC9zdGF0ZW1lbnRcIiksXG4gICAgICB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGVzUXVlcnkgPSBub2Rlc1F1ZXJ5KFwiL2FudGVjZWRlbnR8YW50ZWNlZGVudHMvdW5xdWFsaWZpZWRTdGF0ZW1lbnRcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeUFudGVjZWRlbnRPckFudGVjZWRlbnRzKGFudGVjZWRlbnRPckFudGVjZWRlbnRzTm9kZSwgYW50ZWNlZGVudHMsIHByb29mQ29udGV4dCkge1xuICBsZXQgYW50ZWNlZGVudE9yQW50ZWNlZGVudHNWZXJpZmllZDtcblxuICBwcm9vZkNvbnRleHQuYmVnaW4oYW50ZWNlZGVudE9yQW50ZWNlZGVudHNOb2RlKTtcblxuICBjb25zdCB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGVzID0gdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2Rlc1F1ZXJ5KGFudGVjZWRlbnRPckFudGVjZWRlbnRzTm9kZSk7XG5cbiAgYW50ZWNlZGVudE9yQW50ZWNlZGVudHNWZXJpZmllZCA9IHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZXMuZXZlcnkoKHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSkgPT4ge1xuICAgIGNvbnN0IHVucXVhbGlmaWVkU3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlVbnF1YWxpZmllZFN0YXRlbWVudCh1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUsIHByb29mQ29udGV4dCk7XG5cbiAgICBpZiAodW5xdWFsaWZpZWRTdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgICAgY29uc3Qgc3RhdGVtZW50Tm9kZSA9IHN0YXRlbWVudE5vZGVRdWVyeSh1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUpLFxuICAgICAgICAgICAgYXNzZXJ0aW9uID0gQXNzZXJ0aW9uLmZyb21VbnF1YWxpZmllZFN0YXRlbWVudE5vZGUodW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICAgIGFudGVjZWRlbnQgPSBBbnRlY2VkZW50LmZyb21TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUpO1xuXG4gICAgICBhbnRlY2VkZW50cy5wdXNoKGFudGVjZWRlbnQpO1xuXG4gICAgICBwcm9vZkNvbnRleHQuYWRkQXNzZXJ0aW9uKGFzc2VydGlvbik7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgYW50ZWNlZGVudE9yQW50ZWNlZGVudHNWZXJpZmllZCA/XG4gICAgcHJvb2ZDb250ZXh0LmNvbXBsZXRlKGFudGVjZWRlbnRPckFudGVjZWRlbnRzTm9kZSkgOlxuICAgICAgcHJvb2ZDb250ZXh0LmhhbHQoYW50ZWNlZGVudE9yQW50ZWNlZGVudHNOb2RlKTtcblxuICByZXR1cm4gYW50ZWNlZGVudE9yQW50ZWNlZGVudHNWZXJpZmllZDtcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlBbnRlY2VkZW50T3JBbnRlY2VkZW50cyIsInN0YXRlbWVudE5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZXNRdWVyeSIsIm5vZGVzUXVlcnkiLCJhbnRlY2VkZW50T3JBbnRlY2VkZW50c05vZGUiLCJhbnRlY2VkZW50cyIsInByb29mQ29udGV4dCIsImFudGVjZWRlbnRPckFudGVjZWRlbnRzVmVyaWZpZWQiLCJiZWdpbiIsInVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZXMiLCJldmVyeSIsInVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSIsInVucXVhbGlmaWVkU3RhdGVtZW50VmVyaWZpZWQiLCJ2ZXJpZnlVbnF1YWxpZmllZFN0YXRlbWVudCIsInN0YXRlbWVudE5vZGUiLCJhc3NlcnRpb24iLCJBc3NlcnRpb24iLCJmcm9tVW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlIiwiYW50ZWNlZGVudCIsIkFudGVjZWRlbnQiLCJmcm9tU3RhdGVtZW50Tm9kZSIsInB1c2giLCJhZGRBc3NlcnRpb24iLCJjb21wbGV0ZSIsImhhbHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OytCQVdBOzs7ZUFBd0JBOzs7OERBVEY7K0RBQ0M7Z0VBQ2dCO3FCQUVEOzs7Ozs7QUFFdEMsSUFBTUMscUJBQXFCQyxJQUFBQSxnQkFBUyxFQUFDLG9DQUMvQkMsaUNBQWlDQyxJQUFBQSxpQkFBVSxFQUFDO0FBRW5DLFNBQVNKLDhCQUE4QkssMkJBQTJCLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFO0lBQzVHLElBQUlDO0lBRUpELGFBQWFFLEtBQUssQ0FBQ0o7SUFFbkIsSUFBTUssNEJBQTRCUCwrQkFBK0JFO0lBRWpFRyxrQ0FBa0NFLDBCQUEwQkMsS0FBSyxDQUFDLFNBQUNDLDBCQUE2QjtRQUM5RixJQUFNQywrQkFBK0JDLElBQUFBLG9CQUEwQixFQUFDRiwwQkFBMEJMO1FBRTFGLElBQUlNLDhCQUE4QjtZQUNoQyxJQUFNRSxnQkFBZ0JkLG1CQUFtQlcsMkJBQ25DSSxZQUFZQyxrQkFBUyxDQUFDQyw0QkFBNEIsQ0FBQ04sMkJBQ25ETyxhQUFhQyxtQkFBVSxDQUFDQyxpQkFBaUIsQ0FBQ047WUFFaERULFlBQVlnQixJQUFJLENBQUNIO1lBRWpCWixhQUFhZ0IsWUFBWSxDQUFDUDtZQUUxQixPQUFPLElBQUk7UUFDYixDQUFDO0lBQ0g7SUFFQVIsa0NBQ0VELGFBQWFpQixRQUFRLENBQUNuQiwrQkFDcEJFLGFBQWFrQixJQUFJLENBQUNwQiw0QkFBNEI7SUFFbEQsT0FBT0c7QUFDVCJ9