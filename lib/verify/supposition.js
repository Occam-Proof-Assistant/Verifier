"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifySupposition;
    }
});
var _proof = /*#__PURE__*/ _interopRequireDefault(require("../step/proof"));
var _supposition = /*#__PURE__*/ _interopRequireDefault(require("../supposition"));
var _unqualified = /*#__PURE__*/ _interopRequireDefault(require("./statement/unqualified"));
var _query = require("../utilities/query");
var _string = require("../utilities/string");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var statementNodeQuery = (0, _query.nodeQuery)("/unqualifiedStatement/statement!"), unqualifiedStatementNodeQuery = (0, _query.nodeQuery)("/supposition/unqualifiedStatement!");
function verifySupposition(suppositionNode, suppositions, proofContext) {
    var suppositionVerified;
    proofContext.begin(suppositionNode);
    var suppositionString = (0, _string.nodeAsString)(suppositionNode);
    proofContext.debug("Verifying the ".concat(suppositionString, " supposition..."));
    var derived = false, assertions = [], unqualifiedStatementNode = unqualifiedStatementNodeQuery(suppositionNode), unqualifiedStatementVerified = (0, _unqualified.default)(unqualifiedStatementNode, assertions, derived, proofContext);
    if (unqualifiedStatementVerified) {
        var statementNode = statementNodeQuery(unqualifiedStatementNode), proofStep = _proof.default.fromStatementNode(statementNode), supposition = _supposition.default.fromStatementNode(statementNode);
        suppositions.push(supposition);
        proofContext.addProofStep(proofStep);
        assertions.every(function(assertion) {
            assertion.assert(proofContext);
        });
        suppositionVerified = true;
    }
    suppositionVerified ? proofContext.complete(suppositionNode) : proofContext.halt(suppositionNode);
    return suppositionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3VwcG9zaXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBQcm9vZlN0ZXAgZnJvbSBcIi4uL3N0ZXAvcHJvb2ZcIjtcbmltcG9ydCBTdXBwb3NpdGlvbiBmcm9tIFwiLi4vc3VwcG9zaXRpb25cIjtcbmltcG9ydCB2ZXJpZnlVbnF1YWxpZmllZFN0YXRlbWVudCBmcm9tIFwiLi9zdGF0ZW1lbnQvdW5xdWFsaWZpZWRcIjtcblxuaW1wb3J0IHsgbm9kZVF1ZXJ5IH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgbm9kZUFzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcblxuY29uc3Qgc3RhdGVtZW50Tm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3VucXVhbGlmaWVkU3RhdGVtZW50L3N0YXRlbWVudCFcIiksXG4gICAgICB1bnF1YWxpZmllZFN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9zdXBwb3NpdGlvbi91bnF1YWxpZmllZFN0YXRlbWVudCFcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVN1cHBvc2l0aW9uKHN1cHBvc2l0aW9uTm9kZSwgc3VwcG9zaXRpb25zLCBwcm9vZkNvbnRleHQpIHtcbiAgbGV0IHN1cHBvc2l0aW9uVmVyaWZpZWQ7XG5cbiAgcHJvb2ZDb250ZXh0LmJlZ2luKHN1cHBvc2l0aW9uTm9kZSk7XG5cbiAgY29uc3Qgc3VwcG9zaXRpb25TdHJpbmcgPSBub2RlQXNTdHJpbmcoc3VwcG9zaXRpb25Ob2RlKTtcblxuICBwcm9vZkNvbnRleHQuZGVidWcoYFZlcmlmeWluZyB0aGUgJHtzdXBwb3NpdGlvblN0cmluZ30gc3VwcG9zaXRpb24uLi5gKTtcblxuICBjb25zdCBkZXJpdmVkID0gZmFsc2UsXG4gICAgICAgIGFzc2VydGlvbnMgPSBbXSxcbiAgICAgICAgdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlID0gdW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlUXVlcnkoc3VwcG9zaXRpb25Ob2RlKSxcbiAgICAgICAgdW5xdWFsaWZpZWRTdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVVucXVhbGlmaWVkU3RhdGVtZW50KHVucXVhbGlmaWVkU3RhdGVtZW50Tm9kZSwgYXNzZXJ0aW9ucywgZGVyaXZlZCwgcHJvb2ZDb250ZXh0KTtcblxuICBpZiAodW5xdWFsaWZpZWRTdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgIGNvbnN0IHN0YXRlbWVudE5vZGUgPSBzdGF0ZW1lbnROb2RlUXVlcnkodW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICBwcm9vZlN0ZXAgPSBQcm9vZlN0ZXAuZnJvbVN0YXRlbWVudE5vZGUoc3RhdGVtZW50Tm9kZSksXG4gICAgICAgICAgc3VwcG9zaXRpb24gPSBTdXBwb3NpdGlvbi5mcm9tU3RhdGVtZW50Tm9kZShzdGF0ZW1lbnROb2RlKTtcblxuICAgIHN1cHBvc2l0aW9ucy5wdXNoKHN1cHBvc2l0aW9uKTtcblxuICAgIHByb29mQ29udGV4dC5hZGRQcm9vZlN0ZXAocHJvb2ZTdGVwKTtcblxuICAgIGFzc2VydGlvbnMuZXZlcnkoKGFzc2VydGlvbikgPT4ge1xuICAgICAgYXNzZXJ0aW9uLmFzc2VydChwcm9vZkNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgc3VwcG9zaXRpb25WZXJpZmllZCA9IHRydWU7XG4gIH1cblxuICBzdXBwb3NpdGlvblZlcmlmaWVkID9cbiAgICBwcm9vZkNvbnRleHQuY29tcGxldGUoc3VwcG9zaXRpb25Ob2RlKSA6XG4gICAgICBwcm9vZkNvbnRleHQuaGFsdChzdXBwb3NpdGlvbk5vZGUpO1xuXG4gIHJldHVybiBzdXBwb3NpdGlvblZlcmlmaWVkO1xufVxuIl0sIm5hbWVzIjpbInZlcmlmeVN1cHBvc2l0aW9uIiwic3RhdGVtZW50Tm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidW5xdWFsaWZpZWRTdGF0ZW1lbnROb2RlUXVlcnkiLCJzdXBwb3NpdGlvbk5vZGUiLCJzdXBwb3NpdGlvbnMiLCJwcm9vZkNvbnRleHQiLCJzdXBwb3NpdGlvblZlcmlmaWVkIiwiYmVnaW4iLCJzdXBwb3NpdGlvblN0cmluZyIsIm5vZGVBc1N0cmluZyIsImRlYnVnIiwiZGVyaXZlZCIsImFzc2VydGlvbnMiLCJ1bnF1YWxpZmllZFN0YXRlbWVudE5vZGUiLCJ1bnF1YWxpZmllZFN0YXRlbWVudFZlcmlmaWVkIiwidmVyaWZ5VW5xdWFsaWZpZWRTdGF0ZW1lbnQiLCJzdGF0ZW1lbnROb2RlIiwicHJvb2ZTdGVwIiwiUHJvb2ZTdGVwIiwiZnJvbVN0YXRlbWVudE5vZGUiLCJzdXBwb3NpdGlvbiIsIlN1cHBvc2l0aW9uIiwicHVzaCIsImFkZFByb29mU3RlcCIsImV2ZXJ5IiwiYXNzZXJ0aW9uIiwiYXNzZXJ0IiwiY29tcGxldGUiLCJoYWx0Il0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFZQTs7O2VBQXdCQTs7OzBEQVZGO2dFQUNFO2dFQUNlO3FCQUViO3NCQUNHOzs7Ozs7QUFFN0IsSUFBTUMscUJBQXFCQyxJQUFBQSxnQkFBUyxFQUFDLHFDQUMvQkMsZ0NBQWdDRCxJQUFBQSxnQkFBUyxFQUFDO0FBRWpDLFNBQVNGLGtCQUFrQkksZUFBZSxFQUFFQyxZQUFZLEVBQUVDLFlBQVksRUFBRTtJQUNyRixJQUFJQztJQUVKRCxhQUFhRSxLQUFLLENBQUNKO0lBRW5CLElBQU1LLG9CQUFvQkMsSUFBQUEsb0JBQVksRUFBQ047SUFFdkNFLGFBQWFLLEtBQUssQ0FBQyxBQUFDLGlCQUFrQyxPQUFsQkYsbUJBQWtCO0lBRXRELElBQU1HLFVBQVUsS0FBSyxFQUNmQyxhQUFhLEVBQUUsRUFDZkMsMkJBQTJCWCw4QkFBOEJDLGtCQUN6RFcsK0JBQStCQyxJQUFBQSxvQkFBMEIsRUFBQ0YsMEJBQTBCRCxZQUFZRCxTQUFTTjtJQUUvRyxJQUFJUyw4QkFBOEI7UUFDaEMsSUFBTUUsZ0JBQWdCaEIsbUJBQW1CYSwyQkFDbkNJLFlBQVlDLGNBQVMsQ0FBQ0MsaUJBQWlCLENBQUNILGdCQUN4Q0ksY0FBY0Msb0JBQVcsQ0FBQ0YsaUJBQWlCLENBQUNIO1FBRWxEWixhQUFha0IsSUFBSSxDQUFDRjtRQUVsQmYsYUFBYWtCLFlBQVksQ0FBQ047UUFFMUJMLFdBQVdZLEtBQUssQ0FBQyxTQUFDQyxXQUFjO1lBQzlCQSxVQUFVQyxNQUFNLENBQUNyQjtRQUNuQjtRQUVBQyxzQkFBc0IsSUFBSTtJQUM1QixDQUFDO0lBRURBLHNCQUNFRCxhQUFhc0IsUUFBUSxDQUFDeEIsbUJBQ3BCRSxhQUFhdUIsSUFBSSxDQUFDekIsZ0JBQWdCO0lBRXRDLE9BQU9HO0FBQ1QifQ==