"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyMetaSupposition;
    }
});
var _metaproof = /*#__PURE__*/ _interopRequireDefault(require("../step/metaproof"));
var _metaSupposition = /*#__PURE__*/ _interopRequireDefault(require("../metaSupposition"));
var _metastatement = /*#__PURE__*/ _interopRequireDefault(require("./metastatement"));
var _query = require("../utilities/query");
var _string = require("../utilities/string");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var metastatementNodeQuery = (0, _query.nodeQuery)("/metaSupposition/unqualifiedMetastatement!/metastatement!");
function verifyMetaSupposition(metaSuppositionNode, metaSuppositions, metaproofContext) {
    var metaSuppositionVerified;
    metaproofContext.begin(metaSuppositionNode);
    var metaSuppositionString = (0, _string.nodeAsString)(metaSuppositionNode);
    metaproofContext.debug("Verifying the ".concat(metaSuppositionString, " metaSupposition..."));
    var metastatementNode = metastatementNodeQuery(metaSuppositionNode);
    if (metastatementNode !== null) {
        var qualified = false, metastatementVerified = (0, _metastatement.default)(metastatementNode, qualified, metaproofContext);
        if (metastatementVerified) {
            var metaproofStep = _metaproof.default.fromMetastatementNode(metastatementNode), metaSupposition = _metaSupposition.default.fromMetastatementNode(metastatementNode);
            metaSuppositions.push(metaSupposition);
            metaproofContext.addMetaproofStep(metaproofStep);
        }
        metaSuppositionVerified = true;
    }
    metaSuppositionVerified ? metaproofContext.complete(metaSuppositionNode) : metaproofContext.halt(metaSuppositionNode);
    return metaSuppositionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvbWV0YVN1cHBvc2l0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgTWV0YXByb29mU3RlcCBmcm9tIFwiLi4vc3RlcC9tZXRhcHJvb2ZcIjtcbmltcG9ydCBNZXRhU3VwcG9zaXRpb24gZnJvbSBcIi4uL21ldGFTdXBwb3NpdGlvblwiO1xuaW1wb3J0IHZlcmlmeU1ldGFzdGF0ZW1lbnQgZnJvbSBcIi4vbWV0YXN0YXRlbWVudFwiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBub2RlQXNTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3N0cmluZ1wiO1xuXG5jb25zdCBtZXRhc3RhdGVtZW50Tm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL21ldGFTdXBwb3NpdGlvbi91bnF1YWxpZmllZE1ldGFzdGF0ZW1lbnQhL21ldGFzdGF0ZW1lbnQhXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlNZXRhU3VwcG9zaXRpb24obWV0YVN1cHBvc2l0aW9uTm9kZSwgbWV0YVN1cHBvc2l0aW9ucywgbWV0YXByb29mQ29udGV4dCkge1xuICBsZXQgbWV0YVN1cHBvc2l0aW9uVmVyaWZpZWQ7XG5cbiAgbWV0YXByb29mQ29udGV4dC5iZWdpbihtZXRhU3VwcG9zaXRpb25Ob2RlKTtcblxuICBjb25zdCBtZXRhU3VwcG9zaXRpb25TdHJpbmcgPSBub2RlQXNTdHJpbmcobWV0YVN1cHBvc2l0aW9uTm9kZSk7XG5cbiAgbWV0YXByb29mQ29udGV4dC5kZWJ1ZyhgVmVyaWZ5aW5nIHRoZSAke21ldGFTdXBwb3NpdGlvblN0cmluZ30gbWV0YVN1cHBvc2l0aW9uLi4uYCk7XG5cbiAgY29uc3QgbWV0YXN0YXRlbWVudE5vZGUgPSBtZXRhc3RhdGVtZW50Tm9kZVF1ZXJ5KG1ldGFTdXBwb3NpdGlvbk5vZGUpO1xuXG4gIGlmIChtZXRhc3RhdGVtZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHF1YWxpZmllZCA9IGZhbHNlLFxuICAgICAgICAgIG1ldGFzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeU1ldGFzdGF0ZW1lbnQobWV0YXN0YXRlbWVudE5vZGUsIHF1YWxpZmllZCwgbWV0YXByb29mQ29udGV4dCk7XG5cbiAgICBpZiAobWV0YXN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgICBjb25zdCBtZXRhcHJvb2ZTdGVwID0gTWV0YXByb29mU3RlcC5mcm9tTWV0YXN0YXRlbWVudE5vZGUobWV0YXN0YXRlbWVudE5vZGUpLFxuICAgICAgICAgICAgbWV0YVN1cHBvc2l0aW9uID0gTWV0YVN1cHBvc2l0aW9uLmZyb21NZXRhc3RhdGVtZW50Tm9kZShtZXRhc3RhdGVtZW50Tm9kZSk7XG5cbiAgICAgIG1ldGFTdXBwb3NpdGlvbnMucHVzaChtZXRhU3VwcG9zaXRpb24pO1xuXG4gICAgICBtZXRhcHJvb2ZDb250ZXh0LmFkZE1ldGFwcm9vZlN0ZXAobWV0YXByb29mU3RlcCk7XG4gICAgfVxuXG4gICAgbWV0YVN1cHBvc2l0aW9uVmVyaWZpZWQgPSB0cnVlO1xuICB9XG5cbiAgbWV0YVN1cHBvc2l0aW9uVmVyaWZpZWQgP1xuICAgIG1ldGFwcm9vZkNvbnRleHQuY29tcGxldGUobWV0YVN1cHBvc2l0aW9uTm9kZSkgOlxuICAgICAgbWV0YXByb29mQ29udGV4dC5oYWx0KG1ldGFTdXBwb3NpdGlvbk5vZGUpO1xuXG4gIHJldHVybiBtZXRhU3VwcG9zaXRpb25WZXJpZmllZDtcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlNZXRhU3VwcG9zaXRpb24iLCJtZXRhc3RhdGVtZW50Tm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwibWV0YVN1cHBvc2l0aW9uTm9kZSIsIm1ldGFTdXBwb3NpdGlvbnMiLCJtZXRhcHJvb2ZDb250ZXh0IiwibWV0YVN1cHBvc2l0aW9uVmVyaWZpZWQiLCJiZWdpbiIsIm1ldGFTdXBwb3NpdGlvblN0cmluZyIsIm5vZGVBc1N0cmluZyIsImRlYnVnIiwibWV0YXN0YXRlbWVudE5vZGUiLCJxdWFsaWZpZWQiLCJtZXRhc3RhdGVtZW50VmVyaWZpZWQiLCJ2ZXJpZnlNZXRhc3RhdGVtZW50IiwibWV0YXByb29mU3RlcCIsIk1ldGFwcm9vZlN0ZXAiLCJmcm9tTWV0YXN0YXRlbWVudE5vZGUiLCJtZXRhU3VwcG9zaXRpb24iLCJNZXRhU3VwcG9zaXRpb24iLCJwdXNoIiwiYWRkTWV0YXByb29mU3RlcCIsImNvbXBsZXRlIiwiaGFsdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7K0JBV0E7OztlQUF3QkE7Ozs4REFURTtvRUFDRTtrRUFDSTtxQkFFTjtzQkFDRzs7Ozs7O0FBRTdCLElBQU1DLHlCQUF5QkMsSUFBQUEsZ0JBQVMsRUFBQztBQUUxQixTQUFTRixzQkFBc0JHLG1CQUFtQixFQUFFQyxnQkFBZ0IsRUFBRUMsZ0JBQWdCLEVBQUU7SUFDckcsSUFBSUM7SUFFSkQsaUJBQWlCRSxLQUFLLENBQUNKO0lBRXZCLElBQU1LLHdCQUF3QkMsSUFBQUEsb0JBQVksRUFBQ047SUFFM0NFLGlCQUFpQkssS0FBSyxDQUFDLEFBQUMsaUJBQXNDLE9BQXRCRix1QkFBc0I7SUFFOUQsSUFBTUcsb0JBQW9CVix1QkFBdUJFO0lBRWpELElBQUlRLHNCQUFzQixJQUFJLEVBQUU7UUFDOUIsSUFBTUMsWUFBWSxLQUFLLEVBQ2pCQyx3QkFBd0JDLElBQUFBLHNCQUFtQixFQUFDSCxtQkFBbUJDLFdBQVdQO1FBRWhGLElBQUlRLHVCQUF1QjtZQUN6QixJQUFNRSxnQkFBZ0JDLGtCQUFhLENBQUNDLHFCQUFxQixDQUFDTixvQkFDcERPLGtCQUFrQkMsd0JBQWUsQ0FBQ0YscUJBQXFCLENBQUNOO1lBRTlEUCxpQkFBaUJnQixJQUFJLENBQUNGO1lBRXRCYixpQkFBaUJnQixnQkFBZ0IsQ0FBQ047UUFDcEMsQ0FBQztRQUVEVCwwQkFBMEIsSUFBSTtJQUNoQyxDQUFDO0lBRURBLDBCQUNFRCxpQkFBaUJpQixRQUFRLENBQUNuQix1QkFDeEJFLGlCQUFpQmtCLElBQUksQ0FBQ3BCLG9CQUFvQjtJQUU5QyxPQUFPRztBQUNUIn0=