"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    verifyStandaloneStatement: function() {
        return verifyStandaloneStatement;
    },
    verifyStatementAsEquality: function() {
        return verifyStatementAsEquality;
    },
    verifyStatementAsTypeAssertion: function() {
        return verifyStatementAsTypeAssertion;
    }
});
var _equality = /*#__PURE__*/ _interop_require_default(require("../verify/equality"));
var _bracketed = /*#__PURE__*/ _interop_require_default(require("../ocmbinator/bracketed"));
var _typeAssertion = /*#__PURE__*/ _interop_require_default(require("../verify/typeAssertion"));
var _statementAsDefinedAssertion = /*#__PURE__*/ _interop_require_default(require("../verify/statementAsDefinedAssertion"));
var _statementAsContainedAssertion = /*#__PURE__*/ _interop_require_default(require("../verify/statementAsContainedAssertion"));
var _statementAgainstCombinator = /*#__PURE__*/ _interop_require_default(require("../verifier/nodes/statementAgainstCombinator"));
var _constants = require("../constants");
var _query = require("../utilities/query");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var equalityNodeQuery = (0, _query.nodeQuery)("/statement/equality!"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!"), operatorTerminalNodesQuery = (0, _query.nodesQuery)("/statement/@operator");
function verifyStatement(statementNode, assignments, derived, localContext) {
    var statementVerified;
    var statementString = localContext.nodeAsString(statementNode);
    localContext.trace("Verifying the '".concat(statementString, "' statement..."), statementNode);
    var verifyStatementFunctions = [
        verifyStatementAsEquality,
        verifyStatementAsTypeAssertion,
        _statementAsDefinedAssertion.default,
        _statementAsContainedAssertion.default,
        verifyStatementAgainstCombinators
    ];
    statementVerified = verifyStatementFunctions.some(function(verifyStatementFunction) {
        var statementVerified = verifyStatementFunction(statementNode, assignments, derived, localContext);
        if (statementVerified) {
            return true;
        }
    });
    if (statementVerified) {
        localContext.debug("...verified the '".concat(statementString, "' statement."), statementNode);
    }
    return statementVerified;
}
function verifyStandaloneStatement(statementNode, localContext, verifyAhead) {
    var standaloneStatementVerified = false;
    var statementString = localContext.nodeAsString(statementNode);
    localContext.trace("Verifying the '".concat(statementString, "' standalone statement..."), statementNode);
    var derived = false, assignments = [], statementVerified = verifyStatement(statementNode, assignments, derived);
    if (statementVerified) {
        var verifiedAhead = verifyAhead();
        standaloneStatementVerified = verifiedAhead; ///
    }
    if (standaloneStatementVerified) {
        localContext.debug("...verified the '".concat(statementString, "' standalone statement."), statementNode);
    }
    return standaloneStatementVerified;
}
Object.assign(_statementAgainstCombinator.default, {
    verifyStatement: verifyStatement
});
var _default = verifyStatement;
function verifyStatementAsEquality(statementNode, assignments, derived, localContext) {
    var statementVerifiedAsEquality = false;
    var statementEquality = isStatementEquality(statementNode);
    if (statementEquality) {
        var statementString = localContext.nodeAsString(statementNode);
        localContext.trace("Verifying the '".concat(statementString, "' statement as an equality..."), statementNode);
        var equalityNode = equalityNodeQuery(statementNode), equalityVerified = (0, _equality.default)(equalityNode, assignments, derived, localContext, function() {
            var verifiedAhead = true;
            return verifiedAhead;
        });
        statementVerifiedAsEquality = equalityVerified; ///
        if (statementVerifiedAsEquality) {
            localContext.debug("...verified the '".concat(statementString, "' statement as an equality."), statementNode);
        }
    }
    return statementVerifiedAsEquality;
}
function verifyStatementAsTypeAssertion(statementNode, assignments, derived, localContext) {
    var statementVerifiedAsTypeAssertion = false;
    var statementTypeAssertion = isStatementTypeAssertion(statementNode);
    if (statementTypeAssertion) {
        var statementString = localContext.nodeAsString(statementNode);
        localContext.trace("Verifying the '".concat(statementString, "' statement as a type assertion..."), statementNode);
        var typeAssertionNode = typeAssertionNodeQuery(statementNode), typeAssertionVerified = (0, _typeAssertion.default)(typeAssertionNode, assignments, derived, localContext, function() {
            var verifiedAhead = true;
            return verifiedAhead;
        });
        statementVerifiedAsTypeAssertion = typeAssertionVerified; ///
        if (statementVerifiedAsTypeAssertion) {
            localContext.debug("...verified the '".concat(statementString, "' statement as a type assertion."), statementNode);
        }
    }
    return statementVerifiedAsTypeAssertion;
}
function verifyStatementAgainstCombinators(statementNode, assignments, derived, localContext) {
    var statementVerifiedAgainstCombinators = false;
    var statementEquality = isStatementEquality(statementNode), statementTypeAssertion = isStatementTypeAssertion(statementNode), statementDefinedAssertion = isStatementDefinedAssertion(statementNode), statementContainedAssertion = isStatementContainedAssertion(statementNode);
    if (!statementEquality && !statementTypeAssertion && !statementDefinedAssertion && !statementContainedAssertion) {
        var combinators = localContext.getCombinators();
        combinators = [
            _bracketed.default
        ].concat(_to_consumable_array(combinators));
        statementVerifiedAgainstCombinators = combinators.some(function(combinator) {
            var statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, localContext);
            if (statementVerifiedAgainstCombinator) {
                return true;
            }
        });
    }
    return statementVerifiedAgainstCombinators;
}
function verifyStatementAgainstCombinator(statementNode, combinator, localContext) {
    var statementVerifiedAgainstCombinator;
    var statementString = localContext.nodeAsString(statementNode), combinatorString = combinator.getString();
    localContext.trace("Verifying the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator..."), statementNode);
    var combinatorStatementNode = combinator.getStatementNode(), nonTerminalNodeA = statementNode, nonTerminalNodeB = combinatorStatementNode, nonTerminalNodeVerified = _statementAgainstCombinator.default.verifyNonTerminalNode(nonTerminalNodeA, nonTerminalNodeB, localContext, function() {
        var verifiedAhead = true;
        return verifiedAhead;
    });
    statementVerifiedAgainstCombinator = nonTerminalNodeVerified; ///
    if (statementVerifiedAgainstCombinator) {
        localContext.debug("...verified the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator."), statementNode);
    }
    return statementVerifiedAgainstCombinator;
}
function isStatementEquality(statementNode) {
    var equalityNode = equalityNodeQuery(statementNode), statementEquality = equalityNode !== null;
    return statementEquality;
}
function isStatementTypeAssertion(statementNode) {
    var typeAssertionNode = typeAssertionNodeQuery(statementNode), statementTypeAssertion = typeAssertionNode === null;
    return statementTypeAssertion;
}
function isStatementDefinedAssertion(statementNode) {
    var operatorTerminalNodes = operatorTerminalNodesQuery(statementNode), statementDefinedAssertion = operatorTerminalNodes.some(function(operatorTerminalNode) {
        var content = operatorTerminalNode.getContent(), contentDefined = content === _constants.DEFINED;
        if (contentDefined) {
            return true;
        }
    });
    return statementDefinedAssertion;
}
function isStatementContainedAssertion(statementNode) {
    var operatorTerminalNodes = operatorTerminalNodesQuery(statementNode), statementContainedAssertion = operatorTerminalNodes.some(function(operatorTerminalNode) {
        var content = operatorTerminalNode.getContent(), contentContained = content === _constants.CONTAINED;
        if (contentContained) {
            return true;
        }
    });
    return statementContainedAssertion;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgdmVyaWZ5RXF1YWxpdHkgZnJvbSBcIi4uL3ZlcmlmeS9lcXVhbGl0eVwiO1xuaW1wb3J0IGJyYWNrZXRlZENvbWJpbmF0b3IgZnJvbSBcIi4uL29jbWJpbmF0b3IvYnJhY2tldGVkXCI7XG5pbXBvcnQgdmVyaWZ5VHlwZUFzc2VydGlvbiBmcm9tIFwiLi4vdmVyaWZ5L3R5cGVBc3NlcnRpb25cIjtcbmltcG9ydCB2ZXJpZnlTdGF0ZW1lbnRBc0RlZmluZWRBc3NlcnRpb24gZnJvbSBcIi4uL3ZlcmlmeS9zdGF0ZW1lbnRBc0RlZmluZWRBc3NlcnRpb25cIjtcbmltcG9ydCB2ZXJpZnlTdGF0ZW1lbnRBc0NvbnRhaW5lZEFzc2VydGlvbiBmcm9tIFwiLi4vdmVyaWZ5L3N0YXRlbWVudEFzQ29udGFpbmVkQXNzZXJ0aW9uXCI7XG5pbXBvcnQgc3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JOb2Rlc1ZlcmlmaWVyIGZyb20gXCIuLi92ZXJpZmllci9ub2Rlcy9zdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvclwiO1xuXG5pbXBvcnQgeyBERUZJTkVELCBDT05UQUlORUQgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIG5vZGVzUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5cbmNvbnN0IGVxdWFsaXR5Tm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC9lcXVhbGl0eSFcIiksXG4gICAgICB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC90eXBlQXNzZXJ0aW9uIVwiKSxcbiAgICAgIG9wZXJhdG9yVGVybWluYWxOb2Rlc1F1ZXJ5ID0gbm9kZXNRdWVyeShcIi9zdGF0ZW1lbnQvQG9wZXJhdG9yXCIpO1xuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGxvY2FsQ29udGV4dCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWQ7XG5cbiAgY29uc3Qgc3RhdGVtZW50U3RyaW5nID0gbG9jYWxDb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBsb2NhbENvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50Li4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29uc3QgdmVyaWZ5U3RhdGVtZW50RnVuY3Rpb25zID0gW1xuICAgIHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHksXG4gICAgdmVyaWZ5U3RhdGVtZW50QXNUeXBlQXNzZXJ0aW9uLFxuICAgIHZlcmlmeVN0YXRlbWVudEFzRGVmaW5lZEFzc2VydGlvbixcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBc0NvbnRhaW5lZEFzc2VydGlvbixcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcnNcbiAgXTtcblxuICBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucy5zb21lKCh2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbikgPT4ge1xuICAgIGNvbnN0IHN0YXRlbWVudFZlcmlmaWVkID0gdmVyaWZ5U3RhdGVtZW50RnVuY3Rpb24oc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGxvY2FsQ29udGV4dCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgbG9jYWxDb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50LmAsIHN0YXRlbWVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudFZlcmlmaWVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U3RhbmRhbG9uZVN0YXRlbWVudChzdGF0ZW1lbnROb2RlLCBsb2NhbENvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGFuZGFsb25lU3RhdGVtZW50VmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBsb2NhbENvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gIGxvY2FsQ29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGFuZGFsb25lIHN0YXRlbWVudC4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnN0IGRlcml2ZWQgPSBmYWxzZSxcbiAgICAgICAgYXNzaWdubWVudHMgPSBbXSxcbiAgICAgICAgc3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQpO1xuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgIGNvbnN0IHZlcmlmaWVkQWhlYWQgPSB2ZXJpZnlBaGVhZCgpO1xuXG4gICAgc3RhbmRhbG9uZVN0YXRlbWVudFZlcmlmaWVkID0gdmVyaWZpZWRBaGVhZDsgLy8vXG4gIH1cblxuICBpZiAoc3RhbmRhbG9uZVN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgbG9jYWxDb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhbmRhbG9uZSBzdGF0ZW1lbnQuYCwgc3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhbmRhbG9uZVN0YXRlbWVudFZlcmlmaWVkO1xufVxuXG5PYmplY3QuYXNzaWduKHN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yTm9kZXNWZXJpZmllciwge1xuICB2ZXJpZnlTdGF0ZW1lbnRcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB2ZXJpZnlTdGF0ZW1lbnQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5KHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBsb2NhbENvbnRleHQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eSA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudEVxdWFsaXR5ID0gaXNTdGF0ZW1lbnRFcXVhbGl0eShzdGF0ZW1lbnROb2RlKTtcblxuICBpZiAoc3RhdGVtZW50RXF1YWxpdHkpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBsb2NhbENvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gICAgbG9jYWxDb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhbiBlcXVhbGl0eS4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gICAgY29uc3QgZXF1YWxpdHlOb2RlID0gZXF1YWxpdHlOb2RlUXVlcnkoc3RhdGVtZW50Tm9kZSksXG4gICAgICAgICAgZXF1YWxpdHlWZXJpZmllZCA9IHZlcmlmeUVxdWFsaXR5KGVxdWFsaXR5Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGxvY2FsQ29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRBaGVhZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllZEFoZWFkO1xuICAgICAgICAgIH0pO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5ID0gZXF1YWxpdHlWZXJpZmllZDsgLy8vXG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5KSB7XG4gICAgICBsb2NhbENvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYW4gZXF1YWxpdHkuYCwgc3RhdGVtZW50Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzVHlwZUFzc2VydGlvbihzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgbG9jYWxDb250ZXh0KSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudFR5cGVBc3NlcnRpb24gPSBpc1N0YXRlbWVudFR5cGVBc3NlcnRpb24oc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKHN0YXRlbWVudFR5cGVBc3NlcnRpb24pIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBsb2NhbENvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gICAgbG9jYWxDb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHR5cGUgYXNzZXJ0aW9uLi4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgICBjb25zdCB0eXBlQXNzZXJ0aW9uTm9kZSA9IHR5cGVBc3NlcnRpb25Ob2RlUXVlcnkoc3RhdGVtZW50Tm9kZSksXG4gICAgICAgICAgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGxvY2FsQ29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRBaGVhZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiB2ZXJpZmllZEFoZWFkO1xuICAgICAgICAgIH0pO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24gPSB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQ7IC8vL1xuXG4gICAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uKSB7XG4gICAgICBsb2NhbENvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGFzc2VydGlvbi5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb247XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9ycyhzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgbG9jYWxDb250ZXh0KSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycyA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudEVxdWFsaXR5ID0gaXNTdGF0ZW1lbnRFcXVhbGl0eShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgc3RhdGVtZW50VHlwZUFzc2VydGlvbiA9IGlzU3RhdGVtZW50VHlwZUFzc2VydGlvbihzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgc3RhdGVtZW50RGVmaW5lZEFzc2VydGlvbiA9IGlzU3RhdGVtZW50RGVmaW5lZEFzc2VydGlvbihzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgc3RhdGVtZW50Q29udGFpbmVkQXNzZXJ0aW9uID0gaXNTdGF0ZW1lbnRDb250YWluZWRBc3NlcnRpb24oc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKCFzdGF0ZW1lbnRFcXVhbGl0eSAmJiAhc3RhdGVtZW50VHlwZUFzc2VydGlvbiAmJiAhc3RhdGVtZW50RGVmaW5lZEFzc2VydGlvbiAmJiAhc3RhdGVtZW50Q29udGFpbmVkQXNzZXJ0aW9uKSB7XG4gICAgbGV0IGNvbWJpbmF0b3JzID0gbG9jYWxDb250ZXh0LmdldENvbWJpbmF0b3JzKCk7XG5cbiAgICBjb21iaW5hdG9ycyA9IFsgLy8vXG4gICAgICBicmFja2V0ZWRDb21iaW5hdG9yLFxuICAgICAgLi4uY29tYmluYXRvcnNcbiAgICBdO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnMgPSBjb21iaW5hdG9ycy5zb21lKChjb21iaW5hdG9yKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yID0gdmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3Ioc3RhdGVtZW50Tm9kZSwgY29tYmluYXRvciwgbG9jYWxDb250ZXh0KTtcblxuICAgICAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnM7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yKHN0YXRlbWVudE5vZGUsIGNvbWJpbmF0b3IsIGxvY2FsQ29udGV4dCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcjtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBsb2NhbENvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpLFxuICAgICAgICBjb21iaW5hdG9yU3RyaW5nID0gY29tYmluYXRvci5nZXRTdHJpbmcoKTtcblxuICBsb2NhbENvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFnYWluc3QgdGhlICcke2NvbWJpbmF0b3JTdHJpbmd9JyBjb21iaW5hdG9yLi4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29uc3QgY29tYmluYXRvclN0YXRlbWVudE5vZGUgPSBjb21iaW5hdG9yLmdldFN0YXRlbWVudE5vZGUoKSxcbiAgICAgICAgbm9uVGVybWluYWxOb2RlQSA9IHN0YXRlbWVudE5vZGUsIC8vL1xuICAgICAgICBub25UZXJtaW5hbE5vZGVCID0gY29tYmluYXRvclN0YXRlbWVudE5vZGUsIC8vL1xuICAgICAgICBub25UZXJtaW5hbE5vZGVWZXJpZmllZCA9IHN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yTm9kZXNWZXJpZmllci52ZXJpZnlOb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlQSwgbm9uVGVybWluYWxOb2RlQiwgbG9jYWxDb250ZXh0LCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmVyaWZpZWRBaGVhZCA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gdmVyaWZpZWRBaGVhZDtcbiAgICAgICAgfSk7XG5cbiAgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciA9IG5vblRlcm1pbmFsTm9kZVZlcmlmaWVkOyAgLy8vXG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IpIHtcbiAgICBsb2NhbENvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYWdhaW5zdCB0aGUgJyR7Y29tYmluYXRvclN0cmluZ30nIGNvbWJpbmF0b3IuYCwgc3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcjtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZW1lbnRFcXVhbGl0eShzdGF0ZW1lbnROb2RlKSB7XG4gIGNvbnN0IGVxdWFsaXR5Tm9kZSA9IGVxdWFsaXR5Tm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpLFxuICAgICAgICBzdGF0ZW1lbnRFcXVhbGl0eSA9IChlcXVhbGl0eU5vZGUgIT09IG51bGwpO1xuXG4gIHJldHVybiBzdGF0ZW1lbnRFcXVhbGl0eTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uKHN0YXRlbWVudE5vZGUpIHtcbiAgY29uc3QgdHlwZUFzc2VydGlvbk5vZGUgPSB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpLFxuICAgICAgICBzdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uID0gKHR5cGVBc3NlcnRpb25Ob2RlID09PSBudWxsKTtcblxuICByZXR1cm4gc3RhdGVtZW50VHlwZUFzc2VydGlvbjtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZW1lbnREZWZpbmVkQXNzZXJ0aW9uKHN0YXRlbWVudE5vZGUpIHtcbiAgY29uc3Qgb3BlcmF0b3JUZXJtaW5hbE5vZGVzID0gb3BlcmF0b3JUZXJtaW5hbE5vZGVzUXVlcnkoc3RhdGVtZW50Tm9kZSksXG4gICAgICAgIHN0YXRlbWVudERlZmluZWRBc3NlcnRpb24gPSBvcGVyYXRvclRlcm1pbmFsTm9kZXMuc29tZSgob3BlcmF0b3JUZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gb3BlcmF0b3JUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREZWZpbmVkID0gKGNvbnRlbnQgPT09IERFRklORUQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnREZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBzdGF0ZW1lbnREZWZpbmVkQXNzZXJ0aW9uO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlbWVudENvbnRhaW5lZEFzc2VydGlvbihzdGF0ZW1lbnROb2RlKSB7XG4gIGNvbnN0IG9wZXJhdG9yVGVybWluYWxOb2RlcyA9IG9wZXJhdG9yVGVybWluYWxOb2Rlc1F1ZXJ5KHN0YXRlbWVudE5vZGUpLFxuICAgICAgICBzdGF0ZW1lbnRDb250YWluZWRBc3NlcnRpb24gPSBvcGVyYXRvclRlcm1pbmFsTm9kZXMuc29tZSgob3BlcmF0b3JUZXJtaW5hbE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gb3BlcmF0b3JUZXJtaW5hbE5vZGUuZ2V0Q29udGVudCgpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRDb250YWluZWQgPSAoY29udGVudCA9PT0gQ09OVEFJTkVEKTtcblxuICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gIHJldHVybiBzdGF0ZW1lbnRDb250YWluZWRBc3NlcnRpb247XG59XG4iXSwibmFtZXMiOlsidmVyaWZ5U3RhbmRhbG9uZVN0YXRlbWVudCIsInZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHkiLCJ2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVBc3NlcnRpb24iLCJlcXVhbGl0eU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInR5cGVBc3NlcnRpb25Ob2RlUXVlcnkiLCJvcGVyYXRvclRlcm1pbmFsTm9kZXNRdWVyeSIsIm5vZGVzUXVlcnkiLCJ2ZXJpZnlTdGF0ZW1lbnQiLCJzdGF0ZW1lbnROb2RlIiwiYXNzaWdubWVudHMiLCJkZXJpdmVkIiwibG9jYWxDb250ZXh0Iiwic3RhdGVtZW50VmVyaWZpZWQiLCJzdGF0ZW1lbnRTdHJpbmciLCJub2RlQXNTdHJpbmciLCJ0cmFjZSIsInZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucyIsInZlcmlmeVN0YXRlbWVudEFzRGVmaW5lZEFzc2VydGlvbiIsInZlcmlmeVN0YXRlbWVudEFzQ29udGFpbmVkQXNzZXJ0aW9uIiwidmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzIiwic29tZSIsInZlcmlmeVN0YXRlbWVudEZ1bmN0aW9uIiwiZGVidWciLCJ2ZXJpZnlBaGVhZCIsInN0YW5kYWxvbmVTdGF0ZW1lbnRWZXJpZmllZCIsInZlcmlmaWVkQWhlYWQiLCJPYmplY3QiLCJhc3NpZ24iLCJzdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvck5vZGVzVmVyaWZpZXIiLCJzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHkiLCJzdGF0ZW1lbnRFcXVhbGl0eSIsImlzU3RhdGVtZW50RXF1YWxpdHkiLCJlcXVhbGl0eU5vZGUiLCJlcXVhbGl0eVZlcmlmaWVkIiwidmVyaWZ5RXF1YWxpdHkiLCJzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiIsInN0YXRlbWVudFR5cGVBc3NlcnRpb24iLCJpc1N0YXRlbWVudFR5cGVBc3NlcnRpb24iLCJ0eXBlQXNzZXJ0aW9uTm9kZSIsInR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVR5cGVBc3NlcnRpb24iLCJzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycyIsInN0YXRlbWVudERlZmluZWRBc3NlcnRpb24iLCJpc1N0YXRlbWVudERlZmluZWRBc3NlcnRpb24iLCJzdGF0ZW1lbnRDb250YWluZWRBc3NlcnRpb24iLCJpc1N0YXRlbWVudENvbnRhaW5lZEFzc2VydGlvbiIsImNvbWJpbmF0b3JzIiwiZ2V0Q29tYmluYXRvcnMiLCJicmFja2V0ZWRDb21iaW5hdG9yIiwiY29tYmluYXRvciIsInN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IiLCJ2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvciIsImNvbWJpbmF0b3JTdHJpbmciLCJnZXRTdHJpbmciLCJjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSIsImdldFN0YXRlbWVudE5vZGUiLCJub25UZXJtaW5hbE5vZGVBIiwibm9uVGVybWluYWxOb2RlQiIsIm5vblRlcm1pbmFsTm9kZVZlcmlmaWVkIiwidmVyaWZ5Tm9uVGVybWluYWxOb2RlIiwib3BlcmF0b3JUZXJtaW5hbE5vZGVzIiwib3BlcmF0b3JUZXJtaW5hbE5vZGUiLCJjb250ZW50IiwiZ2V0Q29udGVudCIsImNvbnRlbnREZWZpbmVkIiwiREVGSU5FRCIsImNvbnRlbnRDb250YWluZWQiLCJDT05UQUlORUQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQTBFQSxPQUErQjtlQUEvQjs7SUE1QmdCQSx5QkFBeUI7ZUFBekJBOztJQThCQUMseUJBQXlCO2VBQXpCQTs7SUEyQkFDLDhCQUE4QjtlQUE5QkE7OzsrREFyR1c7Z0VBQ0s7b0VBQ0E7a0ZBQ2M7b0ZBQ0U7aUZBQ0k7eUJBRWpCO3FCQUNHOzs7Ozs7Ozs7Ozs7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