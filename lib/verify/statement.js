"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    verifyStatementAgainstCombinator: function() {
        return verifyStatementAgainstCombinator;
    },
    verifyStatementAgainstCombinators: function() {
        return verifyStatementAgainstCombinators;
    }
});
var _equality = /*#__PURE__*/ _interop_require_default(require("../equality"));
var _term = /*#__PURE__*/ _interop_require_default(require("../verify/term"));
var _bracketed = /*#__PURE__*/ _interop_require_default(require("../ocmbinator/bracketed"));
var _typeInference = /*#__PURE__*/ _interop_require_default(require("../verify/typeInference"));
var _typeAssertion = /*#__PURE__*/ _interop_require_default(require("../verify/typeAssertion"));
var _equality1 = /*#__PURE__*/ _interop_require_default(require("../node/statement/equality"));
var _statement = /*#__PURE__*/ _interop_require_default(require("../verifier/nodes/statement"));
var _query = require("../utilities/query");
var _array = require("../utilities/array");
var _constants = require("../constants");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var leftTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[0]/term!"), rightTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[1]/term!"), typeInferenceNodeQuery = (0, _query.nodeQuery)("/statement/typeInference!"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatement(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerified;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement..."), statementNode);
    var verifyStatementFunctions = [
        verifyStatementAsEquality,
        verifyStatementAsTypeInference,
        verifyStatementAsTypeAssertion,
        verifyStatementAgainstCombinators
    ];
    statementVerified = verifyStatementFunctions.some(function(verifyStatementFunction) {
        var statementVerified = verifyStatementFunction(statementNode, assignments, derived, context, verifyAhead);
        if (statementVerified) {
            return true;
        }
    });
    if (statementVerified) {
        context.debug("...verified the '".concat(statementString, "' statement."), statementNode);
    }
    return statementVerified;
}
Object.assign(verifyStatement, {
    statementNodesVerifier: _statement.default
});
var _default = verifyStatement;
function verifyStatementAgainstCombinators(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAgainstCombinators;
    var combinators = context.getCombinators();
    combinators = [
        _bracketed.default
    ].concat(_to_consumable_array(combinators));
    statementVerifiedAgainstCombinators = combinators.some(function(combinator) {
        var statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead);
        if (statementVerifiedAgainstCombinator) {
            return true;
        }
    });
    return statementVerifiedAgainstCombinators;
}
function verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead) {
    var statementVerifiedAgainstCombinator;
    var statementString = context.nodeAsString(statementNode), combinatorString = combinator.getString();
    context.trace("Verifying the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator..."), statementNode);
    var combinatorStatementNode = combinator.getStatementNode(), nonTerminalNodeA = statementNode, nonTerminalNodeB = combinatorStatementNode, nonTerminalNodeVerified = _statement.default.verifyNonTerminalNode(nonTerminalNodeA, nonTerminalNodeB, context, verifyAhead);
    statementVerifiedAgainstCombinator = nonTerminalNodeVerified; ///
    if (statementVerifiedAgainstCombinator) {
        context.debug("...verified the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator."), statementNode);
    }
    return statementVerifiedAgainstCombinator;
}
function verifyStatementAsTypeInference(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeInference = false;
    var typeInferenceNode = typeInferenceNodeQuery(statementNode);
    if (typeInferenceNode !== null) {
        var statementString = context.nodeAsString(statementNode);
        context.trace("Verifying the '".concat(statementString, "' statement as a type inference..."), statementNode);
        if (!derived) {
            var typeInferenceString = context.nodeAsString(typeInferenceNode);
            context.debug("The '".concat(typeInferenceString, "' type inference can only be derived."), typeInferenceNode);
        } else {
            var typeInferenceVerified = (0, _typeInference.default)(typeInferenceNode, context, verifyAhead);
            statementVerifiedAsTypeInference = typeInferenceVerified; ///
        }
        if (statementVerifiedAsTypeInference) {
            context.debug("...verified the '".concat(statementString, "' statement as a type inference."), statementNode);
        }
    }
    return statementVerifiedAsTypeInference;
}
function verifyStatementAsTypeAssertion(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeAssertion = false;
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var statementString = context.nodeAsString(statementNode);
        context.trace("Verifying the '".concat(statementString, "' statement as a type assertion..."), statementNode);
        var typeAssertionVerified = (0, _typeAssertion.default)(typeAssertionNode, assignments, derived, context, verifyAhead);
        statementVerifiedAsTypeAssertion = typeAssertionVerified; ///
        if (statementVerifiedAsTypeAssertion) {
            context.debug("...verified the '".concat(statementString, "' statement as a type assertion."), statementNode);
        }
    }
    return statementVerifiedAsTypeAssertion;
}
function verifyStatementAsEquality(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsEquality = false;
    var depth = _constants.EQUALITY_DEPTH, statementNodeMatchesEqualityStatementNode = statementNode.match(_equality1.default, depth);
    if (statementNodeMatchesEqualityStatementNode) {
        var statementString = context.nodeAsString(statementNode);
        context.trace("Verifying the '".concat(statementString, "' statement as an equality..."), statementNode);
        var verifyStatementAsEqualityFunctions = [
            verifyStatementAsDerivedEquality,
            verifyStatementAsStandaloneEquality
        ];
        statementVerifiedAsEquality = verifyStatementAsEqualityFunctions.some(function(verifyStatementAsEqualityFunction) {
            var statementVerified = verifyStatementAsEqualityFunction(statementNode, derived, context, verifyAhead);
            if (statementVerified) {
                return true;
            }
        });
        if (statementVerifiedAsEquality) {
            context.debug("...verified the '".concat(statementString, "' statement as an equality."), statementNode);
        }
    }
    return statementVerifiedAsEquality;
}
function verifyStatementAsDerivedEquality(statementNode, derived, context, verifyAhead) {
    var verifiedStatementAsDerivedEquality = false;
    if (derived) {
        var statementString = context.nodeAsString(statementNode);
        context.trace("Verifying the '".concat(statementString, "' statement as a derived equality..."), statementNode);
        var equality = _equality.default.fromStatementNode(statementNode), equalities = context.getEqualities(), equalityVerified = equality.verify(equalities, context, verifyAhead);
        verifiedStatementAsDerivedEquality = equalityVerified; ///
        if (verifiedStatementAsDerivedEquality) {
            context.debug("...verified the '".concat(statementString, "' statement as a derived equality."), statementNode);
        }
    }
    return verifiedStatementAsDerivedEquality;
}
function verifyStatementAsStandaloneEquality(statementNode, derived, context, verifyAhead) {
    var statementVerifiedAsStandaloneEquality;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a standalone equality..."), statementNode);
    var types = [], leftTermNode = leftTermNodeQuery(statementNode), leftTermVerified = (0, _term.default)(leftTermNode, types, context, function() {
        var verifiedAhead;
        var rightTermNode = rightTermNodeQuery(statementNode), rightTermVerified = (0, _term.default)(rightTermNode, types, context, function() {
            var verifiedAhead = false;
            var firstType = (0, _array.first)(types), secondType = (0, _array.second)(types), leftType = firstType, rightType = secondType, leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType = leftType.isEqualToOrSubTypeOfOfSuperTypeOf(rightType);
            if (!leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType) {
                var leftTypeName = leftType.getName(), rightTypeName = rightType.getName(), leftTermString = context.nodeAsString(leftTermNode), rightTermString = context.nodeAsString(rightTermNode);
                context.debug("The left '".concat(leftTermString, "' term's '").concat(leftTypeName, "' type is not equal to, a sub-type of nor a super-type of the right '").concat(rightTermString, "' term's '").concat(rightTypeName, "' type."), statementNode);
            } else {
                verifiedAhead = verifyAhead();
            }
            return verifiedAhead;
        });
        verifiedAhead = rightTermVerified; ///
        return verifiedAhead;
    });
    statementVerifiedAsStandaloneEquality = leftTermVerified; ///
    if (statementVerifiedAsStandaloneEquality) {
        context.trace("...verified the '".concat(statementString, "' statement as a standalone equality."), statementNode);
    }
    return statementVerifiedAsStandaloneEquality;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRXF1YWxpdHkgZnJvbSBcIi4uL2VxdWFsaXR5XCI7XG5pbXBvcnQgdmVyaWZ5VGVybSBmcm9tIFwiLi4vdmVyaWZ5L3Rlcm1cIjtcbmltcG9ydCBicmFja2V0ZWRDb21iaW5hdG9yIGZyb20gXCIuLi9vY21iaW5hdG9yL2JyYWNrZXRlZFwiO1xuaW1wb3J0IHZlcmlmeVR5cGVJbmZlcmVuY2UgZnJvbSBcIi4uL3ZlcmlmeS90eXBlSW5mZXJlbmNlXCI7XG5pbXBvcnQgdmVyaWZ5VHlwZUFzc2VydGlvbiBmcm9tIFwiLi4vdmVyaWZ5L3R5cGVBc3NlcnRpb25cIjtcbmltcG9ydCBlcXVhbGl0eVN0YXRlbWVudE5vZGUgZnJvbSBcIi4uL25vZGUvc3RhdGVtZW50L2VxdWFsaXR5XCI7XG5pbXBvcnQgc3RhdGVtZW50Tm9kZXNWZXJpZmllciBmcm9tIFwiLi4vdmVyaWZpZXIvbm9kZXMvc3RhdGVtZW50XCI7XG5cbmltcG9ydCB7IG5vZGVRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5pbXBvcnQgeyBFUVVBTElUWV9ERVBUSCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgbGVmdFRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvc3RhdGVtZW50L2FyZ3VtZW50WzBdL3Rlcm0hXCIpLFxuICAgICAgcmlnaHRUZXJtTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC9hcmd1bWVudFsxXS90ZXJtIVwiKSxcbiAgICAgIHR5cGVJbmZlcmVuY2VOb2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvc3RhdGVtZW50L3R5cGVJbmZlcmVuY2UhXCIpLFxuICAgICAgdHlwZUFzc2VydGlvbk5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9zdGF0ZW1lbnQvdHlwZUFzc2VydGlvbiFcIik7XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudChzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50Li4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29uc3QgdmVyaWZ5U3RhdGVtZW50RnVuY3Rpb25zID0gW1xuICAgIHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHksXG4gICAgdmVyaWZ5U3RhdGVtZW50QXNUeXBlSW5mZXJlbmNlLFxuICAgIHZlcmlmeVN0YXRlbWVudEFzVHlwZUFzc2VydGlvbixcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcnNcbiAgXTtcblxuICBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucy5zb21lKCh2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbikgPT4ge1xuICAgIGNvbnN0IHN0YXRlbWVudFZlcmlmaWVkID0gdmVyaWZ5U3RhdGVtZW50RnVuY3Rpb24oc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgIGlmIChzdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50LmAsIHN0YXRlbWVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudFZlcmlmaWVkO1xufVxuXG5PYmplY3QuYXNzaWduKHZlcmlmeVN0YXRlbWVudCwge1xuICBzdGF0ZW1lbnROb2Rlc1ZlcmlmaWVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdmVyaWZ5U3RhdGVtZW50O1xuXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzKHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnM7XG5cbiAgbGV0IGNvbWJpbmF0b3JzID0gY29udGV4dC5nZXRDb21iaW5hdG9ycygpO1xuXG4gIGNvbWJpbmF0b3JzID0gWyAvLy9cbiAgICBicmFja2V0ZWRDb21iaW5hdG9yLFxuICAgIC4uLmNvbWJpbmF0b3JzXG4gIF07XG5cbiAgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnMgPSBjb21iaW5hdG9ycy5zb21lKChjb21iaW5hdG9yKSA9PiB7XG4gICAgY29uc3Qgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciA9IHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yKHN0YXRlbWVudE5vZGUsIGNvbWJpbmF0b3IsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yKHN0YXRlbWVudE5vZGUsIGNvbWJpbmF0b3IsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpLFxuICAgICAgICBjb21iaW5hdG9yU3RyaW5nID0gY29tYmluYXRvci5nZXRTdHJpbmcoKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhZ2FpbnN0IHRoZSAnJHtjb21iaW5hdG9yU3RyaW5nfScgY29tYmluYXRvci4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnN0IGNvbWJpbmF0b3JTdGF0ZW1lbnROb2RlID0gY29tYmluYXRvci5nZXRTdGF0ZW1lbnROb2RlKCksXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZUEgPSBzdGF0ZW1lbnROb2RlLCAvLy9cbiAgICAgICAgbm9uVGVybWluYWxOb2RlQiA9IGNvbWJpbmF0b3JTdGF0ZW1lbnROb2RlLCAvLy9cbiAgICAgICAgbm9uVGVybWluYWxOb2RlVmVyaWZpZWQgPSBzdGF0ZW1lbnROb2Rlc1ZlcmlmaWVyLnZlcmlmeU5vblRlcm1pbmFsTm9kZShub25UZXJtaW5hbE5vZGVBLCBub25UZXJtaW5hbE5vZGVCLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciA9IG5vblRlcm1pbmFsTm9kZVZlcmlmaWVkOyAgLy8vXG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IpIHtcbiAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFnYWluc3QgdGhlICcke2NvbWJpbmF0b3JTdHJpbmd9JyBjb21iaW5hdG9yLmAsIHN0YXRlbWVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3I7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzVHlwZUluZmVyZW5jZShzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlSW5mZXJlbmNlID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZUluZmVyZW5jZU5vZGUgPSB0eXBlSW5mZXJlbmNlTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICh0eXBlSW5mZXJlbmNlTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gICAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGluZmVyZW5jZS4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gICAgaWYgKCFkZXJpdmVkKSB7XG4gICAgICBjb25zdCB0eXBlSW5mZXJlbmNlU3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcodHlwZUluZmVyZW5jZU5vZGUpO1xuXG4gICAgICBjb250ZXh0LmRlYnVnKGBUaGUgJyR7dHlwZUluZmVyZW5jZVN0cmluZ30nIHR5cGUgaW5mZXJlbmNlIGNhbiBvbmx5IGJlIGRlcml2ZWQuYCwgdHlwZUluZmVyZW5jZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlSW5mZXJlbmNlVmVyaWZpZWQgPSB2ZXJpZnlUeXBlSW5mZXJlbmNlKHR5cGVJbmZlcmVuY2VOb2RlLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICAgIHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlSW5mZXJlbmNlID0gdHlwZUluZmVyZW5jZVZlcmlmaWVkOyAvLy9cbiAgICB9XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2UpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGluZmVyZW5jZS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2U7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzVHlwZUFzc2VydGlvbihzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZUFzc2VydGlvbk5vZGUgPSB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICh0eXBlQXNzZXJ0aW9uTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gICAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGFzc2VydGlvbi4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gICAgY29uc3QgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgIHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uID0gdHlwZUFzc2VydGlvblZlcmlmaWVkOyAvLy9cblxuICAgIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbikge1xuICAgICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHR5cGUgYXNzZXJ0aW9uLmAsIHN0YXRlbWVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbjtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eShzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eSA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlcHRoID0gRVFVQUxJVFlfREVQVEgsXG4gICAgICAgIHN0YXRlbWVudE5vZGVNYXRjaGVzRXF1YWxpdHlTdGF0ZW1lbnROb2RlID0gc3RhdGVtZW50Tm9kZS5tYXRjaChlcXVhbGl0eVN0YXRlbWVudE5vZGUsIGRlcHRoKTtcblxuICBpZiAoc3RhdGVtZW50Tm9kZU1hdGNoZXNFcXVhbGl0eVN0YXRlbWVudE5vZGUpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICAgIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGFuIGVxdWFsaXR5Li4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgICBjb25zdCB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb25zID0gW1xuICAgICAgdmVyaWZ5U3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHksXG4gICAgICB2ZXJpZnlTdGF0ZW1lbnRBc1N0YW5kYWxvbmVFcXVhbGl0eVxuICAgIF07XG5cbiAgICBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHkgPSB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb25zLnNvbWUoKHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHlGdW5jdGlvbikgPT4ge1xuICAgICAgY29uc3Qgc3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb24oc3RhdGVtZW50Tm9kZSwgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpO1xuXG4gICAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5KSB7XG4gICAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGFuIGVxdWFsaXR5LmAsIHN0YXRlbWVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5KHN0YXRlbWVudE5vZGUsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5ID0gZmFsc2U7XG5cbiAgaWYgKGRlcml2ZWQpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICAgIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgZGVyaXZlZCBlcXVhbGl0eS4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gICAgY29uc3QgZXF1YWxpdHkgPSBFcXVhbGl0eS5mcm9tU3RhdGVtZW50Tm9kZShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICBlcXVhbGl0aWVzID0gY29udGV4dC5nZXRFcXVhbGl0aWVzKCksXG4gICAgICAgICAgZXF1YWxpdHlWZXJpZmllZCA9IGVxdWFsaXR5LnZlcmlmeShlcXVhbGl0aWVzLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5ID0gZXF1YWxpdHlWZXJpZmllZDsgIC8vL1xuXG4gICAgaWYgKHZlcmlmaWVkU3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHkpIHtcbiAgICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSBkZXJpdmVkIGVxdWFsaXR5LmAsIHN0YXRlbWVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5O1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc1N0YW5kYWxvbmVFcXVhbGl0eShzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc1N0YW5kYWxvbmVFcXVhbGl0eTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHN0YW5kYWxvbmUgZXF1YWxpdHkuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCB0eXBlcyA9IFtdLFxuICAgICAgICBsZWZ0VGVybU5vZGUgPSBsZWZ0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgbGVmdFRlcm1WZXJpZmllZCA9IHZlcmlmeVRlcm0obGVmdFRlcm1Ob2RlLCB0eXBlcywgY29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgIGxldCB2ZXJpZmllZEFoZWFkO1xuXG4gICAgICAgICAgY29uc3QgcmlnaHRUZXJtTm9kZSA9IHJpZ2h0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICAgICAgICByaWdodFRlcm1WZXJpZmllZCA9IHZlcmlmeVRlcm0ocmlnaHRUZXJtTm9kZSwgdHlwZXMsIGNvbnRleHQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCB2ZXJpZmllZEFoZWFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFR5cGUgPSBzZWNvbmQodHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFR5cGUgPSBmaXJzdFR5cGUsIC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUeXBlID0gc2Vjb25kVHlwZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VHlwZUVxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2ZSaWdodFR5cGUgPSBsZWZ0VHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2YocmlnaHRUeXBlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0VHlwZUVxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2ZSaWdodFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdFR5cGVOYW1lID0gbGVmdFR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFR5cGVOYW1lID0gcmlnaHRUeXBlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFRlcm1TdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhsZWZ0VGVybU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFRlcm1TdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhyaWdodFRlcm1Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRlYnVnKGBUaGUgbGVmdCAnJHtsZWZ0VGVybVN0cmluZ30nIHRlcm0ncyAnJHtsZWZ0VHlwZU5hbWV9JyB0eXBlIGlzIG5vdCBlcXVhbCB0bywgYSBzdWItdHlwZSBvZiBub3IgYSBzdXBlci10eXBlIG9mIHRoZSByaWdodCAnJHtyaWdodFRlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7cmlnaHRUeXBlTmFtZX0nIHR5cGUuYCwgc3RhdGVtZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZEFoZWFkID0gdmVyaWZ5QWhlYWQoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVkQWhlYWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdmVyaWZpZWRBaGVhZCA9IHJpZ2h0VGVybVZlcmlmaWVkOyAgLy8vXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVkQWhlYWQ7XG4gICAgICAgICAgICB9KTtcblxuICBzdGF0ZW1lbnRWZXJpZmllZEFzU3RhbmRhbG9uZUVxdWFsaXR5ID0gbGVmdFRlcm1WZXJpZmllZDsgLy8vXG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQXNTdGFuZGFsb25lRXF1YWxpdHkpIHtcbiAgICBjb250ZXh0LnRyYWNlKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgc3RhbmRhbG9uZSBlcXVhbGl0eS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzU3RhbmRhbG9uZUVxdWFsaXR5O1xufVxuIl0sIm5hbWVzIjpbInZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yIiwidmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzIiwibGVmdFRlcm1Ob2RlUXVlcnkiLCJub2RlUXVlcnkiLCJyaWdodFRlcm1Ob2RlUXVlcnkiLCJ0eXBlSW5mZXJlbmNlTm9kZVF1ZXJ5IiwidHlwZUFzc2VydGlvbk5vZGVRdWVyeSIsInZlcmlmeVN0YXRlbWVudCIsInN0YXRlbWVudE5vZGUiLCJhc3NpZ25tZW50cyIsImRlcml2ZWQiLCJjb250ZXh0IiwidmVyaWZ5QWhlYWQiLCJzdGF0ZW1lbnRWZXJpZmllZCIsInN0YXRlbWVudFN0cmluZyIsIm5vZGVBc1N0cmluZyIsInRyYWNlIiwidmVyaWZ5U3RhdGVtZW50RnVuY3Rpb25zIiwidmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eSIsInZlcmlmeVN0YXRlbWVudEFzVHlwZUluZmVyZW5jZSIsInZlcmlmeVN0YXRlbWVudEFzVHlwZUFzc2VydGlvbiIsInNvbWUiLCJ2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbiIsImRlYnVnIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdGVtZW50Tm9kZXNWZXJpZmllciIsInN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzIiwiY29tYmluYXRvcnMiLCJnZXRDb21iaW5hdG9ycyIsImJyYWNrZXRlZENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwic3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciIsImNvbWJpbmF0b3JTdHJpbmciLCJnZXRTdHJpbmciLCJjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSIsImdldFN0YXRlbWVudE5vZGUiLCJub25UZXJtaW5hbE5vZGVBIiwibm9uVGVybWluYWxOb2RlQiIsIm5vblRlcm1pbmFsTm9kZVZlcmlmaWVkIiwidmVyaWZ5Tm9uVGVybWluYWxOb2RlIiwic3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2UiLCJ0eXBlSW5mZXJlbmNlTm9kZSIsInR5cGVJbmZlcmVuY2VTdHJpbmciLCJ0eXBlSW5mZXJlbmNlVmVyaWZpZWQiLCJ2ZXJpZnlUeXBlSW5mZXJlbmNlIiwic3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24iLCJ0eXBlQXNzZXJ0aW9uTm9kZSIsInR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVR5cGVBc3NlcnRpb24iLCJzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHkiLCJkZXB0aCIsIkVRVUFMSVRZX0RFUFRIIiwic3RhdGVtZW50Tm9kZU1hdGNoZXNFcXVhbGl0eVN0YXRlbWVudE5vZGUiLCJtYXRjaCIsImVxdWFsaXR5U3RhdGVtZW50Tm9kZSIsInZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHlGdW5jdGlvbnMiLCJ2ZXJpZnlTdGF0ZW1lbnRBc0Rlcml2ZWRFcXVhbGl0eSIsInZlcmlmeVN0YXRlbWVudEFzU3RhbmRhbG9uZUVxdWFsaXR5IiwidmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eUZ1bmN0aW9uIiwidmVyaWZpZWRTdGF0ZW1lbnRBc0Rlcml2ZWRFcXVhbGl0eSIsImVxdWFsaXR5IiwiRXF1YWxpdHkiLCJmcm9tU3RhdGVtZW50Tm9kZSIsImVxdWFsaXRpZXMiLCJnZXRFcXVhbGl0aWVzIiwiZXF1YWxpdHlWZXJpZmllZCIsInZlcmlmeSIsInN0YXRlbWVudFZlcmlmaWVkQXNTdGFuZGFsb25lRXF1YWxpdHkiLCJ0eXBlcyIsImxlZnRUZXJtTm9kZSIsImxlZnRUZXJtVmVyaWZpZWQiLCJ2ZXJpZnlUZXJtIiwidmVyaWZpZWRBaGVhZCIsInJpZ2h0VGVybU5vZGUiLCJyaWdodFRlcm1WZXJpZmllZCIsImZpcnN0VHlwZSIsImZpcnN0Iiwic2Vjb25kVHlwZSIsInNlY29uZCIsImxlZnRUeXBlIiwicmlnaHRUeXBlIiwibGVmdFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZPZlN1cGVyVHlwZU9mUmlnaHRUeXBlIiwiaXNFcXVhbFRvT3JTdWJUeXBlT2ZPZlN1cGVyVHlwZU9mIiwibGVmdFR5cGVOYW1lIiwiZ2V0TmFtZSIsInJpZ2h0VHlwZU5hbWUiLCJsZWZ0VGVybVN0cmluZyIsInJpZ2h0VGVybVN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0lBb0RBLE9BQStCO2VBQS9COztJQXVCZ0JBLGdDQUFnQztlQUFoQ0E7O0lBckJBQyxpQ0FBaUM7ZUFBakNBOzs7K0RBcERLOzJEQUNFO2dFQUNTO29FQUNBO29FQUNBO2dFQUNFO2dFQUNDO3FCQUVUO3FCQUNJO3lCQUNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FB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