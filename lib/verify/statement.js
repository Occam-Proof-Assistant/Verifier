"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    verifyStatementAgainstCombinator: function() {
        return verifyStatementAgainstCombinator;
    },
    verifyStatementAgainstCombinators: function() {
        return verifyStatementAgainstCombinators;
    }
});
var _equality = /*#__PURE__*/ _interop_require_default(require("../equality"));
var _term = /*#__PURE__*/ _interop_require_default(require("../verify/term"));
var _bracketed = /*#__PURE__*/ _interop_require_default(require("../ocmbinator/bracketed"));
var _typeInference = /*#__PURE__*/ _interop_require_default(require("../verify/typeInference"));
var _type = /*#__PURE__*/ _interop_require_default(require("../verify/assertion/type"));
var _equality1 = /*#__PURE__*/ _interop_require_default(require("../node/statement/equality"));
var _statement = /*#__PURE__*/ _interop_require_default(require("../verifier/nodes/statement"));
var _query = require("../utilities/query");
var _array = require("../utilities/array");
var _constants = require("../constants");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var leftTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[0]/term!"), rightTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[1]/term!"), typeInferenceNodeQuery = (0, _query.nodeQuery)("/statement/typeInference!"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatement(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerified;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement..."), statementNode);
    var verifyStatementFunctions = [
        verifyStatementAsEquality,
        verifyStatementAsTypeInference,
        verifyStatementAsTypeAssertion,
        verifyStatementAgainstCombinators
    ];
    statementVerified = verifyStatementFunctions.some(function(verifyStatementFunction) {
        var statementVerified = verifyStatementFunction(statementNode, assignments, derived, context, verifyAhead);
        if (statementVerified) {
            return true;
        }
    });
    if (statementVerified) {
        context.debug("...verified the '".concat(statementString, "' statement."), statementNode);
    }
    return statementVerified;
}
Object.assign(verifyStatement, {
    statementNodesVerifier: _statement.default
});
var _default = verifyStatement;
function verifyStatementAgainstCombinators(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAgainstCombinators;
    var combinators = context.getCombinators();
    combinators = [
        _bracketed.default
    ].concat(_to_consumable_array(combinators));
    statementVerifiedAgainstCombinators = combinators.some(function(combinator) {
        var statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead);
        if (statementVerifiedAgainstCombinator) {
            return true;
        }
    });
    return statementVerifiedAgainstCombinators;
}
function verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead) {
    var statementVerifiedAgainstCombinator;
    var statementString = context.nodeAsString(statementNode), combinatorString = combinator.getString();
    context.trace("Verifying the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator..."), statementNode);
    var combinatorStatementNode = combinator.getStatementNode(), nonTerminalNodeA = statementNode, nonTerminalNodeB = combinatorStatementNode, nonTerminalNodeVerified = _statement.default.verifyNonTerminalNode(nonTerminalNodeA, nonTerminalNodeB, context, verifyAhead);
    statementVerifiedAgainstCombinator = nonTerminalNodeVerified; ///
    if (statementVerifiedAgainstCombinator) {
        context.debug("...verified the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator."), statementNode);
    }
    return statementVerifiedAgainstCombinator;
}
function verifyStatementAsTypeInference(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeInference = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a type inference..."), statementNode);
    var typeInferenceNode = typeInferenceNodeQuery(statementNode);
    if (typeInferenceNode !== null) {
        if (!derived) {
            var typeInferenceString = context.nodeAsString(typeInferenceNode);
            context.info("The '".concat(typeInferenceString, "' type inference can only be derived."), typeInferenceNode);
        } else {
            var typeInferenceVerified = (0, _typeInference.default)(typeInferenceNode, context, verifyAhead);
            statementVerifiedAsTypeInference = typeInferenceVerified; ///
        }
    }
    if (statementVerifiedAsTypeInference) {
        context.debug("...verified the '".concat(statementString, "' statement as a type inference."), statementNode);
    }
    return statementVerifiedAsTypeInference;
}
function verifyStatementAsTypeAssertion(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeAssertion = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a type assertion..."), statementNode);
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var typeAssertionVerified = (0, _type.default)(typeAssertionNode, assignments, derived, context, verifyAhead);
        statementVerifiedAsTypeAssertion = typeAssertionVerified; ///
    }
    if (statementVerifiedAsTypeAssertion) {
        context.debug("...verified the '".concat(statementString, "' statement as a type assertion."), statementNode);
    }
    return statementVerifiedAsTypeAssertion;
}
function verifyStatementAsEquality(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsEquality;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as an equality..."), statementNode);
    var verifyStatementAsEqualityFunctions = [
        verifyStatementAsDerivedEquality,
        verifyStatementAsStandaloneEquality
    ];
    statementVerifiedAsEquality = verifyStatementAsEqualityFunctions.some(function(verifyStatementAsEqualityFunction) {
        var statementVerified = verifyStatementAsEqualityFunction(statementNode, derived, context, verifyAhead);
        if (statementVerified) {
            return true;
        }
    });
    if (statementVerifiedAsEquality) {
        context.debug("...verified the '".concat(statementString, "' statement as an equality."), statementNode);
    }
    return statementVerifiedAsEquality;
}
function verifyStatementAsDerivedEquality(statementNode, derived, context, verifyAhead) {
    var verifiedStatementAsDerivedEquality = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a derived equality..."), statementNode);
    if (derived) {
        var equality = _equality.default.fromStatementNode(statementNode), equalities = context.getEqualities(), equalityVerified = equality.verify(equalities, context, verifyAhead);
        verifiedStatementAsDerivedEquality = equalityVerified; ///
    }
    if (verifiedStatementAsDerivedEquality) {
        context.debug("...verified the '".concat(statementString, "' statement as a derived equality."), statementNode);
    }
    return verifiedStatementAsDerivedEquality;
}
function verifyStatementAsStandaloneEquality(statementNode, derived, context, verifyAhead) {
    var statementVerifiedAsStandaloneEquality;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a standalone equality..."), statementNode);
    var depth = _constants.EQUALITY_DEPTH, statementNodeMatchesEqualityStatementNode = statementNode.match(_equality1.default, depth);
    if (statementNodeMatchesEqualityStatementNode) {
        var types = [], leftTermNode = leftTermNodeQuery(statementNode), leftTermVerified = (0, _term.default)(leftTermNode, types, context, function() {
            var verifiedAhead;
            var rightTermNode = rightTermNodeQuery(statementNode), rightTermVerified = (0, _term.default)(rightTermNode, types, context, function() {
                var verifiedAhead = false;
                var firstType = (0, _array.first)(types), secondType = (0, _array.second)(types), leftType = firstType, rightType = secondType, leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType = leftType.isEqualToOrSubTypeOfOfSuperTypeOf(rightType);
                if (!leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType) {
                    var leftTypeName = leftType.getName(), rightTypeName = rightType.getName(), leftTermString = context.nodeAsString(leftTermNode), rightTermString = context.nodeAsString(rightTermNode);
                    context.info("The left '".concat(leftTermString, "' term's '").concat(leftTypeName, "' type is not equal to, a sub-type of nor a super-type of the right '").concat(rightTermString, "' term's '").concat(rightTypeName, "' type."), statementNode);
                } else {
                    verifiedAhead = verifyAhead();
                }
                return verifiedAhead;
            });
            verifiedAhead = rightTermVerified; ///
            return verifiedAhead;
        });
        statementVerifiedAsStandaloneEquality = leftTermVerified; ///
    }
    if (statementVerifiedAsStandaloneEquality) {
        context.trace("...verified the '".concat(statementString, "' statement as a standalone equality."), statementNode);
    }
    return statementVerifiedAsStandaloneEquality;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRXF1YWxpdHkgZnJvbSBcIi4uL2VxdWFsaXR5XCI7XG5pbXBvcnQgdmVyaWZ5VGVybSBmcm9tIFwiLi4vdmVyaWZ5L3Rlcm1cIjtcbmltcG9ydCBicmFja2V0ZWRDb21iaW5hdG9yIGZyb20gXCIuLi9vY21iaW5hdG9yL2JyYWNrZXRlZFwiO1xuaW1wb3J0IHZlcmlmeVR5cGVJbmZlcmVuY2UgZnJvbSBcIi4uL3ZlcmlmeS90eXBlSW5mZXJlbmNlXCI7XG5pbXBvcnQgdmVyaWZ5VHlwZUFzc2VydGlvbiBmcm9tIFwiLi4vdmVyaWZ5L2Fzc2VydGlvbi90eXBlXCI7XG5pbXBvcnQgZXF1YWxpdHlTdGF0ZW1lbnROb2RlIGZyb20gXCIuLi9ub2RlL3N0YXRlbWVudC9lcXVhbGl0eVwiO1xuaW1wb3J0IHN0YXRlbWVudE5vZGVzVmVyaWZpZXIgZnJvbSBcIi4uL3ZlcmlmaWVyL25vZGVzL3N0YXRlbWVudFwiO1xuXG5pbXBvcnQgeyBub2RlUXVlcnkgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBmaXJzdCwgc2Vjb25kIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9hcnJheVwiO1xuaW1wb3J0IHsgRVFVQUxJVFlfREVQVEggfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmNvbnN0IGxlZnRUZXJtTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC9hcmd1bWVudFswXS90ZXJtIVwiKSxcbiAgICAgIHJpZ2h0VGVybU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9zdGF0ZW1lbnQvYXJndW1lbnRbMV0vdGVybSFcIiksXG4gICAgICB0eXBlSW5mZXJlbmNlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC90eXBlSW5mZXJlbmNlIVwiKSxcbiAgICAgIHR5cGVBc3NlcnRpb25Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvc3RhdGVtZW50L3R5cGVBc3NlcnRpb24hXCIpO1xuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZDtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudC4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnN0IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucyA9IFtcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5LFxuICAgIHZlcmlmeVN0YXRlbWVudEFzVHlwZUluZmVyZW5jZSxcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVBc3NlcnRpb24sXG4gICAgdmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzXG4gIF07XG5cbiAgc3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbnMuc29tZSgodmVyaWZ5U3RhdGVtZW50RnVuY3Rpb24pID0+IHtcbiAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9uKHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudC5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZDtcbn1cblxuT2JqZWN0LmFzc2lnbih2ZXJpZnlTdGF0ZW1lbnQsIHtcbiAgc3RhdGVtZW50Tm9kZXNWZXJpZmllclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHZlcmlmeVN0YXRlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9ycyhzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzO1xuXG4gIGxldCBjb21iaW5hdG9ycyA9IGNvbnRleHQuZ2V0Q29tYmluYXRvcnMoKTtcblxuICBjb21iaW5hdG9ycyA9IFsgLy8vXG4gICAgYnJhY2tldGVkQ29tYmluYXRvcixcbiAgICAuLi5jb21iaW5hdG9yc1xuICBdO1xuXG4gIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzID0gY29tYmluYXRvcnMuc29tZSgoY29tYmluYXRvcikgPT4ge1xuICAgIGNvbnN0IHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcihzdGF0ZW1lbnROb2RlLCBjb21iaW5hdG9yLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcihzdGF0ZW1lbnROb2RlLCBjb21iaW5hdG9yLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcjtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgY29tYmluYXRvclN0cmluZyA9IGNvbWJpbmF0b3IuZ2V0U3RyaW5nKCk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYWdhaW5zdCB0aGUgJyR7Y29tYmluYXRvclN0cmluZ30nIGNvbWJpbmF0b3IuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCBjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSA9IGNvbWJpbmF0b3IuZ2V0U3RhdGVtZW50Tm9kZSgpLFxuICAgICAgICBub25UZXJtaW5hbE5vZGVBID0gc3RhdGVtZW50Tm9kZSwgLy8vXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZUIgPSBjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSwgLy8vXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZVZlcmlmaWVkID0gc3RhdGVtZW50Tm9kZXNWZXJpZmllci52ZXJpZnlOb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlQSwgbm9uVGVybWluYWxOb2RlQiwgY29udGV4dCwgdmVyaWZ5QWhlYWQpO1xuXG4gIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSBub25UZXJtaW5hbE5vZGVWZXJpZmllZDsgIC8vL1xuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yKSB7XG4gICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhZ2FpbnN0IHRoZSAnJHtjb21iaW5hdG9yU3RyaW5nfScgY29tYmluYXRvci5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVJbmZlcmVuY2Uoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZSA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgdHlwZSBpbmZlcmVuY2UuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCB0eXBlSW5mZXJlbmNlTm9kZSA9IHR5cGVJbmZlcmVuY2VOb2RlUXVlcnkoc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGVJbmZlcmVuY2VOb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCFkZXJpdmVkKSB7XG4gICAgICBjb25zdCB0eXBlSW5mZXJlbmNlU3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcodHlwZUluZmVyZW5jZU5vZGUpO1xuXG4gICAgICBjb250ZXh0LmluZm8oYFRoZSAnJHt0eXBlSW5mZXJlbmNlU3RyaW5nfScgdHlwZSBpbmZlcmVuY2UgY2FuIG9ubHkgYmUgZGVyaXZlZC5gLCB0eXBlSW5mZXJlbmNlTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGVJbmZlcmVuY2VWZXJpZmllZCA9IHZlcmlmeVR5cGVJbmZlcmVuY2UodHlwZUluZmVyZW5jZU5vZGUsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgICAgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2UgPSB0eXBlSW5mZXJlbmNlVmVyaWZpZWQ7IC8vL1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZSkge1xuICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGluZmVyZW5jZS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50QXNUeXBlQXNzZXJ0aW9uKHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24gPSBmYWxzZTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHR5cGUgYXNzZXJ0aW9uLi4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29uc3QgdHlwZUFzc2VydGlvbk5vZGUgPSB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICh0eXBlQXNzZXJ0aW9uTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZlcmlmeVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb25WZXJpZmllZDsgLy8vXG4gIH1cblxuICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24pIHtcbiAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgdHlwZSBhc3NlcnRpb24uYCwgc3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb247XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHkoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHk7XG5cbiAgY29uc3Qgc3RhdGVtZW50U3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcoc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYW4gZXF1YWxpdHkuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb25zID0gW1xuICAgIHZlcmlmeVN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5LFxuICAgIHZlcmlmeVN0YXRlbWVudEFzU3RhbmRhbG9uZUVxdWFsaXR5XG4gIF07XG5cbiAgc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5ID0gdmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eUZ1bmN0aW9ucy5zb21lKCh2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb24pID0+IHtcbiAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHlGdW5jdGlvbihzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eSkge1xuICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYW4gZXF1YWxpdHkuYCwgc3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5O1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc0Rlcml2ZWRFcXVhbGl0eShzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgdmVyaWZpZWRTdGF0ZW1lbnRBc0Rlcml2ZWRFcXVhbGl0eSA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgZGVyaXZlZCBlcXVhbGl0eS4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmIChkZXJpdmVkKSB7XG4gICAgY29uc3QgZXF1YWxpdHkgPSBFcXVhbGl0eS5mcm9tU3RhdGVtZW50Tm9kZShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICBlcXVhbGl0aWVzID0gY29udGV4dC5nZXRFcXVhbGl0aWVzKCksXG4gICAgICAgICAgZXF1YWxpdHlWZXJpZmllZCA9IGVxdWFsaXR5LnZlcmlmeShlcXVhbGl0aWVzLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5ID0gZXF1YWxpdHlWZXJpZmllZDsgIC8vL1xuICB9XG5cbiAgaWYgKHZlcmlmaWVkU3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHkpIHtcbiAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgZGVyaXZlZCBlcXVhbGl0eS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5O1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc1N0YW5kYWxvbmVFcXVhbGl0eShzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc1N0YW5kYWxvbmVFcXVhbGl0eTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHN0YW5kYWxvbmUgZXF1YWxpdHkuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCBkZXB0aCA9IEVRVUFMSVRZX0RFUFRILFxuICAgICAgICBzdGF0ZW1lbnROb2RlTWF0Y2hlc0VxdWFsaXR5U3RhdGVtZW50Tm9kZSA9IHN0YXRlbWVudE5vZGUubWF0Y2goZXF1YWxpdHlTdGF0ZW1lbnROb2RlLCBkZXB0aCk7XG5cbiAgaWYgKHN0YXRlbWVudE5vZGVNYXRjaGVzRXF1YWxpdHlTdGF0ZW1lbnROb2RlKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXSxcbiAgICAgICAgICBsZWZ0VGVybU5vZGUgPSBsZWZ0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICBsZWZ0VGVybVZlcmlmaWVkID0gdmVyaWZ5VGVybShsZWZ0VGVybU5vZGUsIHR5cGVzLCBjb250ZXh0LCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmVyaWZpZWRBaGVhZDtcblxuICAgICAgICAgICAgY29uc3QgcmlnaHRUZXJtTm9kZSA9IHJpZ2h0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0VGVybVZlcmlmaWVkID0gdmVyaWZ5VGVybShyaWdodFRlcm1Ob2RlLCB0eXBlcywgY29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmVyaWZpZWRBaGVhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kVHlwZSA9IHNlY29uZCh0eXBlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUeXBlID0gZmlyc3RUeXBlLCAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUeXBlID0gc2Vjb25kVHlwZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUeXBlRXF1YWxUb09yU3ViVHlwZU9mT2ZTdXBlclR5cGVPZlJpZ2h0VHlwZSA9IGxlZnRUeXBlLmlzRXF1YWxUb09yU3ViVHlwZU9mT2ZTdXBlclR5cGVPZihyaWdodFR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZPZlN1cGVyVHlwZU9mUmlnaHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdFR5cGVOYW1lID0gbGVmdFR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VHlwZU5hbWUgPSByaWdodFR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUZXJtU3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcobGVmdFRlcm1Ob2RlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFRlcm1TdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhyaWdodFRlcm1Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5mbyhgVGhlIGxlZnQgJyR7bGVmdFRlcm1TdHJpbmd9JyB0ZXJtJ3MgJyR7bGVmdFR5cGVOYW1lfScgdHlwZSBpcyBub3QgZXF1YWwgdG8sIGEgc3ViLXR5cGUgb2Ygbm9yIGEgc3VwZXItdHlwZSBvZiB0aGUgcmlnaHQgJyR7cmlnaHRUZXJtU3RyaW5nfScgdGVybSdzICcke3JpZ2h0VHlwZU5hbWV9JyB0eXBlLmAsIHN0YXRlbWVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkQWhlYWQgPSB2ZXJpZnlBaGVhZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVkQWhlYWQ7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZlcmlmaWVkQWhlYWQgPSByaWdodFRlcm1WZXJpZmllZDsgIC8vL1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcmlmaWVkQWhlYWQ7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWRBc1N0YW5kYWxvbmVFcXVhbGl0eSA9IGxlZnRUZXJtVmVyaWZpZWQ7IC8vL1xuICB9XG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQXNTdGFuZGFsb25lRXF1YWxpdHkpIHtcbiAgICBjb250ZXh0LnRyYWNlKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgc3RhbmRhbG9uZSBlcXVhbGl0eS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzU3RhbmRhbG9uZUVxdWFsaXR5O1xufVxuIl0sIm5hbWVzIjpbInZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yIiwidmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzIiwibGVmdFRlcm1Ob2RlUXVlcnkiLCJub2RlUXVlcnkiLCJyaWdodFRlcm1Ob2RlUXVlcnkiLCJ0eXBlSW5mZXJlbmNlTm9kZVF1ZXJ5IiwidHlwZUFzc2VydGlvbk5vZGVRdWVyeSIsInZlcmlmeVN0YXRlbWVudCIsInN0YXRlbWVudE5vZGUiLCJhc3NpZ25tZW50cyIsImRlcml2ZWQiLCJjb250ZXh0IiwidmVyaWZ5QWhlYWQiLCJzdGF0ZW1lbnRWZXJpZmllZCIsInN0YXRlbWVudFN0cmluZyIsIm5vZGVBc1N0cmluZyIsInRyYWNlIiwidmVyaWZ5U3RhdGVtZW50RnVuY3Rpb25zIiwidmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eSIsInZlcmlmeVN0YXRlbWVudEFzVHlwZUluZmVyZW5jZSIsInZlcmlmeVN0YXRlbWVudEFzVHlwZUFzc2VydGlvbiIsInNvbWUiLCJ2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbiIsImRlYnVnIiwiT2JqZWN0IiwiYXNzaWduIiwic3RhdGVtZW50Tm9kZXNWZXJpZmllciIsInN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzIiwiY29tYmluYXRvcnMiLCJnZXRDb21iaW5hdG9ycyIsImJyYWNrZXRlZENvbWJpbmF0b3IiLCJjb21iaW5hdG9yIiwic3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciIsImNvbWJpbmF0b3JTdHJpbmciLCJnZXRTdHJpbmciLCJjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSIsImdldFN0YXRlbWVudE5vZGUiLCJub25UZXJtaW5hbE5vZGVBIiwibm9uVGVybWluYWxOb2RlQiIsIm5vblRlcm1pbmFsTm9kZVZlcmlmaWVkIiwidmVyaWZ5Tm9uVGVybWluYWxOb2RlIiwic3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2UiLCJ0eXBlSW5mZXJlbmNlTm9kZSIsInR5cGVJbmZlcmVuY2VTdHJpbmciLCJpbmZvIiwidHlwZUluZmVyZW5jZVZlcmlmaWVkIiwidmVyaWZ5VHlwZUluZmVyZW5jZSIsInN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uIiwidHlwZUFzc2VydGlvbk5vZGUiLCJ0eXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJ2ZXJpZnlUeXBlQXNzZXJ0aW9uIiwic3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5IiwidmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eUZ1bmN0aW9ucyIsInZlcmlmeVN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5IiwidmVyaWZ5U3RhdGVtZW50QXNTdGFuZGFsb25lRXF1YWxpdHkiLCJ2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb24iLCJ2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5IiwiZXF1YWxpdHkiLCJFcXVhbGl0eSIsImZyb21TdGF0ZW1lbnROb2RlIiwiZXF1YWxpdGllcyIsImdldEVxdWFsaXRpZXMiLCJlcXVhbGl0eVZlcmlmaWVkIiwidmVyaWZ5Iiwic3RhdGVtZW50VmVyaWZpZWRBc1N0YW5kYWxvbmVFcXVhbGl0eSIsImRlcHRoIiwiRVFVQUxJVFlfREVQVEgiLCJzdGF0ZW1lbnROb2RlTWF0Y2hlc0VxdWFsaXR5U3RhdGVtZW50Tm9kZSIsIm1hdGNoIiwiZXF1YWxpdHlTdGF0ZW1lbnROb2RlIiwidHlwZXMiLCJsZWZ0VGVybU5vZGUiLCJsZWZ0VGVybVZlcmlmaWVkIiwidmVyaWZ5VGVybSIsInZlcmlmaWVkQWhlYWQiLCJyaWdodFRlcm1Ob2RlIiwicmlnaHRUZXJtVmVyaWZpZWQiLCJmaXJzdFR5cGUiLCJmaXJzdCIsInNlY29uZFR5cGUiLCJzZWNvbmQiLCJsZWZ0VHlwZSIsInJpZ2h0VHlwZSIsImxlZnRUeXBlRXF1YWxUb09yU3ViVHlwZU9mT2ZTdXBlclR5cGVPZlJpZ2h0VHlwZSIsImlzRXF1YWxUb09yU3ViVHlwZU9mT2ZTdXBlclR5cGVPZiIsImxlZnRUeXBlTmFtZSIsImdldE5hbWUiLCJyaWdodFR5cGVOYW1lIiwibGVmdFRlcm1TdHJpbmciLCJyaWdodFRlcm1TdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztJQW9EQSxPQUErQjtlQUEvQjs7SUF1QmdCQSxnQ0FBZ0M7ZUFBaENBOztJQXJCQUMsaUNBQWlDO2VBQWpDQTs7OytEQXBESzsyREFDRTtnRUFDUztvRUFDQTsyREFDQTtnRUFDRTtnRUFDQztxQkFFVDtxQkFDSTt5QkFDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUvQixJQUFN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