"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyStatement;
    }
});
var _equality = /*#__PURE__*/ _interopRequireDefault(require("../equality"));
var _term = /*#__PURE__*/ _interopRequireDefault(require("../verify/term"));
var _equality1 = /*#__PURE__*/ _interopRequireDefault(require("../ocmbinator/equality"));
var _bracketed = /*#__PURE__*/ _interopRequireDefault(require("../ocmbinator/bracketed"));
var _type = /*#__PURE__*/ _interopRequireDefault(require("../verify/assertion/type"));
var _array = require("../utilities/array");
var _type1 = require("../type");
var _string = require("../utilities/string");
var _typeNames = require("../typeNames");
var _metaTypes = require("../metaTypes");
var _constants = require("../constants");
var _query = require("../utilities/query");
var _ruleNames = require("../ruleNames");
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
var termNodeQuery = (0, _query.nodeQuery)("/argument/term!"), typeNodeQuery = (0, _query.nodeQuery)("/argument/type!"), metaTypeNodeQuery = (0, _query.nodeQuery)("/metaArgument/metaType!/@meta-type"), statementNodeQuery = (0, _query.nodeQuery)("/metaArgument/statement!"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatement(statementNode, assertions, derived, context) {
    var statementVerified = false;
    context.begin(statementNode);
    if (!statementVerified) {
        var statementVerifiedAsEquality = verifyStatementAsEquality(statementNode, derived, context);
        statementVerified = statementVerifiedAsEquality; //
    }
    if (!statementVerified) {
        var statementVerifiedAsTypeAssertion = verifyStatementAsTypeAssertion(statementNode, assertions, context);
        statementVerified = statementVerifiedAsTypeAssertion; ///
    }
    if (!statementVerified) {
        var statementVerifiedAgainstCombinators = verifyStatementAgainstCombinators(statementNode, context);
        statementVerified = statementVerifiedAgainstCombinators; ///
    }
    statementVerified ? context.complete(statementNode) : context.halt(statementNode);
    return statementVerified;
}
function verifyStatementAsEquality(statementNode, derived, context) {
    var statementVerifiedAsEquality = false;
    var combinator = _equality1.default, statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context);
    if (statementVerifiedAgainstCombinator) {
        statementVerifiedAsEquality = true;
        if (derived) {
            var equality = _equality.default.fromStatementNode(statementNode), proofSteps = context.getProofSteps(), equalities = equalitiesFromProofSteps(proofSteps), equalityEquates = equality.equate(equalities);
            statementVerifiedAsEquality = equalityEquates; ///
        }
    }
    return statementVerifiedAsEquality;
}
function verifyStatementAsTypeAssertion(statementNode, assertions, context) {
    var statementVerifiedAsTypeAssertion = false;
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var typeAssertionVerified = (0, _type.default)(typeAssertionNode, assertions, context);
        statementVerifiedAsTypeAssertion = typeAssertionVerified; ///
    }
    return statementVerifiedAsTypeAssertion;
}
function verifyStatementAgainstCombinators(statementNode, context) {
    var statementVerifiedAgainstCombinators = false;
    var combinators = context.getCombinators();
    combinators = [
        _bracketed.default
    ].concat(_toConsumableArray(combinators));
    var combinator = combinators.find(function(combinator) {
        var statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context);
        if (statementVerifiedAgainstCombinator) {
            return true;
        }
    }) || null;
    if (combinator !== null) {
        statementVerifiedAgainstCombinators = true;
    }
    return statementVerifiedAgainstCombinators;
}
function verifyStatementAgainstCombinator(statementNode, combinator, context) {
    var combinatorStatementNode = combinator.getStatementNode(), node = statementNode, combinatorNode = combinatorStatementNode, nodeVerified = verifyNode(node, combinatorNode, context), statementVerifiedAgainstCombinator = nodeVerified; ///
    return statementVerifiedAgainstCombinator;
}
function verifyNode(node, combinatorNode, context) {
    var nodeVerified;
    var nodeTerminalNode = node.isTerminalNode(), combinatorNodeTerminalNode = combinatorNode.isTerminalNode();
    if (nodeTerminalNode === combinatorNodeTerminalNode) {
        if (nodeTerminalNode) {
            var terminalNode = node, combinatorTerminalNode = combinatorNode, terminalNodeVerified = verifyTerminalNode(terminalNode, combinatorTerminalNode, context);
            nodeVerified = terminalNodeVerified; ///
        } else {
            var nonTerminalNode = node, combinatorNonTerminalNode = combinatorNode, nonTerminalNodeVerified = verifyNonTerminalNode(nonTerminalNode, combinatorNonTerminalNode, context);
            nodeVerified = nonTerminalNodeVerified; ///
        }
    }
    return nodeVerified;
}
function verifyNodes(nodes, combinatorNodes, context) {
    var nodesVerified = false;
    var nodesLength = nodes.length, combinatorNodesLength = combinatorNodes.length;
    if (nodesLength === combinatorNodesLength) {
        nodesVerified = nodes.every(function(node, index) {
            var combinatorNode = combinatorNodes[index], nodeVerified = verifyNode(node, combinatorNode, context);
            if (nodeVerified) {
                return true;
            }
        });
    }
    return nodesVerified;
}
function verifyTerminalNode(terminalNode, combinatorTerminalNode, context) {
    var terminalNodeVerified = false;
    var matches = terminalNode.match(combinatorTerminalNode);
    if (matches) {
        terminalNodeVerified = true;
    }
    return terminalNodeVerified;
}
function verifyNonTerminalNode(nonTerminalNode, combinatorNonTerminalNode, context) {
    var nonTerminalNodeVerified = false;
    var ruleName = nonTerminalNode.getRuleName(), combinatorRuleName = combinatorNonTerminalNode.getRuleName(); ///
    if (ruleName === combinatorRuleName) {
        switch(ruleName){
            case _ruleNames.ARGUMENT_RULE_NAME:
                {
                    var argumentNode = nonTerminalNode, combinatorArgumentNode = combinatorNonTerminalNode, argumentNodeVerified = verifyArgumentNode(argumentNode, combinatorArgumentNode, context);
                    nonTerminalNodeVerified = argumentNodeVerified; ///
                    break;
                }
            case _ruleNames.META_ARGUMENT_RULE_NAME:
                {
                    var metaArgumentNode = nonTerminalNode, combinatorMetaargumentNode = combinatorNonTerminalNode, metaArgumentNodeVerified = verifyMetaargumentNode(metaArgumentNode, combinatorMetaargumentNode, context);
                    nonTerminalNodeVerified = metaArgumentNodeVerified; ///
                    break;
                }
            default:
                {
                    var childNodes = nonTerminalNode.getChildNodes(), combinatorChildNodes = combinatorNonTerminalNode.getChildNodes(), nodes = childNodes, combinatorNodes = combinatorChildNodes, nodesVerified = verifyNodes(nodes, combinatorNodes, context);
                    nonTerminalNodeVerified = nodesVerified; ///
                    break;
                }
        }
    }
    return nonTerminalNodeVerified;
}
function verifyArgumentNode(argumentNode, combinatorArgumentNode, context) {
    var argumentNodeVerified = false;
    var termNode = termNodeQuery(argumentNode);
    if (termNode === null) {
        var argumentString = (0, _string.nodeAsString)(argumentNode);
        context.error("The ".concat(argumentString, " argument should be a term, not a type"));
    } else {
        var types = [], termVerified = (0, _term.default)(termNode, types, context);
        if (termVerified) {
            var firstType = (0, _array.first)(types), termType = firstType, typeNode = typeNodeQuery(combinatorArgumentNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), type = typeName === _typeNames.OBJECT_TYPE_NAME ? _type1.objectType : context.findTypeByTypeName(typeName), statementTypeEqualToOrSubTypeOfType = termType.isEqualToOrSubTypeOf(type);
            if (statementTypeEqualToOrSubTypeOfType) {
                argumentNodeVerified = true;
            }
        }
    }
    return argumentNodeVerified;
}
function verifyMetaargumentNode(metaArgumentNode, combinatorMetaargumentNode, context) {
    var metaArgumentNodeVerified = false;
    var statementNode = statementNodeQuery(metaArgumentNode);
    if (statementNode === null) {
        var metaArgumentString = (0, _string.nodeAsString)(metaArgumentNode);
        context.error("The '".concat(metaArgumentString, "' meta-argument should be a statement, not a meta-type."));
    } else {
        var derived = false, assertions = null, statementVerified = verifyStatement(statementNode, assertions, derived, context);
        if (statementVerified) {
            var combinatorMetaTYpeNode = metaTypeNodeQuery(combinatorMetaargumentNode);
            if (combinatorMetaTYpeNode !== null) {
                var terminalNode = combinatorMetaTYpeNode, terminalNodeContent = terminalNode.getContent(), terminalNodeContentStatementMetaType = terminalNodeContent === _metaTypes.STATEMENT_META_TYPE;
                metaArgumentNodeVerified = terminalNodeContentStatementMetaType; ///
            }
            if (!metaArgumentNodeVerified) {
                var combinatorMetaargumentString = (0, _string.nodeAsString)(combinatorMetaargumentNode);
                context.error("The '".concat(combinatorMetaargumentString, "' combinator meta-argument should be the 'Statement' meta-type."));
            }
        }
    }
    return metaArgumentNodeVerified;
}
function equalitiesFromProofSteps(proofSteps) {
    var start = -_constants.MAXIMUM_INDEXES_LENGTH; ///
    proofSteps = proofSteps.slice(start); ///
    var equalities = proofSteps.reduce(function(equalities, proofStep, index) {
        var equality = _equality.default.fromProofStep(proofStep);
        if (equality !== null) {
            equalities.push(equality);
        }
        return equalities;
    }, []);
    return equalities;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRXF1YWxpdHkgZnJvbSBcIi4uL2VxdWFsaXR5XCI7XG5pbXBvcnQgdmVyaWZ5VGVybSBmcm9tIFwiLi4vdmVyaWZ5L3Rlcm1cIjtcbmltcG9ydCBlcXVhbGl0eUNvbWJpbmF0b3IgZnJvbSBcIi4uL29jbWJpbmF0b3IvZXF1YWxpdHlcIjtcbmltcG9ydCBicmFja2V0ZWRDb21iaW5hdG9yIGZyb20gXCIuLi9vY21iaW5hdG9yL2JyYWNrZXRlZFwiO1xuaW1wb3J0IHZlcmlmeVR5cGVBc3NlcnRpb24gZnJvbSBcIi4uL3ZlcmlmeS9hc3NlcnRpb24vdHlwZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG9iamVjdFR5cGUgfSBmcm9tIFwiLi4vdHlwZVwiO1xuaW1wb3J0IHsgbm9kZUFzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9zdHJpbmdcIjtcbmltcG9ydCB7IE9CSkVDVF9UWVBFX05BTUUgfSBmcm9tIFwiLi4vdHlwZU5hbWVzXCI7XG5pbXBvcnQgeyBTVEFURU1FTlRfTUVUQV9UWVBFIH0gZnJvbSBcIi4uL21ldGFUeXBlc1wiO1xuaW1wb3J0IHsgTUFYSU1VTV9JTkRFWEVTX0xFTkdUSCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IG5vZGVRdWVyeSwgdHlwZU5hbWVGcm9tVHlwZU5vZGUgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL3F1ZXJ5XCI7XG5pbXBvcnQgeyBBUkdVTUVOVF9SVUxFX05BTUUsIE1FVEFfQVJHVU1FTlRfUlVMRV9OQU1FIH0gZnJvbSBcIi4uL3J1bGVOYW1lc1wiO1xuXG5jb25zdCB0ZXJtTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL2FyZ3VtZW50L3Rlcm0hXCIpLFxuICAgICAgdHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9hcmd1bWVudC90eXBlIVwiKSxcbiAgICAgIG1ldGFUeXBlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL21ldGFBcmd1bWVudC9tZXRhVHlwZSEvQG1ldGEtdHlwZVwiKSxcbiAgICAgIHN0YXRlbWVudE5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9tZXRhQXJndW1lbnQvc3RhdGVtZW50IVwiKSxcbiAgICAgIHR5cGVBc3NlcnRpb25Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvc3RhdGVtZW50L3R5cGVBc3NlcnRpb24hXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzZXJ0aW9ucywgZGVyaXZlZCwgY29udGV4dCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb250ZXh0LmJlZ2luKHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICghc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHkgPSB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5KHN0YXRlbWVudE5vZGUsIGRlcml2ZWQsIGNvbnRleHQpO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWQgPSBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHk7ICAvL1xuICB9XG5cbiAgaWYgKCFzdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgIGNvbnN0IHN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uID0gdmVyaWZ5U3RhdGVtZW50QXNUeXBlQXNzZXJ0aW9uKHN0YXRlbWVudE5vZGUsIGFzc2VydGlvbnMsIGNvbnRleHQpO1xuXG4gICAgc3RhdGVtZW50VmVyaWZpZWQgPSBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbjsgLy8vXG4gIH1cblxuICBpZiAoIXN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnMgPSB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcnMoc3RhdGVtZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgICBzdGF0ZW1lbnRWZXJpZmllZCA9IHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzOyAgLy8vXG4gIH1cblxuICBzdGF0ZW1lbnRWZXJpZmllZCA/XG4gICAgY29udGV4dC5jb21wbGV0ZShzdGF0ZW1lbnROb2RlKSA6XG4gICAgICBjb250ZXh0LmhhbHQoc3RhdGVtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHN0YXRlbWVudFZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5KHN0YXRlbWVudE5vZGUsIGRlcml2ZWQsIGNvbnRleHQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eSA9IGZhbHNlO1xuXG4gIGNvbnN0IGNvbWJpbmF0b3IgPSBlcXVhbGl0eUNvbWJpbmF0b3IsICAvLy9cbiAgICAgICAgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciA9IHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yKHN0YXRlbWVudE5vZGUsIGNvbWJpbmF0b3IsIGNvbnRleHQpO1xuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yKSB7XG4gICAgc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5ID0gdHJ1ZTtcblxuICAgIGlmIChkZXJpdmVkKSB7XG4gICAgICBjb25zdCBlcXVhbGl0eSA9IEVxdWFsaXR5LmZyb21TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUpLFxuICAgICAgICAgICAgcHJvb2ZTdGVwcyA9IGNvbnRleHQuZ2V0UHJvb2ZTdGVwcygpLFxuICAgICAgICAgICAgZXF1YWxpdGllcyA9IGVxdWFsaXRpZXNGcm9tUHJvb2ZTdGVwcyhwcm9vZlN0ZXBzKSxcbiAgICAgICAgICAgIGVxdWFsaXR5RXF1YXRlcyA9IGVxdWFsaXR5LmVxdWF0ZShlcXVhbGl0aWVzKTtcblxuICAgICAgc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5ID0gZXF1YWxpdHlFcXVhdGVzOyAvLy9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5O1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVBc3NlcnRpb24oc3RhdGVtZW50Tm9kZSwgYXNzZXJ0aW9ucywgY29udGV4dCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24gPSBmYWxzZTtcblxuICBjb25zdCB0eXBlQXNzZXJ0aW9uTm9kZSA9IHR5cGVBc3NlcnRpb25Ob2RlUXVlcnkoc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGVBc3NlcnRpb25Ob2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgdHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgYXNzZXJ0aW9ucywgY29udGV4dCk7XG5cbiAgICBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb25WZXJpZmllZDsgLy8vXG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb247XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9ycyhzdGF0ZW1lbnROb2RlLCBjb250ZXh0KSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycyA9IGZhbHNlO1xuXG4gIGxldCBjb21iaW5hdG9ycyA9IGNvbnRleHQuZ2V0Q29tYmluYXRvcnMoKTtcblxuICBjb21iaW5hdG9ycyA9IFsgLy8vXG4gICAgYnJhY2tldGVkQ29tYmluYXRvcixcbiAgICAuLi5jb21iaW5hdG9yc1xuICBdO1xuXG4gIGNvbnN0IGNvbWJpbmF0b3IgPSBjb21iaW5hdG9ycy5maW5kKChjb21iaW5hdG9yKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciA9IHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yKHN0YXRlbWVudE5vZGUsIGNvbWJpbmF0b3IsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkgfHwgbnVsbDtcblxuICBpZiAoY29tYmluYXRvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycztcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3Ioc3RhdGVtZW50Tm9kZSwgY29tYmluYXRvciwgY29udGV4dCkge1xuICBjb25zdCBjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSA9IGNvbWJpbmF0b3IuZ2V0U3RhdGVtZW50Tm9kZSgpLFxuICAgICAgICBub2RlID0gc3RhdGVtZW50Tm9kZSwgIC8vL1xuICAgICAgICBjb21iaW5hdG9yTm9kZSA9IGNvbWJpbmF0b3JTdGF0ZW1lbnROb2RlLCAvLy9cbiAgICAgICAgbm9kZVZlcmlmaWVkID0gdmVyaWZ5Tm9kZShub2RlLCBjb21iaW5hdG9yTm9kZSwgY29udGV4dCksXG4gICAgICAgIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSBub2RlVmVyaWZpZWQ7ICAvLy9cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcjtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5Tm9kZShub2RlLCBjb21iaW5hdG9yTm9kZSwgY29udGV4dCkge1xuICBsZXQgbm9kZVZlcmlmaWVkO1xuXG4gIGNvbnN0IG5vZGVUZXJtaW5hbE5vZGUgPSBub2RlLmlzVGVybWluYWxOb2RlKCksXG4gICAgICAgIGNvbWJpbmF0b3JOb2RlVGVybWluYWxOb2RlID0gY29tYmluYXRvck5vZGUuaXNUZXJtaW5hbE5vZGUoKTtcblxuICBpZiAobm9kZVRlcm1pbmFsTm9kZSA9PT0gY29tYmluYXRvck5vZGVUZXJtaW5hbE5vZGUpIHtcbiAgICBpZiAobm9kZVRlcm1pbmFsTm9kZSkge1xuICAgICAgY29uc3QgdGVybWluYWxOb2RlID0gbm9kZSwgIC8vL1xuICAgICAgICAgICAgY29tYmluYXRvclRlcm1pbmFsTm9kZSA9IGNvbWJpbmF0b3JOb2RlLCAgLy8vXG4gICAgICAgICAgICB0ZXJtaW5hbE5vZGVWZXJpZmllZCA9IHZlcmlmeVRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIGNvbWJpbmF0b3JUZXJtaW5hbE5vZGUsIGNvbnRleHQpO1xuXG4gICAgICBub2RlVmVyaWZpZWQgPSB0ZXJtaW5hbE5vZGVWZXJpZmllZDsgIC8vL1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub25UZXJtaW5hbE5vZGUgPSBub2RlLCAvLy9cbiAgICAgICAgICAgIGNvbWJpbmF0b3JOb25UZXJtaW5hbE5vZGUgPSBjb21iaW5hdG9yTm9kZSwgIC8vL1xuICAgICAgICAgICAgbm9uVGVybWluYWxOb2RlVmVyaWZpZWQgPSB2ZXJpZnlOb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlLCBjb21iaW5hdG9yTm9uVGVybWluYWxOb2RlLCBjb250ZXh0KTtcblxuICAgICAgbm9kZVZlcmlmaWVkID0gbm9uVGVybWluYWxOb2RlVmVyaWZpZWQ7IC8vL1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeU5vZGVzKG5vZGVzLCBjb21iaW5hdG9yTm9kZXMsIGNvbnRleHQpIHtcbiAgbGV0IG5vZGVzVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgY29tYmluYXRvck5vZGVzTGVuZ3RoID0gY29tYmluYXRvck5vZGVzLmxlbmd0aDtcblxuICBpZiAobm9kZXNMZW5ndGggPT09IGNvbWJpbmF0b3JOb2Rlc0xlbmd0aCkge1xuICAgIG5vZGVzVmVyaWZpZWQgPSBub2Rlcy5ldmVyeSgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNvbWJpbmF0b3JOb2RlID0gY29tYmluYXRvck5vZGVzW2luZGV4XSxcbiAgICAgICAgICAgIG5vZGVWZXJpZmllZCA9IHZlcmlmeU5vZGUobm9kZSwgY29tYmluYXRvck5vZGUsIGNvbnRleHQpO1xuXG4gICAgICBpZiAobm9kZVZlcmlmaWVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVRlcm1pbmFsTm9kZSh0ZXJtaW5hbE5vZGUsIGNvbWJpbmF0b3JUZXJtaW5hbE5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHRlcm1pbmFsTm9kZVZlcmlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHRlcm1pbmFsTm9kZS5tYXRjaChjb21iaW5hdG9yVGVybWluYWxOb2RlKTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIHRlcm1pbmFsTm9kZVZlcmlmaWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0ZXJtaW5hbE5vZGVWZXJpZmllZDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5Tm9uVGVybWluYWxOb2RlKG5vblRlcm1pbmFsTm9kZSwgY29tYmluYXRvck5vblRlcm1pbmFsTm9kZSwgY29udGV4dCkge1xuICBsZXQgbm9uVGVybWluYWxOb2RlVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBydWxlTmFtZSA9IG5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpLCAvLy9cbiAgICAgICAgY29tYmluYXRvclJ1bGVOYW1lID0gY29tYmluYXRvck5vblRlcm1pbmFsTm9kZS5nZXRSdWxlTmFtZSgpOyAvLy9cblxuICBpZiAocnVsZU5hbWUgPT09IGNvbWJpbmF0b3JSdWxlTmFtZSkge1xuICAgIHN3aXRjaCAocnVsZU5hbWUpIHtcbiAgICAgIGNhc2UgQVJHVU1FTlRfUlVMRV9OQU1FOiB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50Tm9kZSA9IG5vblRlcm1pbmFsTm9kZSwgLy8vXG4gICAgICAgICAgICAgIGNvbWJpbmF0b3JBcmd1bWVudE5vZGUgPSBjb21iaW5hdG9yTm9uVGVybWluYWxOb2RlLCAvLy9cbiAgICAgICAgICAgICAgYXJndW1lbnROb2RlVmVyaWZpZWQgPSB2ZXJpZnlBcmd1bWVudE5vZGUoYXJndW1lbnROb2RlLCBjb21iaW5hdG9yQXJndW1lbnROb2RlLCBjb250ZXh0KTtcblxuICAgICAgICBub25UZXJtaW5hbE5vZGVWZXJpZmllZCA9IGFyZ3VtZW50Tm9kZVZlcmlmaWVkOyAvLy9cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSBNRVRBX0FSR1VNRU5UX1JVTEVfTkFNRToge1xuICAgICAgICBjb25zdCBtZXRhQXJndW1lbnROb2RlID0gbm9uVGVybWluYWxOb2RlLCAvLy9cbiAgICAgICAgICAgICAgY29tYmluYXRvck1ldGFhcmd1bWVudE5vZGUgPSBjb21iaW5hdG9yTm9uVGVybWluYWxOb2RlLCAvLy9cbiAgICAgICAgICAgICAgbWV0YUFyZ3VtZW50Tm9kZVZlcmlmaWVkID0gdmVyaWZ5TWV0YWFyZ3VtZW50Tm9kZShtZXRhQXJndW1lbnROb2RlLCBjb21iaW5hdG9yTWV0YWFyZ3VtZW50Tm9kZSwgY29udGV4dCk7XG5cbiAgICAgICAgbm9uVGVybWluYWxOb2RlVmVyaWZpZWQgPSBtZXRhQXJndW1lbnROb2RlVmVyaWZpZWQ7IC8vL1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBub25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICBjb21iaW5hdG9yQ2hpbGROb2RlcyA9IGNvbWJpbmF0b3JOb25UZXJtaW5hbE5vZGUuZ2V0Q2hpbGROb2RlcygpLFxuICAgICAgICAgICAgICBub2RlcyA9IGNoaWxkTm9kZXMsIC8vL1xuICAgICAgICAgICAgICBjb21iaW5hdG9yTm9kZXMgPSBjb21iaW5hdG9yQ2hpbGROb2RlcywgLy8vXG4gICAgICAgICAgICAgIG5vZGVzVmVyaWZpZWQgPSB2ZXJpZnlOb2Rlcyhub2RlcywgY29tYmluYXRvck5vZGVzLCBjb250ZXh0KTtcblxuICAgICAgICBub25UZXJtaW5hbE5vZGVWZXJpZmllZCA9IG5vZGVzVmVyaWZpZWQ7IC8vL1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub25UZXJtaW5hbE5vZGVWZXJpZmllZDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5QXJndW1lbnROb2RlKGFyZ3VtZW50Tm9kZSwgY29tYmluYXRvckFyZ3VtZW50Tm9kZSwgY29udGV4dCkge1xuICBsZXQgYXJndW1lbnROb2RlVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCB0ZXJtTm9kZSA9IHRlcm1Ob2RlUXVlcnkoYXJndW1lbnROb2RlKTtcblxuICBpZiAodGVybU5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBhcmd1bWVudFN0cmluZyA9IG5vZGVBc1N0cmluZyhhcmd1bWVudE5vZGUpO1xuXG4gICAgY29udGV4dC5lcnJvcihgVGhlICR7YXJndW1lbnRTdHJpbmd9IGFyZ3VtZW50IHNob3VsZCBiZSBhIHRlcm0sIG5vdCBhIHR5cGVgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0eXBlcyA9IFtdLFxuICAgICAgICAgIHRlcm1WZXJpZmllZCA9IHZlcmlmeVRlcm0odGVybU5vZGUsIHR5cGVzLCBjb250ZXh0KTtcblxuICAgIGlmICh0ZXJtVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICAgIHRlcm1UeXBlID0gZmlyc3RUeXBlLCAvLy9cbiAgICAgICAgICAgIHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeShjb21iaW5hdG9yQXJndW1lbnROb2RlKSxcbiAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICAgICAgdHlwZSA9ICh0eXBlTmFtZSA9PT0gT0JKRUNUX1RZUEVfTkFNRSkgP1xuICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VHlwZSA6ICAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maW5kVHlwZUJ5VHlwZU5hbWUodHlwZU5hbWUpLFxuICAgICAgICAgICAgc3RhdGVtZW50VHlwZUVxdWFsVG9PclN1YlR5cGVPZlR5cGUgPSB0ZXJtVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih0eXBlKTtcblxuICAgICAgaWYgKHN0YXRlbWVudFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZUeXBlKSB7XG4gICAgICAgIGFyZ3VtZW50Tm9kZVZlcmlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJndW1lbnROb2RlVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeU1ldGFhcmd1bWVudE5vZGUobWV0YUFyZ3VtZW50Tm9kZSwgY29tYmluYXRvck1ldGFhcmd1bWVudE5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IG1ldGFBcmd1bWVudE5vZGVWZXJpZmllZCA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudE5vZGUgPSBzdGF0ZW1lbnROb2RlUXVlcnkobWV0YUFyZ3VtZW50Tm9kZSk7XG5cbiAgaWYgKHN0YXRlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBtZXRhQXJndW1lbnRTdHJpbmcgPSBub2RlQXNTdHJpbmcobWV0YUFyZ3VtZW50Tm9kZSk7XG5cbiAgICBjb250ZXh0LmVycm9yKGBUaGUgJyR7bWV0YUFyZ3VtZW50U3RyaW5nfScgbWV0YS1hcmd1bWVudCBzaG91bGQgYmUgYSBzdGF0ZW1lbnQsIG5vdCBhIG1ldGEtdHlwZS5gKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZXJpdmVkID0gZmFsc2UsXG4gICAgICAgICAgYXNzZXJ0aW9ucyA9IG51bGwsXG4gICAgICAgICAgc3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzZXJ0aW9ucywgZGVyaXZlZCwgY29udGV4dCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IGNvbWJpbmF0b3JNZXRhVFlwZU5vZGUgPSBtZXRhVHlwZU5vZGVRdWVyeShjb21iaW5hdG9yTWV0YWFyZ3VtZW50Tm9kZSk7XG5cbiAgICAgIGlmIChjb21iaW5hdG9yTWV0YVRZcGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmFsTm9kZSA9IGNvbWJpbmF0b3JNZXRhVFlwZU5vZGUsICAvLy9cbiAgICAgICAgICAgICAgdGVybWluYWxOb2RlQ29udGVudCA9IHRlcm1pbmFsTm9kZS5nZXRDb250ZW50KCksXG4gICAgICAgICAgICAgIHRlcm1pbmFsTm9kZUNvbnRlbnRTdGF0ZW1lbnRNZXRhVHlwZSA9ICh0ZXJtaW5hbE5vZGVDb250ZW50ID09PSBTVEFURU1FTlRfTUVUQV9UWVBFKTtcblxuICAgICAgICBtZXRhQXJndW1lbnROb2RlVmVyaWZpZWQgPSB0ZXJtaW5hbE5vZGVDb250ZW50U3RhdGVtZW50TWV0YVR5cGU7ICAvLy9cbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXRhQXJndW1lbnROb2RlVmVyaWZpZWQpIHtcbiAgICAgICAgY29uc3QgY29tYmluYXRvck1ldGFhcmd1bWVudFN0cmluZyA9IG5vZGVBc1N0cmluZyhjb21iaW5hdG9yTWV0YWFyZ3VtZW50Tm9kZSk7XG5cbiAgICAgICAgY29udGV4dC5lcnJvcihgVGhlICcke2NvbWJpbmF0b3JNZXRhYXJndW1lbnRTdHJpbmd9JyBjb21iaW5hdG9yIG1ldGEtYXJndW1lbnQgc2hvdWxkIGJlIHRoZSAnU3RhdGVtZW50JyBtZXRhLXR5cGUuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ldGFBcmd1bWVudE5vZGVWZXJpZmllZDtcbn1cblxuZnVuY3Rpb24gZXF1YWxpdGllc0Zyb21Qcm9vZlN0ZXBzKHByb29mU3RlcHMpIHtcbiAgY29uc3Qgc3RhcnQgPSAtTUFYSU1VTV9JTkRFWEVTX0xFTkdUSDsgIC8vL1xuXG4gIHByb29mU3RlcHMgPSBwcm9vZlN0ZXBzLnNsaWNlKHN0YXJ0KTsgLy8vXG5cbiAgY29uc3QgZXF1YWxpdGllcyA9IHByb29mU3RlcHMucmVkdWNlKChlcXVhbGl0aWVzLCBwcm9vZlN0ZXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgZXF1YWxpdHkgPSBFcXVhbGl0eS5mcm9tUHJvb2ZTdGVwKHByb29mU3RlcCk7XG5cbiAgICBpZiAoZXF1YWxpdHkgIT09IG51bGwpIHtcbiAgICAgIGVxdWFsaXRpZXMucHVzaChlcXVhbGl0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVxdWFsaXRpZXM7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gZXF1YWxpdGllcztcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlTdGF0ZW1lbnQiLCJ0ZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwidHlwZU5vZGVRdWVyeSIsIm1ldGFUeXBlTm9kZVF1ZXJ5Iiwic3RhdGVtZW50Tm9kZVF1ZXJ5IiwidHlwZUFzc2VydGlvbk5vZGVRdWVyeSIsInN0YXRlbWVudE5vZGUiLCJhc3NlcnRpb25zIiwiZGVyaXZlZCIsImNvbnRleHQiLCJzdGF0ZW1lbnRWZXJpZmllZCIsImJlZ2luIiwic3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5IiwidmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eSIsInN0YXRlbWVudFZlcmlmaWVkQXNUeXBlQXNzZXJ0aW9uIiwidmVyaWZ5U3RhdGVtZW50QXNUeXBlQXNzZXJ0aW9uIiwic3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnMiLCJ2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcnMiLCJjb21wbGV0ZSIsImhhbHQiLCJjb21iaW5hdG9yIiwiZXF1YWxpdHlDb21iaW5hdG9yIiwic3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvciIsInZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9yIiwiZXF1YWxpdHkiLCJFcXVhbGl0eSIsImZyb21TdGF0ZW1lbnROb2RlIiwicHJvb2ZTdGVwcyIsImdldFByb29mU3RlcHMiLCJlcXVhbGl0aWVzIiwiZXF1YWxpdGllc0Zyb21Qcm9vZlN0ZXBzIiwiZXF1YWxpdHlFcXVhdGVzIiwiZXF1YXRlIiwidHlwZUFzc2VydGlvbk5vZGUiLCJ0eXBlQXNzZXJ0aW9uVmVyaWZpZWQiLCJ2ZXJpZnlUeXBlQXNzZXJ0aW9uIiwiY29tYmluYXRvcnMiLCJnZXRDb21iaW5hdG9ycyIsImJyYWNrZXRlZENvbWJpbmF0b3IiLCJmaW5kIiwiY29tYmluYXRvclN0YXRlbWVudE5vZGUiLCJnZXRTdGF0ZW1lbnROb2RlIiwibm9kZSIsImNvbWJpbmF0b3JOb2RlIiwibm9kZVZlcmlmaWVkIiwidmVyaWZ5Tm9kZSIsIm5vZGVUZXJtaW5hbE5vZGUiLCJpc1Rlcm1pbmFsTm9kZSIsImNvbWJpbmF0b3JOb2RlVGVybWluYWxOb2RlIiwidGVybWluYWxOb2RlIiwiY29tYmluYXRvclRlcm1pbmFsTm9kZSIsInRlcm1pbmFsTm9kZVZlcmlmaWVkIiwidmVyaWZ5VGVybWluYWxOb2RlIiwibm9uVGVybWluYWxOb2RlIiwiY29tYmluYXRvck5vblRlcm1pbmFsTm9kZSIsIm5vblRlcm1pbmFsTm9kZVZlcmlmaWVkIiwidmVyaWZ5Tm9uVGVybWluYWxOb2RlIiwidmVyaWZ5Tm9kZXMiLCJub2RlcyIsImNvbWJpbmF0b3JOb2RlcyIsIm5vZGVzVmVyaWZpZWQiLCJub2Rlc0xlbmd0aCIsImxlbmd0aCIsImNvbWJpbmF0b3JOb2Rlc0xlbmd0aCIsImV2ZXJ5IiwiaW5kZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJydWxlTmFtZSIsImdldFJ1bGVOYW1lIiwiY29tYmluYXRvclJ1bGVOYW1lIiwiQVJHVU1FTlRfUlVMRV9OQU1FIiwiYXJndW1lbnROb2RlIiwiY29tYmluYXRvckFyZ3VtZW50Tm9kZSIsImFyZ3VtZW50Tm9kZVZlcmlmaWVkIiwidmVyaWZ5QXJndW1lbnROb2RlIiwiTUVUQV9BUkdVTUVOVF9SVUxFX05BTUUiLCJtZXRhQXJndW1lbnROb2RlIiwiY29tYmluYXRvck1ldGFhcmd1bWVudE5vZGUiLCJtZXRhQXJndW1lbnROb2RlVmVyaWZpZWQiLCJ2ZXJpZnlNZXRhYXJndW1lbnROb2RlIiwiY2hpbGROb2RlcyIsImdldENoaWxkTm9kZXMiLCJjb21iaW5hdG9yQ2hpbGROb2RlcyIsInRlcm1Ob2RlIiwiYXJndW1lbnRTdHJpbmciLCJub2RlQXNTdHJpbmciLCJlcnJvciIsInR5cGVzIiwidGVybVZlcmlmaWVkIiwidmVyaWZ5VGVybSIsImZpcnN0VHlwZSIsImZpcnN0IiwidGVybVR5cGUiLCJ0eXBlTm9kZSIsInR5cGVOYW1lIiwidHlwZU5hbWVGcm9tVHlwZU5vZGUiLCJ0eXBlIiwiT0JKRUNUX1RZUEVfTkFNRSIsIm9iamVjdFR5cGUiLCJmaW5kVHlwZUJ5VHlwZU5hbWUiLCJzdGF0ZW1lbnRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVHlwZSIsImlzRXF1YWxUb09yU3ViVHlwZU9mIiwibWV0YUFyZ3VtZW50U3RyaW5nIiwiY29tYmluYXRvck1ldGFUWXBlTm9kZSIsInRlcm1pbmFsTm9kZUNvbnRlbnQiLCJnZXRDb250ZW50IiwidGVybWluYWxOb2RlQ29udGVudFN0YXRlbWVudE1ldGFUeXBlIiwiU1RBVEVNRU5UX01FVEFfVFlQRSIsImNvbWJpbmF0b3JNZXRhYXJndW1lbnRTdHJpbmciLCJzdGFydCIsIk1BWElNVU1fSU5ERVhFU19MRU5HVEgiLCJzbGljZSIsInJlZHVjZSIsInByb29mU3RlcCIsImZyb21Qcm9vZlN0ZXAiLCJwdXNoIl0sIm1hcHBpbmdzIjoi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