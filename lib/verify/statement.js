"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    verifyStatementAgainstCombinator: function() {
        return verifyStatementAgainstCombinator;
    },
    verifyStatementAgainstCombinators: function() {
        return verifyStatementAgainstCombinators;
    }
});
var _equality = /*#__PURE__*/ _interop_require_default(require("../equality"));
var _term = /*#__PURE__*/ _interop_require_default(require("../verify/term"));
var _equality1 = /*#__PURE__*/ _interop_require_default(require("../ocmbinator/equality"));
var _bracketed = /*#__PURE__*/ _interop_require_default(require("../ocmbinator/bracketed"));
var _typeInference = /*#__PURE__*/ _interop_require_default(require("../verify/typeInference"));
var _type = /*#__PURE__*/ _interop_require_default(require("../verify/assertion/type"));
var _statement = /*#__PURE__*/ _interop_require_default(require("../verifier/nodes/statement"));
var _query = require("../utilities/query");
var _array = require("../utilities/array");
function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var leftTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[0]/term!"), rightTermNodeQuery = (0, _query.nodeQuery)("/statement/argument[1]/term!"), typeInferenceNodeQuery = (0, _query.nodeQuery)("/statement/typeInference!"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatement(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerified;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement..."), statementNode);
    var verifyStatementFunctions = [
        verifyStatementAsEquality,
        verifyStatementAsTypeInference,
        verifyStatementAsTypeAssertion,
        verifyStatementAgainstCombinators
    ];
    statementVerified = verifyStatementFunctions.some(function(verifyStatementFunction) {
        var statementVerified = verifyStatementFunction(statementNode, assignments, derived, context, verifyAhead);
        if (statementVerified) {
            return true;
        }
    });
    if (statementVerified) {
        context.debug("...verified the '".concat(statementString, "' statement."), statementNode);
    }
    return statementVerified;
}
Object.assign(verifyStatement, {
    statementNodesVerifier: _statement.default
});
var _default = verifyStatement;
function verifyStatementAgainstCombinators(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAgainstCombinators;
    var combinators = context.getCombinators();
    combinators = [
        _bracketed.default
    ].concat(_to_consumable_array(combinators));
    statementVerifiedAgainstCombinators = combinators.some(function(combinator) {
        var statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead);
        if (statementVerifiedAgainstCombinator) {
            return true;
        }
    });
    return statementVerifiedAgainstCombinators;
}
function verifyStatementAgainstCombinator(statementNode, combinator, context, verifyAhead) {
    var statementVerifiedAgainstCombinator;
    var statementString = context.nodeAsString(statementNode), combinatorString = combinator.getString();
    context.trace("Verifying the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator..."), statementNode);
    var combinatorStatementNode = combinator.getStatementNode(), nonTerminalNodeA = statementNode, nonTerminalNodeB = combinatorStatementNode, nonTerminalNodeVerified = _statement.default.verifyNonTerminalNode(nonTerminalNodeA, nonTerminalNodeB, context, verifyAhead);
    statementVerifiedAgainstCombinator = nonTerminalNodeVerified; ///
    if (statementVerifiedAgainstCombinator) {
        context.debug("...verified the '".concat(statementString, "' statement against the '").concat(combinatorString, "' combinator."), statementNode);
    }
    return statementVerifiedAgainstCombinator;
}
function verifyStatementAsTypeInference(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeInference = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a type inference..."), statementNode);
    var typeInferenceNode = typeInferenceNodeQuery(statementNode);
    if (typeInferenceNode !== null) {
        if (!derived) {
            var typeInferenceString = context.nodeAsString(typeInferenceNode);
            context.info("The '".concat(typeInferenceString, "' type inference can only be derived."), typeInferenceNode);
        } else {
            var typeInferenceVerified = (0, _typeInference.default)(typeInferenceNode, context, verifyAhead);
            statementVerifiedAsTypeInference = typeInferenceVerified; ///
        }
    }
    if (statementVerifiedAsTypeInference) {
        context.debug("...verified the '".concat(statementString, "' statement as a type inference."), statementNode);
    }
    return statementVerifiedAsTypeInference;
}
function verifyStatementAsTypeAssertion(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsTypeAssertion = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a type assertion..."), statementNode);
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var typeAssertionVerified = (0, _type.default)(typeAssertionNode, assignments, derived, context, verifyAhead);
        statementVerifiedAsTypeAssertion = typeAssertionVerified; ///
    }
    if (statementVerifiedAsTypeAssertion) {
        context.debug("...verified the '".concat(statementString, "' statement as a type assertion."), statementNode);
    }
    return statementVerifiedAsTypeAssertion;
}
function verifyStatementAsEquality(statementNode, assignments, derived, context, verifyAhead) {
    var statementVerifiedAsEquality;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as an equality..."), statementNode);
    var combinator = _equality1.default, statementVerifiedAgainstCombinator = verifyStatementAgainstCombinator(statementNode, combinator, context, function() {
        var verifiedAhead;
        var verifyStatementAsEqualityFunctions = [
            verifyStatementAsDerivedEquality,
            verifyStatementAsEqualTerms
        ];
        verifiedAhead = verifyStatementAsEqualityFunctions.some(function(verifyStatementAsEqualityFunction) {
            var statementVerified = verifyStatementAsEqualityFunction(statementNode, derived, context, verifyAhead);
            if (statementVerified) {
                return true;
            }
        });
        return verifiedAhead;
    });
    statementVerifiedAsEquality = statementVerifiedAgainstCombinator; ///
    if (statementVerifiedAsEquality) {
        context.debug("...verified the '".concat(statementString, "' statement as an equality."), statementNode);
    }
    return statementVerifiedAsEquality;
}
function verifyStatementAsDerivedEquality(statementNode, derived, context, verifyAhead) {
    var verifiedStatementAsDerivedEquality = false;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as a derived equality..."), statementNode);
    if (derived) {
        var equality = _equality.default.fromStatementNode(statementNode), equalities = context.getEqualities(), equalityVerified = equality.verify(equalities, context, verifyAhead);
        verifiedStatementAsDerivedEquality = equalityVerified; ///
    }
    if (verifiedStatementAsDerivedEquality) {
        context.debug("...verified the '".concat(statementString, "' statement as a derived equality."), statementNode);
    }
    return verifiedStatementAsDerivedEquality;
}
function verifyStatementAsEqualTerms(statementNode, derived, context, verifyAhead) {
    var statementVerifiedAsEqualTerms;
    var statementString = context.nodeAsString(statementNode);
    context.trace("Verifying the '".concat(statementString, "' statement as equal terms..."), statementNode);
    var types = [], leftTermNode = leftTermNodeQuery(statementNode), leftTermVerified = (0, _term.default)(leftTermNode, types, context, function() {
        var verifiedAhead;
        var rightTermNode = rightTermNodeQuery(statementNode), rightTermVerified = (0, _term.default)(rightTermNode, types, context, function() {
            var verifiedAhead = false;
            var firstType = (0, _array.first)(types), secondType = (0, _array.second)(types), leftType = firstType, rightType = secondType, leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType = leftType.isEqualToOrSubTypeOfOfSuperTypeOf(rightType);
            if (!leftTypeEqualToOrSubTypeOfOfSuperTypeOfRightType) {
                var leftTypeName = leftType.getName(), rightTypeName = rightType.getName(), leftTermString = context.nodeAsString(leftTermNode), rightTermString = context.nodeAsString(rightTermNode);
                context.info("The left '".concat(leftTermString, "' term's '").concat(leftTypeName, "' type is not equal to, a sub-type of nor a super-type of the right '").concat(rightTermString, "' term's '").concat(rightTypeName, "' type."), statementNode);
            } else {
                verifiedAhead = verifyAhead();
            }
            return verifiedAhead;
        });
        verifiedAhead = rightTermVerified; ///
        return verifiedAhead;
    });
    statementVerifiedAsEqualTerms = leftTermVerified; ///
    if (statementVerifiedAsEqualTerms) {
        context.trace("...verified the '".concat(statementString, "' statement as equal terms."), statementNode);
    }
    return statementVerifiedAsEqualTerms;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRXF1YWxpdHkgZnJvbSBcIi4uL2VxdWFsaXR5XCI7XG5pbXBvcnQgdmVyaWZ5VGVybSBmcm9tIFwiLi4vdmVyaWZ5L3Rlcm1cIjtcbmltcG9ydCBlcXVhbGl0eUNvbWJpbmF0b3IgZnJvbSBcIi4uL29jbWJpbmF0b3IvZXF1YWxpdHlcIjtcbmltcG9ydCBicmFja2V0ZWRDb21iaW5hdG9yIGZyb20gXCIuLi9vY21iaW5hdG9yL2JyYWNrZXRlZFwiO1xuaW1wb3J0IHZlcmlmeVR5cGVJbmZlcmVuY2UgZnJvbSBcIi4uL3ZlcmlmeS90eXBlSW5mZXJlbmNlXCI7XG5pbXBvcnQgdmVyaWZ5VHlwZUFzc2VydGlvbiBmcm9tIFwiLi4vdmVyaWZ5L2Fzc2VydGlvbi90eXBlXCI7XG5pbXBvcnQgc3RhdGVtZW50Tm9kZXNWZXJpZmllciBmcm9tIFwiLi4vdmVyaWZpZXIvbm9kZXMvc3RhdGVtZW50XCI7XG5cbmltcG9ydCB7IG5vZGVRdWVyeSB9IGZyb20gXCIuLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IGZpcnN0LCBzZWNvbmQgfSBmcm9tIFwiLi4vdXRpbGl0aWVzL2FycmF5XCI7XG5cbmNvbnN0IGxlZnRUZXJtTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC9hcmd1bWVudFswXS90ZXJtIVwiKSxcbiAgICAgIHJpZ2h0VGVybU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9zdGF0ZW1lbnQvYXJndW1lbnRbMV0vdGVybSFcIiksXG4gICAgICB0eXBlSW5mZXJlbmNlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC90eXBlSW5mZXJlbmNlIVwiKSxcbiAgICAgIHR5cGVBc3NlcnRpb25Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvc3RhdGVtZW50L3R5cGVBc3NlcnRpb24hXCIpO1xuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnQoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZDtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudC4uLmAsIHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnN0IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucyA9IFtcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5LFxuICAgIHZlcmlmeVN0YXRlbWVudEFzVHlwZUluZmVyZW5jZSxcbiAgICB2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVBc3NlcnRpb24sXG4gICAgdmVyaWZ5U3RhdGVtZW50QWdhaW5zdENvbWJpbmF0b3JzXG4gIF07XG5cbiAgc3RhdGVtZW50VmVyaWZpZWQgPSB2ZXJpZnlTdGF0ZW1lbnRGdW5jdGlvbnMuc29tZSgodmVyaWZ5U3RhdGVtZW50RnVuY3Rpb24pID0+IHtcbiAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEZ1bmN0aW9uKHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkKSB7XG4gICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudC5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZDtcbn1cblxuT2JqZWN0LmFzc2lnbih2ZXJpZnlTdGF0ZW1lbnQsIHtcbiAgc3RhdGVtZW50Tm9kZXNWZXJpZmllclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHZlcmlmeVN0YXRlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9ycyhzdGF0ZW1lbnROb2RlLCBhc3NpZ25tZW50cywgZGVyaXZlZCwgY29udGV4dCwgdmVyaWZ5QWhlYWQpIHtcbiAgbGV0IHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzO1xuXG4gIGxldCBjb21iaW5hdG9ycyA9IGNvbnRleHQuZ2V0Q29tYmluYXRvcnMoKTtcblxuICBjb21iaW5hdG9ycyA9IFsgLy8vXG4gICAgYnJhY2tldGVkQ29tYmluYXRvcixcbiAgICAuLi5jb21iaW5hdG9yc1xuICBdO1xuXG4gIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3JzID0gY29tYmluYXRvcnMuc29tZSgoY29tYmluYXRvcikgPT4ge1xuICAgIGNvbnN0IHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcihzdGF0ZW1lbnROb2RlLCBjb21iaW5hdG9yLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcihzdGF0ZW1lbnROb2RlLCBjb21iaW5hdG9yLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBZ2FpbnN0Q29tYmluYXRvcjtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgY29tYmluYXRvclN0cmluZyA9IGNvbWJpbmF0b3IuZ2V0U3RyaW5nKCk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYWdhaW5zdCB0aGUgJyR7Y29tYmluYXRvclN0cmluZ30nIGNvbWJpbmF0b3IuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCBjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSA9IGNvbWJpbmF0b3IuZ2V0U3RhdGVtZW50Tm9kZSgpLFxuICAgICAgICBub25UZXJtaW5hbE5vZGVBID0gc3RhdGVtZW50Tm9kZSwgLy8vXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZUIgPSBjb21iaW5hdG9yU3RhdGVtZW50Tm9kZSwgLy8vXG4gICAgICAgIG5vblRlcm1pbmFsTm9kZVZlcmlmaWVkID0gc3RhdGVtZW50Tm9kZXNWZXJpZmllci52ZXJpZnlOb25UZXJtaW5hbE5vZGUobm9uVGVybWluYWxOb2RlQSwgbm9uVGVybWluYWxOb2RlQiwgY29udGV4dCwgdmVyaWZ5QWhlYWQpO1xuXG4gIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSBub25UZXJtaW5hbE5vZGVWZXJpZmllZDsgIC8vL1xuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yKSB7XG4gICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhZ2FpbnN0IHRoZSAnJHtjb21iaW5hdG9yU3RyaW5nfScgY29tYmluYXRvci5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVJbmZlcmVuY2Uoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZSA9IGZhbHNlO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IGNvbnRleHQubm9kZUFzU3RyaW5nKHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgdHlwZSBpbmZlcmVuY2UuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCB0eXBlSW5mZXJlbmNlTm9kZSA9IHR5cGVJbmZlcmVuY2VOb2RlUXVlcnkoc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKHR5cGVJbmZlcmVuY2VOb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCFkZXJpdmVkKSB7XG4gICAgICBjb25zdCB0eXBlSW5mZXJlbmNlU3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcodHlwZUluZmVyZW5jZU5vZGUpO1xuXG4gICAgICBjb250ZXh0LmluZm8oYFRoZSAnJHt0eXBlSW5mZXJlbmNlU3RyaW5nfScgdHlwZSBpbmZlcmVuY2UgY2FuIG9ubHkgYmUgZGVyaXZlZC5gLCB0eXBlSW5mZXJlbmNlTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGVJbmZlcmVuY2VWZXJpZmllZCA9IHZlcmlmeVR5cGVJbmZlcmVuY2UodHlwZUluZmVyZW5jZU5vZGUsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgICAgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVJbmZlcmVuY2UgPSB0eXBlSW5mZXJlbmNlVmVyaWZpZWQ7IC8vL1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZSkge1xuICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSB0eXBlIGluZmVyZW5jZS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUluZmVyZW5jZTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50QXNUeXBlQXNzZXJ0aW9uKHN0YXRlbWVudE5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24gPSBmYWxzZTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBjb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhIHR5cGUgYXNzZXJ0aW9uLi4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29uc3QgdHlwZUFzc2VydGlvbk5vZGUgPSB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICh0eXBlQXNzZXJ0aW9uTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZlcmlmeVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIGFzc2lnbm1lbnRzLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICBzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiA9IHR5cGVBc3NlcnRpb25WZXJpZmllZDsgLy8vXG4gIH1cblxuICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb24pIHtcbiAgICBjb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IGFzIGEgdHlwZSBhc3NlcnRpb24uYCwgc3RhdGVtZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50VmVyaWZpZWRBc1R5cGVBc3NlcnRpb247XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHkoc3RhdGVtZW50Tm9kZSwgYXNzaWdubWVudHMsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHk7XG5cbiAgY29uc3Qgc3RhdGVtZW50U3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcoc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYW4gZXF1YWxpdHkuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCBjb21iaW5hdG9yID0gZXF1YWxpdHlDb21iaW5hdG9yLCAgLy8vXG4gICAgICAgIHN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IgPSB2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvcihzdGF0ZW1lbnROb2RlLCBjb21iaW5hdG9yLCBjb250ZXh0LCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHZlcmlmaWVkQWhlYWQ7XG5cbiAgICAgICAgICBjb25zdCB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb25zID0gW1xuICAgICAgICAgICAgdmVyaWZ5U3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHksXG4gICAgICAgICAgICB2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsVGVybXNcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgdmVyaWZpZWRBaGVhZCA9IHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHlGdW5jdGlvbnMuc29tZSgodmVyaWZ5U3RhdGVtZW50QXNFcXVhbGl0eUZ1bmN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZW1lbnRWZXJpZmllZCA9IHZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHlGdW5jdGlvbihzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCk7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRWZXJpZmllZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB2ZXJpZmllZEFoZWFkO1xuICAgICAgICB9KTtcblxuICBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHkgPSBzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9yOyAvLy9cblxuICBpZiAoc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsaXR5KSB7XG4gICAgY29udGV4dC5kZWJ1ZyhgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBhbiBlcXVhbGl0eS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxpdHk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5KHN0YXRlbWVudE5vZGUsIGRlcml2ZWQsIGNvbnRleHQsIHZlcmlmeUFoZWFkKSB7XG4gIGxldCB2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5ID0gZmFsc2U7XG5cbiAgY29uc3Qgc3RhdGVtZW50U3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcoc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSBkZXJpdmVkIGVxdWFsaXR5Li4uYCwgc3RhdGVtZW50Tm9kZSk7XG5cbiAgaWYgKGRlcml2ZWQpIHtcbiAgICBjb25zdCBlcXVhbGl0eSA9IEVxdWFsaXR5LmZyb21TdGF0ZW1lbnROb2RlKHN0YXRlbWVudE5vZGUpLFxuICAgICAgICAgIGVxdWFsaXRpZXMgPSBjb250ZXh0LmdldEVxdWFsaXRpZXMoKSxcbiAgICAgICAgICBlcXVhbGl0eVZlcmlmaWVkID0gZXF1YWxpdHkudmVyaWZ5KGVxdWFsaXRpZXMsIGNvbnRleHQsIHZlcmlmeUFoZWFkKTtcblxuICAgIHZlcmlmaWVkU3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHkgPSBlcXVhbGl0eVZlcmlmaWVkOyAgLy8vXG4gIH1cblxuICBpZiAodmVyaWZpZWRTdGF0ZW1lbnRBc0Rlcml2ZWRFcXVhbGl0eSkge1xuICAgIGNvbnRleHQuZGVidWcoYC4uLnZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgYSBkZXJpdmVkIGVxdWFsaXR5LmAsIHN0YXRlbWVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHZlcmlmaWVkU3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlbWVudEFzRXF1YWxUZXJtcyhzdGF0ZW1lbnROb2RlLCBkZXJpdmVkLCBjb250ZXh0LCB2ZXJpZnlBaGVhZCkge1xuICBsZXQgc3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsVGVybXM7XG5cbiAgY29uc3Qgc3RhdGVtZW50U3RyaW5nID0gY29udGV4dC5ub2RlQXNTdHJpbmcoc3RhdGVtZW50Tm9kZSk7XG5cbiAgY29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgYXMgZXF1YWwgdGVybXMuLi5gLCBzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCB0eXBlcyA9IFtdLFxuICAgICAgICBsZWZ0VGVybU5vZGUgPSBsZWZ0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgbGVmdFRlcm1WZXJpZmllZCA9IHZlcmlmeVRlcm0obGVmdFRlcm1Ob2RlLCB0eXBlcywgY29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgIGxldCB2ZXJpZmllZEFoZWFkO1xuXG4gICAgICAgICAgY29uc3QgcmlnaHRUZXJtTm9kZSA9IHJpZ2h0VGVybU5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKSxcbiAgICAgICAgICAgICAgICByaWdodFRlcm1WZXJpZmllZCA9IHZlcmlmeVRlcm0ocmlnaHRUZXJtTm9kZSwgdHlwZXMsIGNvbnRleHQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCB2ZXJpZmllZEFoZWFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFR5cGUgPSBzZWNvbmQodHlwZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFR5cGUgPSBmaXJzdFR5cGUsIC8vL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUeXBlID0gc2Vjb25kVHlwZSwgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VHlwZUVxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2ZSaWdodFR5cGUgPSBsZWZ0VHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2YocmlnaHRUeXBlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0VHlwZUVxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2ZSaWdodFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdFR5cGVOYW1lID0gbGVmdFR5cGUuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFR5cGVOYW1lID0gcmlnaHRUeXBlLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFRlcm1TdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhsZWZ0VGVybU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFRlcm1TdHJpbmcgPSBjb250ZXh0Lm5vZGVBc1N0cmluZyhyaWdodFRlcm1Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmluZm8oYFRoZSBsZWZ0ICcke2xlZnRUZXJtU3RyaW5nfScgdGVybSdzICcke2xlZnRUeXBlTmFtZX0nIHR5cGUgaXMgbm90IGVxdWFsIHRvLCBhIHN1Yi10eXBlIG9mIG5vciBhIHN1cGVyLXR5cGUgb2YgdGhlIHJpZ2h0ICcke3JpZ2h0VGVybVN0cmluZ30nIHRlcm0ncyAnJHtyaWdodFR5cGVOYW1lfScgdHlwZS5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkQWhlYWQgPSB2ZXJpZnlBaGVhZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmVyaWZpZWRBaGVhZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZlcmlmaWVkQWhlYWQgPSByaWdodFRlcm1WZXJpZmllZDsgIC8vL1xuXG4gICAgICAgICAgcmV0dXJuIHZlcmlmaWVkQWhlYWQ7XG4gICAgICAgIH0pO1xuXG4gIHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbFRlcm1zID0gbGVmdFRlcm1WZXJpZmllZDsgLy8vXG5cbiAgaWYgKHN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbFRlcm1zKSB7XG4gICAgY29udGV4dC50cmFjZShgLi4udmVyaWZpZWQgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCBhcyBlcXVhbCB0ZXJtcy5gLCBzdGF0ZW1lbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZW1lbnRWZXJpZmllZEFzRXF1YWxUZXJtcztcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlTdGF0ZW1lbnRBZ2FpbnN0Q29tYmluYXRvciIsInZlcmlmeVN0YXRlbWVudEFnYWluc3RDb21iaW5hdG9ycyIsImxlZnRUZXJtTm9kZVF1ZXJ5Iiwibm9kZVF1ZXJ5IiwicmlnaHRUZXJtTm9kZVF1ZXJ5IiwidHlwZUluZmVyZW5jZU5vZGVRdWVyeSIsInR5cGVBc3NlcnRpb25Ob2RlUXVlcnkiLCJ2ZXJpZnlTdGF0ZW1lbnQiLCJzdGF0ZW1lbnROb2RlIiwiYXNzaWdubWVudHMiLCJkZXJpdmVkIiwiY29udGV4dCIsInZlcmlmeUFoZWFkIiwic3RhdGVtZW50VmVyaWZpZWQiLCJzdGF0ZW1lbnRTdHJpbmciLCJub2RlQXNTdHJpbmciLCJ0cmFjZSIsInZlcmlmeVN0YXRlbWVudEZ1bmN0aW9ucyIsInZlcmlmeVN0YXRlbWVudEFzRXF1YWxpdHkiLCJ2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVJbmZlcmVuY2UiLCJ2ZXJpZnlTdGF0ZW1lbnRBc1R5cGVBc3NlcnRpb24iLCJzb21lIiwidmVyaWZ5U3RhdGVtZW50RnVuY3Rpb24iLCJkZWJ1ZyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXRlbWVudE5vZGVzVmVyaWZpZXIiLCJzdGF0ZW1lbnRWZXJpZmllZEFnYWluc3RDb21iaW5hdG9ycyIsImNvbWJpbmF0b3JzIiwiZ2V0Q29tYmluYXRvcnMiLCJicmFja2V0ZWRDb21iaW5hdG9yIiwiY29tYmluYXRvciIsInN0YXRlbWVudFZlcmlmaWVkQWdhaW5zdENvbWJpbmF0b3IiLCJjb21iaW5hdG9yU3RyaW5nIiwiZ2V0U3RyaW5nIiwiY29tYmluYXRvclN0YXRlbWVudE5vZGUiLCJnZXRTdGF0ZW1lbnROb2RlIiwibm9uVGVybWluYWxOb2RlQSIsIm5vblRlcm1pbmFsTm9kZUIiLCJub25UZXJtaW5hbE5vZGVWZXJpZmllZCIsInZlcmlmeU5vblRlcm1pbmFsTm9kZSIsInN0YXRlbWVudFZlcmlmaWVkQXNUeXBlSW5mZXJlbmNlIiwidHlwZUluZmVyZW5jZU5vZGUiLCJ0eXBlSW5mZXJlbmNlU3RyaW5nIiwiaW5mbyIsInR5cGVJbmZlcmVuY2VWZXJpZmllZCIsInZlcmlmeVR5cGVJbmZlcmVuY2UiLCJzdGF0ZW1lbnRWZXJpZmllZEFzVHlwZUFzc2VydGlvbiIsInR5cGVBc3NlcnRpb25Ob2RlIiwidHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VHlwZUFzc2VydGlvbiIsInN0YXRlbWVudFZlcmlmaWVkQXNFcXVhbGl0eSIsImVxdWFsaXR5Q29tYmluYXRvciIsInZlcmlmaWVkQWhlYWQiLCJ2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb25zIiwidmVyaWZ5U3RhdGVtZW50QXNEZXJpdmVkRXF1YWxpdHkiLCJ2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsVGVybXMiLCJ2ZXJpZnlTdGF0ZW1lbnRBc0VxdWFsaXR5RnVuY3Rpb24iLCJ2ZXJpZmllZFN0YXRlbWVudEFzRGVyaXZlZEVxdWFsaXR5IiwiZXF1YWxpdHkiLCJFcXVhbGl0eSIsImZyb21TdGF0ZW1lbnROb2RlIiwiZXF1YWxpdGllcyIsImdldEVxdWFsaXRpZXMiLCJlcXVhbGl0eVZlcmlmaWVkIiwidmVyaWZ5Iiwic3RhdGVtZW50VmVyaWZpZWRBc0VxdWFsVGVybXMiLCJ0eXBlcyIsImxlZnRUZXJtTm9kZSIsImxlZnRUZXJtVmVyaWZpZWQiLCJ2ZXJpZnlUZXJtIiwicmlnaHRUZXJtTm9kZSIsInJpZ2h0VGVybVZlcmlmaWVkIiwiZmlyc3RUeXBlIiwiZmlyc3QiLCJzZWNvbmRUeXBlIiwic2Vjb25kIiwibGVmdFR5cGUiLCJyaWdodFR5cGUiLCJsZWZ0VHlwZUVxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2ZSaWdodFR5cGUiLCJpc0VxdWFsVG9PclN1YlR5cGVPZk9mU3VwZXJUeXBlT2YiLCJsZWZ0VHlwZU5hbWUiLCJnZXROYW1lIiwicmlnaHRUeXBlTmFtZSIsImxlZnRUZXJtU3RyaW5nIiwicmlnaHRUZXJtU3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7SUFtREEsT0FBK0I7ZUFBL0I7O0lBdUJnQkEsZ0NBQWdDO2VBQWhDQTs7SUFyQkFDLGlDQUFpQztlQUFqQ0E7OzsrREFuREs7MkRBQ0U7Z0VBQ1E7Z0VBQ0M7b0VBQ0E7MkRBQ0E7Z0VBQ0c7cUJBRVQ7cUJBQ0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFOUIsSUFBTUMsb0JBQW9CQyxJQUFBQSxnQkFBUyxFQUFDLGlDQUM5QkMscUJBQXFCRCxJQUFBQSxnQkFBUyxFQUFDLGlDQUMvQkUseUJBQXlCRixJQUFBQSxnQkFBUyxFQUFDLDhCQUNu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