"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyTypeDeclaration;
    }
});
var _type = /*#__PURE__*/ _interop_require_default(require("../../verify/type"));
var _query = require("../../utilities/query");
var _constants = require("../../constants");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var firstTypeNodeQuery = (0, _query.nodeQuery)("/typeDeclaration/type[0]"), secondTypeNodeQuery = (0, _query.nodeQuery)("/typeDeclaration/type[1]");
function verifyTypeDeclaration(typeDeclarationNode, fileContext) {
    var typeDeclarationVerified;
    var firstTypeNode = firstTypeNodeQuery(typeDeclarationNode), secondTypeNode = secondTypeNodeQuery(typeDeclarationNode), typeNode = firstTypeNode, superTypeNode = secondTypeNode, typeString = fileContext.nodeAsString(typeNode), superTypeString = fileContext.nodeAsString(superTypeNode);
    superTypeString === _constants.EMPTY_STRING ? fileContext.trace("Verifying the '".concat(typeString, "' type declaration..."), typeDeclarationNode) : fileContext.trace("Verifying the '".concat(typeString, ":").concat(superTypeString, "' type declaration..."), typeDeclarationNode);
    var typeVerified = (0, _type.default)(typeNode, superTypeNode, fileContext);
    typeDeclarationVerified = typeVerified; ///
    if (typeDeclarationVerified) {
        superTypeString === _constants.EMPTY_STRING ? fileContext.trace("...verified the '".concat(typeString, "' type declaration."), typeDeclarationNode) : fileContext.trace("...verified the '".concat(typeString, ":").concat(superTypeString, "' type declaration."), typeDeclarationNode);
    }
    return typeDeclarationVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvZGVjbGFyYXRpb24vdHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHZlcmlmeVR5cGUgZnJvbSBcIi4uLy4uL3ZlcmlmeS90eXBlXCI7XG5cbmltcG9ydCB7IG5vZGVRdWVyeSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuY29uc3QgZmlyc3RUeXBlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3R5cGVEZWNsYXJhdGlvbi90eXBlWzBdXCIpLFxuICAgICAgc2Vjb25kVHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlRGVjbGFyYXRpb24vdHlwZVsxXVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5VHlwZURlY2xhcmF0aW9uKHR5cGVEZWNsYXJhdGlvbk5vZGUsIGZpbGVDb250ZXh0KSB7XG4gIGxldCB0eXBlRGVjbGFyYXRpb25WZXJpZmllZDtcblxuICBjb25zdCBmaXJzdFR5cGVOb2RlID0gZmlyc3RUeXBlTm9kZVF1ZXJ5KHR5cGVEZWNsYXJhdGlvbk5vZGUpLFxuICAgICAgICBzZWNvbmRUeXBlTm9kZSA9IHNlY29uZFR5cGVOb2RlUXVlcnkodHlwZURlY2xhcmF0aW9uTm9kZSksXG4gICAgICAgIHR5cGVOb2RlID0gZmlyc3RUeXBlTm9kZSwgLy8vXG4gICAgICAgIHN1cGVyVHlwZU5vZGUgPSBzZWNvbmRUeXBlTm9kZSwgLy8vXG4gICAgICAgIHR5cGVTdHJpbmcgPSBmaWxlQ29udGV4dC5ub2RlQXNTdHJpbmcodHlwZU5vZGUpLFxuICAgICAgICBzdXBlclR5cGVTdHJpbmcgPSBmaWxlQ29udGV4dC5ub2RlQXNTdHJpbmcoc3VwZXJUeXBlTm9kZSk7XG5cbiAgKHN1cGVyVHlwZVN0cmluZyA9PT0gRU1QVFlfU1RSSU5HKSA/XG4gICAgZmlsZUNvbnRleHQudHJhY2UoYFZlcmlmeWluZyB0aGUgJyR7dHlwZVN0cmluZ30nIHR5cGUgZGVjbGFyYXRpb24uLi5gLCB0eXBlRGVjbGFyYXRpb25Ob2RlKSA6XG4gICAgICBmaWxlQ29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHt0eXBlU3RyaW5nfToke3N1cGVyVHlwZVN0cmluZ30nIHR5cGUgZGVjbGFyYXRpb24uLi5gLCB0eXBlRGVjbGFyYXRpb25Ob2RlKTtcblxuICBjb25zdCB0eXBlVmVyaWZpZWQgPSB2ZXJpZnlUeXBlKHR5cGVOb2RlLCBzdXBlclR5cGVOb2RlLCBmaWxlQ29udGV4dCk7XG5cbiAgdHlwZURlY2xhcmF0aW9uVmVyaWZpZWQgPSB0eXBlVmVyaWZpZWQ7IC8vL1xuXG4gIGlmICh0eXBlRGVjbGFyYXRpb25WZXJpZmllZCkge1xuICAgIChzdXBlclR5cGVTdHJpbmcgPT09IEVNUFRZX1NUUklORykgP1xuICAgICAgZmlsZUNvbnRleHQudHJhY2UoYC4uLnZlcmlmaWVkIHRoZSAnJHt0eXBlU3RyaW5nfScgdHlwZSBkZWNsYXJhdGlvbi5gLCB0eXBlRGVjbGFyYXRpb25Ob2RlKSA6XG4gICAgICAgIGZpbGVDb250ZXh0LnRyYWNlKGAuLi52ZXJpZmllZCB0aGUgJyR7dHlwZVN0cmluZ306JHtzdXBlclR5cGVTdHJpbmd9JyB0eXBlIGRlY2xhcmF0aW9uLmAsIHR5cGVEZWNsYXJhdGlvbk5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVEZWNsYXJhdGlvblZlcmlmaWVkO1xufVxuIl0sIm5hbWVzIjpbInZlcmlmeVR5cGVEZWNsYXJhdGlvbiIsImZpcnN0VHlwZU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInNlY29uZFR5cGVOb2RlUXVlcnkiLCJ0eXBlRGVjbGFyYXRpb25Ob2RlIiwiZmlsZUNvbnRleHQiLCJ0eXBlRGVjbGFyYXRpb25WZXJpZmllZCIsImZpcnN0VHlwZU5vZGUiLCJzZWNvbmRUeXBlTm9kZSIsInR5cGVOb2RlIiwic3VwZXJUeXBlTm9kZSIsInR5cGVTdHJpbmciLCJub2RlQXNTdHJpbmciLCJzdXBlclR5cGVTdHJpbmciLCJFTVBUWV9TVFJJTkciLCJ0cmFjZSIsInR5cGVWZXJpZmllZCIsInZlcmlmeVR5cGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7OytCQVVBOzs7ZUFBd0JBOzs7MkRBUkQ7cUJBRUc7eUJBQ0c7Ozs7OztBQUU3QixJQUFNQyxxQkFBcUJDLElBQUFBLGdCQUFTLEVBQUMsNkJBQy9CQyxzQkFBc0JELElBQUFBLGdCQUFTLEVBQUM7QUFFdkIsU0FBU0Ysc0JBQXNCSSxtQkFBbUIsRUFBRUMsV0FBVztJQUM1RSxJQUFJQztJQUVKLElBQU1DLGdCQUFnQk4sbUJBQW1CRyxzQkFDbkNJLGlCQUFpQkwsb0JBQW9CQyxzQkFDckNLLFdBQVdGLGVBQ1hHLGdCQUFnQkYsZ0JBQ2hCRyxhQUFhTixZQUFZTyxZQUFZLENBQUNILFdBQ3RDSSxrQkFBa0JSLFlBQVlPLFlBQVksQ0FBQ0Y7SUFFaERHLG9CQUFvQkMsdUJBQVksR0FDL0JULFlBQVlVLEtBQUssQ0FBQyxBQUFDLGtCQUE0QixPQUFYSixZQUFXLDBCQUF3QlAsdUJBQ3JFQyxZQUFZVSxLQUFLLENBQUMsQUFBQyxrQkFBK0JGLE9BQWRGLFlBQVcsS0FBbUIsT0FBaEJFLGlCQUFnQiwwQkFBd0JUO0lBRTlGLElBQU1ZLGVBQWVDLElBQUFBLGFBQVUsRUFBQ1IsVUFBVUMsZUFBZUw7SUFFekRDLDBCQUEwQlUsY0FBYyxHQUFHO0lBRTNDLElBQUlWLHlCQUF5QjtRQUMxQk8sb0JBQW9CQyx1QkFBWSxHQUMvQlQsWUFBWVUsS0FBSyxDQUFDLEFBQUMsb0JBQThCLE9BQVhKLFlBQVcsd0JBQXNCUCx1QkFDckVDLFlBQVlVLEtBQUssQ0FBQyxBQUFDLG9CQUFpQ0YsT0FBZEYsWUFBVyxLQUFtQixPQUFoQkUsaUJBQWdCLHdCQUFzQlQ7SUFDaEc7SUFFQSxPQUFPRTtBQUNUIn0=