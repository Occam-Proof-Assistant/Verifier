"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyConstructorDeclaration;
    }
});
var _termAsConstructor = /*#__PURE__*/ _interop_require_default(require("../../verify/termAsConstructor"));
var _query = require("../../utilities/query");
var _constants = require("../../constants");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/term"), typeNodeQuery = (0, _query.nodeQuery)("/constructorDeclaration/type");
function verifyConstructorDeclaration(constructorDeclarationNode, fileContext) {
    var constructorDeclarationVerified;
    var termNode = termNodeQuery(constructorDeclarationNode), typeNode = typeNodeQuery(constructorDeclarationNode), termString = fileContext.nodeAsString(termNode), typeString = typeNode === null ? _constants.EMPTY_STRING : fileContext.nodeAsString(typeNode);
    typeString === _constants.EMPTY_STRING ? fileContext.trace("Verifying the '".concat(termString, "' constructor declaration..."), constructorDeclarationNode) : fileContext.trace("Verifying the '".concat(termString, ":").concat(typeString, "' constructor declaration..."), constructorDeclarationNode);
    var termVerifiedAsConstructor = (0, _termAsConstructor.default)(termNode, typeNode, fileContext);
    constructorDeclarationVerified = termVerifiedAsConstructor; ///
    if (constructorDeclarationVerified) {
        typeString === _constants.EMPTY_STRING ? fileContext.debug("...verified the '".concat(termString, "' constructor declaration."), constructorDeclarationNode) : fileContext.debug("...verified the '".concat(termString, ":").concat(typeString, "' constructor declaration."), constructorDeclarationNode);
    }
    return constructorDeclarationVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92ZXJpZnkvZGVjbGFyYXRpb24vY29uc3RydWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB2ZXJpZnlUZXJtQXNDb25zdHJ1Y3RvciBmcm9tIFwiLi4vLi4vdmVyaWZ5L3Rlcm1Bc0NvbnN0cnVjdG9yXCI7XG5cbmltcG9ydCB7IG5vZGVRdWVyeSB9IGZyb20gXCIuLi8uLi91dGlsaXRpZXMvcXVlcnlcIjtcbmltcG9ydCB7IEVNUFRZX1NUUklORyB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuY29uc3QgdGVybU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi9jb25zdHJ1Y3RvckRlY2xhcmF0aW9uL3Rlcm1cIiksXG4gICAgICB0eXBlTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL2NvbnN0cnVjdG9yRGVjbGFyYXRpb24vdHlwZVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5Q29uc3RydWN0b3JEZWNsYXJhdGlvbihjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSwgZmlsZUNvbnRleHQpIHtcbiAgbGV0IGNvbnN0cnVjdG9yRGVjbGFyYXRpb25WZXJpZmllZDtcblxuICBjb25zdCB0ZXJtTm9kZSA9IHRlcm1Ob2RlUXVlcnkoY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUpLFxuICAgICAgICB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkoY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUpLFxuICAgICAgICB0ZXJtU3RyaW5nID0gZmlsZUNvbnRleHQubm9kZUFzU3RyaW5nKHRlcm1Ob2RlKSxcbiAgICAgICAgdHlwZVN0cmluZyA9ICh0eXBlTm9kZSA9PT0gbnVsbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICBFTVBUWV9TVFJJTkcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb250ZXh0Lm5vZGVBc1N0cmluZyh0eXBlTm9kZSk7XG5cbiAgKHR5cGVTdHJpbmcgPT09IEVNUFRZX1NUUklORykgP1xuICAgIGZpbGVDb250ZXh0LnRyYWNlKGBWZXJpZnlpbmcgdGhlICcke3Rlcm1TdHJpbmd9JyBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi4uLmAsIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKSA6XG4gICAgICBmaWxlQ29udGV4dC50cmFjZShgVmVyaWZ5aW5nIHRoZSAnJHt0ZXJtU3RyaW5nfToke3R5cGVTdHJpbmd9JyBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi4uLmAsIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKTtcblxuICBjb25zdCB0ZXJtVmVyaWZpZWRBc0NvbnN0cnVjdG9yID0gdmVyaWZ5VGVybUFzQ29uc3RydWN0b3IodGVybU5vZGUsIHR5cGVOb2RlLCBmaWxlQ29udGV4dCk7XG5cbiAgY29uc3RydWN0b3JEZWNsYXJhdGlvblZlcmlmaWVkID0gdGVybVZlcmlmaWVkQXNDb25zdHJ1Y3RvcjsgLy8vXG5cbiAgaWYgKGNvbnN0cnVjdG9yRGVjbGFyYXRpb25WZXJpZmllZCkge1xuICAgICh0eXBlU3RyaW5nID09PSBFTVBUWV9TVFJJTkcpID9cbiAgICAgIGZpbGVDb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7dGVybVN0cmluZ30nIGNvbnN0cnVjdG9yIGRlY2xhcmF0aW9uLmAsIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25Ob2RlKSA6XG4gICAgICAgIGZpbGVDb250ZXh0LmRlYnVnKGAuLi52ZXJpZmllZCB0aGUgJyR7dGVybVN0cmluZ306JHt0eXBlU3RyaW5nfScgY29uc3RydWN0b3IgZGVjbGFyYXRpb24uYCwgY29uc3RydWN0b3JEZWNsYXJhdGlvbk5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yRGVjbGFyYXRpb25WZXJpZmllZDtcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlDb25zdHJ1Y3RvckRlY2xhcmF0aW9uIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInR5cGVOb2RlUXVlcnkiLCJjb25zdHJ1Y3RvckRlY2xhcmF0aW9uTm9kZSIsImZpbGVDb250ZXh0IiwiY29uc3RydWN0b3JEZWNsYXJhdGlvblZlcmlmaWVkIiwidGVybU5vZGUiLCJ0eXBlTm9kZSIsInRlcm1TdHJpbmciLCJub2RlQXNTdHJpbmciLCJ0eXBlU3RyaW5nIiwiRU1QVFlfU1RSSU5HIiwidHJhY2UiLCJ0ZXJtVmVyaWZpZWRBc0NvbnN0cnVjdG9yIiwidmVyaWZ5VGVybUFzQ29uc3RydWN0b3IiLCJkZWJ1ZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7K0JBVUE7OztlQUF3QkE7Ozt3RUFSWTtxQkFFVjt5QkFDRzs7Ozs7O0FBRTdCLElBQU1DLGdCQUFnQkMsSUFBQUEsZ0JBQVMsRUFBQyxpQ0FDMUJDLGdCQUFnQkQsSUFBQUEsZ0JBQVMsRUFBQztBQUVqQixTQUFTRiw2QkFBNkJJLDBCQUEwQixFQUFFQyxXQUFXO0lBQzFGLElBQUlDO0lBRUosSUFBTUMsV0FBV04sY0FBY0csNkJBQ3pCSSxXQUFXTCxjQUFjQyw2QkFDekJLLGFBQWFKLFlBQVlLLFlBQVksQ0FBQ0gsV0FDdENJLGFBQWEsQUFBQ0gsYUFBYSxPQUNaSSx1QkFBWSxHQUNWUCxZQUFZSyxZQUFZLENBQUNGO0lBRS9DRyxlQUFlQyx1QkFBWSxHQUMxQlAsWUFBWVEsS0FBSyxDQUFDLEFBQUMsa0JBQTRCLE9BQVhKLFlBQVcsaUNBQStCTCw4QkFDNUVDLFlBQVlRLEtBQUssQ0FBQyxBQUFDLGtCQUErQkYsT0FBZEYsWUFBVyxLQUFjLE9BQVhFLFlBQVcsaUNBQStCUDtJQUVoRyxJQUFNVSw0QkFBNEJDLElBQUFBLDBCQUF1QixFQUFDUixVQUFVQyxVQUFVSDtJQUU5RUMsaUNBQWlDUSwyQkFBMkIsR0FBRztJQUUvRCxJQUFJUixnQ0FBZ0M7UUFDakNLLGVBQWVDLHVCQUFZLEdBQzFCUCxZQUFZVyxLQUFLLENBQUMsQUFBQyxvQkFBOEIsT0FBWFAsWUFBVywrQkFBNkJMLDhCQUM1RUMsWUFBWVcsS0FBSyxDQUFDLEFBQUMsb0JBQWlDTCxPQUFkRixZQUFXLEtBQWMsT0FBWEUsWUFBVywrQkFBNkJQO0lBQ2xHO0lBRUEsT0FBT0U7QUFDVCJ9