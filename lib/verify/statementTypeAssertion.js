"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyStatementTypeAssertion;
    }
});
var _variable = /*#__PURE__*/ _interopRequireDefault(require("../variable"));
var _array = require("../utilities/array");
var _string = require("../utilities/string");
var _query = require("../utilities/query");
var _term = require("../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatementTypeAssertion(statementNode, qualified, proofContext) {
    var statementTypeAssertionVerified = false;
    proofContext.begin(statementNode);
    var statementString = (0, _string.nodeAsString)(statementNode);
    proofContext.debug("Verifying the '".concat(statementString, "' statement type assertion..."));
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
        if (!typePresent) {
            proofContext.error("The ".concat(typeName, " type is not present."));
        } else {
            if (!statementTypeAssertionVerified) {
                var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, qualified, proofContext);
                statementTypeAssertionVerified = variableTypeAssertionVerified; ///
            }
            if (!statementTypeAssertionVerified) {
                var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, qualified, proofContext);
                statementTypeAssertionVerified = termTypeAssertionVerified; ///
            }
        }
    }
    if (statementTypeAssertionVerified) {
        proofContext.info("Verified the '".concat(statementString, "' statement type assertion."));
    }
    statementTypeAssertionVerified ? proofContext.complete(statementNode) : proofContext.halt(statementNode);
    return statementTypeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, qualified, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode), termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
    if (termVerifiedAsVariable) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType();
        var assertedTypeEqualToOrSubTypeOfVariableType = variableType === null ? true : assertedType.isEqualToOrSubTypeOf(variableType);
        if (!assertedTypeEqualToOrSubTypeOfVariableType) {
            proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(variableName, "' variable type."));
        } else {
            if (!qualified) {
                var type = assertedType, name = variableName, variable1 = _variable.default.fromTypeAndName(type, name);
                proofContext.addVariable(variable1);
            }
            variableTypeAssertionVerified = true;
        }
    }
    return variableTypeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, qualified, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstType = (0, _array.first)(types), termType = firstType, termString = (0, _string.nodeAsString)(termNode), assertedTypeEqualToOrSubTypeOfTermType = termType === null ? true : assertedType.isEqualToOrSubTypeOf(termType);
        if (!assertedTypeEqualToOrSubTypeOfTermType) {
            proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(termString, "' term type."));
        } else {
            if (!qualified) {
                debugger;
            }
            termTypeAssertionVerified = true;
        }
    }
    return termTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50VHlwZUFzc2VydGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFZhcmlhYmxlIGZyb20gXCIuLi92YXJpYWJsZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG5vZGVBc1N0cmluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIHR5cGVOYW1lRnJvbVR5cGVOb2RlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgdmVyaWZ5VGVybUFzVmFyaWFibGUsIHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzIH0gZnJvbSBcIi4uL3ZlcmlmeS90ZXJtXCI7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdHlwZUFzc2VydGlvbi90ZXJtXCIpLFxuICAgICAgdHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlQXNzZXJ0aW9uL3R5cGVcIiksXG4gICAgICB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC90eXBlQXNzZXJ0aW9uIVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50VHlwZUFzc2VydGlvbihzdGF0ZW1lbnROb2RlLCBxdWFsaWZpZWQsIHByb29mQ29udGV4dCkge1xuICBsZXQgc3RhdGVtZW50VHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgcHJvb2ZDb250ZXh0LmJlZ2luKHN0YXRlbWVudE5vZGUpO1xuXG4gIGNvbnN0IHN0YXRlbWVudFN0cmluZyA9IG5vZGVBc1N0cmluZyhzdGF0ZW1lbnROb2RlKTtcblxuICBwcm9vZkNvbnRleHQuZGVidWcoYFZlcmlmeWluZyB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IHR5cGUgYXNzZXJ0aW9uLi4uYCk7XG5cbiAgY29uc3QgdHlwZUFzc2VydGlvbk5vZGUgPSB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5KHN0YXRlbWVudE5vZGUpO1xuXG4gIGlmICh0eXBlQXNzZXJ0aW9uTm9kZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgICAgdHlwZU5hbWUgPSB0eXBlTmFtZUZyb21UeXBlTm9kZSh0eXBlTm9kZSksXG4gICAgICAgICAgdHlwZVByZXNlbnQgPSBwcm9vZkNvbnRleHQuaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUodHlwZU5hbWUpO1xuXG4gICAgaWYgKCF0eXBlUHJlc2VudCkge1xuICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgJHt0eXBlTmFtZX0gdHlwZSBpcyBub3QgcHJlc2VudC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uVmVyaWZpZWQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2ZXJpZnlWYXJpYWJsZVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIHF1YWxpZmllZCwgcHJvb2ZDb250ZXh0KTtcblxuICAgICAgICBzdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZDsgIC8vL1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRlbWVudFR5cGVBc3NlcnRpb25WZXJpZmllZCkge1xuICAgICAgICBjb25zdCB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdmVyaWZ5VGVybVR5cGVBc3NlcnRpb24odHlwZUFzc2VydGlvbk5vZGUsIHF1YWxpZmllZCwgcHJvb2ZDb250ZXh0KTtcblxuICAgICAgICBzdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkOyAgLy8vXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlbWVudFR5cGVBc3NlcnRpb25WZXJpZmllZCkge1xuICAgIHByb29mQ29udGV4dC5pbmZvKGBWZXJpZmllZCB0aGUgJyR7c3RhdGVtZW50U3RyaW5nfScgc3RhdGVtZW50IHR5cGUgYXNzZXJ0aW9uLmApO1xuICB9XG5cbiAgc3RhdGVtZW50VHlwZUFzc2VydGlvblZlcmlmaWVkID9cbiAgICBwcm9vZkNvbnRleHQuY29tcGxldGUoc3RhdGVtZW50Tm9kZSkgOlxuICAgICAgcHJvb2ZDb250ZXh0LmhhbHQoc3RhdGVtZW50Tm9kZSk7XG5cbiAgcmV0dXJuIHN0YXRlbWVudFR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBxdWFsaWZpZWQsIHByb29mQ29udGV4dCkge1xuICBsZXQgdmFyaWFibGVUeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCBjb250ZXh0ID0gcHJvb2ZDb250ZXh0LCAvLy9cbiAgICAgICAgdmFyaWFibGVzID0gW10sXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHRlcm1WZXJpZmllZEFzVmFyaWFibGUgPSB2ZXJpZnlUZXJtQXNWYXJpYWJsZSh0ZXJtTm9kZSwgdmFyaWFibGVzLCBjb250ZXh0KTtcblxuICBpZiAodGVybVZlcmlmaWVkQXNWYXJpYWJsZSkge1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdHlwZU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgICAgdHlwZU5hbWUgPSB0eXBlTmFtZUZyb21UeXBlTm9kZSh0eXBlTm9kZSksXG4gICAgICAgICAgYXNzZXJ0ZWRUeXBlTmFtZSA9IHR5cGVOYW1lLCAgLy8vXG4gICAgICAgICAgYXNzZXJ0ZWRUeXBlID0gcHJvb2ZDb250ZXh0LmZpbmRUeXBlQnlUeXBlTmFtZShhc3NlcnRlZFR5cGVOYW1lKSxcbiAgICAgICAgICBmaXJzdFZhcmlhYmxlID0gZmlyc3QodmFyaWFibGVzKSxcbiAgICAgICAgICB2YXJpYWJsZSA9IGZpcnN0VmFyaWFibGUsIC8vL1xuICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlLmdldE5hbWUoKSxcbiAgICAgICAgICB2YXJpYWJsZVR5cGUgPSB2YXJpYWJsZS5nZXRUeXBlKCk7XG5cbiAgICBjb25zdCBhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZWYXJpYWJsZVR5cGUgPSAodmFyaWFibGVUeXBlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIDogLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydGVkVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih2YXJpYWJsZVR5cGUpO1xuXG4gICAgaWYgKCFhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZWYXJpYWJsZVR5cGUpIHtcbiAgICAgIHByb29mQ29udGV4dC5lcnJvcihgVGhlIGFzc2VydGVkIHR5cGUgaXMgbm90IGVxdWFsIHRvIG9yIGEgc3ViLXR5cGUgb2YgdGhlICcke3ZhcmlhYmxlTmFtZX0nIHZhcmlhYmxlIHR5cGUuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcXVhbGlmaWVkKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhc3NlcnRlZFR5cGUsICAvLy9cbiAgICAgICAgICAgICAgbmFtZSA9IHZhcmlhYmxlTmFtZSwgIC8vL1xuICAgICAgICAgICAgICB2YXJpYWJsZSA9IFZhcmlhYmxlLmZyb21UeXBlQW5kTmFtZSh0eXBlLCBuYW1lKTtcblxuICAgICAgICBwcm9vZkNvbnRleHQuYWRkVmFyaWFibGUodmFyaWFibGUpO1xuICAgICAgfVxuXG4gICAgICB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcXVhbGlmaWVkLCBwcm9vZkNvbnRleHQpIHtcbiAgbGV0IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSBmYWxzZTtcblxuICBjb25zdCB0eXBlcyA9IFtdLFxuICAgICAgICBjb250ZXh0ID0gcHJvb2ZDb250ZXh0LCAvLy9cbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgdGVybVZlcmlmaWVkQWdhaW5zdENvbnN0cnVjdG9ycyA9IHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzKHRlcm1Ob2RlLCB0eXBlcywgY29udGV4dCk7XG5cbiAgaWYgKHRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMpIHtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICAgIGFzc2VydGVkVHlwZU5hbWUgPSB0eXBlTmFtZSwgIC8vL1xuICAgICAgICAgIGFzc2VydGVkVHlwZSA9IHByb29mQ29udGV4dC5maW5kVHlwZUJ5VHlwZU5hbWUoYXNzZXJ0ZWRUeXBlTmFtZSksXG4gICAgICAgICAgZmlyc3RUeXBlID0gZmlyc3QodHlwZXMpLFxuICAgICAgICAgIHRlcm1UeXBlID0gZmlyc3RUeXBlLFxuICAgICAgICAgIHRlcm1TdHJpbmcgPSBub2RlQXNTdHJpbmcodGVybU5vZGUpLFxuICAgICAgICAgIGFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlRlcm1UeXBlID0gKHRlcm1UeXBlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgOiAvLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRlZFR5cGUuaXNFcXVhbFRvT3JTdWJUeXBlT2YodGVybVR5cGUpO1xuXG4gICAgaWYgKCFhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZUZXJtVHlwZSkge1xuICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gb3IgYSBzdWItdHlwZSBvZiB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gdHlwZS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFxdWFsaWZpZWQpIHtcbiAgICAgICAgZGVidWdnZXJcbiAgICAgIH1cblxuICAgICAgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlTdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInR5cGVOb2RlUXVlcnkiLCJ0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5Iiwic3RhdGVtZW50Tm9kZSIsInF1YWxpZmllZCIsInByb29mQ29udGV4dCIsInN0YXRlbWVudFR5cGVBc3NlcnRpb25WZXJpZmllZCIsImJlZ2luIiwic3RhdGVtZW50U3RyaW5nIiwibm9kZUFzU3RyaW5nIiwiZGVidWciLCJ0eXBlQXNzZXJ0aW9uTm9kZSIsInR5cGVOb2RlIiwidHlwZU5hbWUiLCJ0eXBlTmFtZUZyb21UeXBlTm9kZSIsInR5cGVQcmVzZW50IiwiaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUiLCJlcnJvciIsInZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uIiwidGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uIiwiaW5mbyIsImNvbXBsZXRlIiwiaGFsdCIsImNvbnRleHQiLCJ2YXJpYWJsZXMiLCJ0ZXJtTm9kZSIsInRlcm1WZXJpZmllZEFzVmFyaWFibGUiLCJ2ZXJpZnlUZXJtQXNWYXJpYWJsZSIsImFzc2VydGVkVHlwZU5hbWUiLCJhc3NlcnRlZFR5cGUiLCJmaW5kVHlwZUJ5VHlwZU5hbWUiLCJmaXJzdFZhcmlhYmxlIiwiZmlyc3QiLCJ2YXJpYWJsZSIsInZhcmlhYmxlTmFtZSIsImdldE5hbWUiLCJ2YXJpYWJsZVR5cGUiLCJnZXRUeXBlIiwiYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlIiwiaXNFcXVhbFRvT3JTdWJUeXBlT2YiLCJ0eXBlIiwibmFtZSIsIlZhcmlhYmxlIiwiZnJvbVR5cGVBbmROYW1lIiwiYWRkVmFyaWFibGUiLCJ0eXBlcyIsInRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMiLCJ2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyIsImZpcnN0VHlwZSIsInRlcm1UeXBlIiwidGVybVN0cmluZyIsImFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlRlcm1UeXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFhQTs7O2VBQXdCQTs7OzZEQVhIO3FCQUVDO3NCQUNPO3FCQUNtQjtvQkFDb0I7Ozs7OztBQUVwRSxJQUFNQyxnQkFBZ0JDLElBQUFBLGdCQUFTLEVBQUMsd0JBQzFCQyxnQkFBZ0JELElBQUFBLGdCQUFTLEVBQUMsd0JBQzFCRSx5QkFBeUJGLElBQUFBLGdCQUFTLEVBQUM7QUFFMUIsU0FBU0YsNkJBQTZCSyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFO0lBQzNGLElBQUlDLGlDQUFpQyxLQUFLO0lBRTFDRCxhQUFhRSxLQUFLLENBQUNKO0lBRW5CLElB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