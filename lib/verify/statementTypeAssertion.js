"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return verifyStatementTypeAssertion;
    }
});
var _variable = /*#__PURE__*/ _interopRequireDefault(require("../variable"));
var _array = require("../utilities/array");
var _string = require("../utilities/string");
var _query = require("../utilities/query");
var _term = require("../verify/term");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var termNodeQuery = (0, _query.nodeQuery)("/typeAssertion/term"), typeNodeQuery = (0, _query.nodeQuery)("/typeAssertion/type"), typeAssertionNodeQuery = (0, _query.nodeQuery)("/statement/typeAssertion!");
function verifyStatementTypeAssertion(statementNode, proofContext) {
    var typeAssertionVerified = false;
    proofContext.begin(statementNode);
    var statementString = (0, _string.nodeAsString)(statementNode);
    proofContext.debug("Verifying the '".concat(statementString, "' statement type assertion..."));
    var typeAssertionNode = typeAssertionNodeQuery(statementNode);
    if (typeAssertionNode !== null) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), typePresent = proofContext.isTypePresentByTypeName(typeName);
        if (!typePresent) {
            proofContext.error("The ".concat(typeName, " type is not present."));
        } else {
            var context = proofContext, termNode = termNodeQuery(typeAssertionNode), variables = [], termVerifiedAsVariable = (0, _term.verifyTermAsVariable)(termNode, variables, context);
            if (termVerifiedAsVariable) {
                var variableTypeAssertionVerified = verifyVariableTypeAssertion(typeAssertionNode, proofContext);
                typeAssertionVerified = variableTypeAssertionVerified; ///
            } else {
                var termTypeAssertionVerified = verifyTermTypeAssertion(typeAssertionNode, proofContext);
                typeAssertionVerified = termTypeAssertionVerified; ///
            }
        }
    }
    if (typeAssertionVerified) {
        proofContext.info("Verified the '".concat(statementString, "' statement type assertion."));
    }
    typeAssertionVerified ? proofContext.complete(statementNode) : proofContext.halt(statementNode);
    return typeAssertionVerified;
}
function verifyTermTypeAssertion(typeAssertionNode, proofContext) {
    var termTypeAssertionVerified = false;
    var types = [], context = proofContext, termNode = termNodeQuery(typeAssertionNode), termVerifiedAgainstConstructors = (0, _term.verifyTermAgainstConstructors)(termNode, types, context);
    if (termVerifiedAgainstConstructors) {
        var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstType = (0, _array.first)(types), termType = firstType, assertedTypeEqualToOrSubTypeOfTermType = assertedType.isEqualToOrSubTypeOf(termType);
        if (!assertedTypeEqualToOrSubTypeOfTermType) {
            var termString = (0, _string.nodeAsString)(termNode);
            proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(termString, "' term type."));
        } else {
            termTypeAssertionVerified = true;
        }
    }
    return termTypeAssertionVerified;
}
function verifyVariableTypeAssertion(typeAssertionNode, proofContext) {
    var variableTypeAssertionVerified = false;
    var context = proofContext, variables = [], termNode = termNodeQuery(typeAssertionNode);
    (0, _term.verifyTermAsVariable)(termNode, variables, context);
    var typeNode = typeNodeQuery(typeAssertionNode), typeName = (0, _query.typeNameFromTypeNode)(typeNode), assertedTypeName = typeName, assertedType = proofContext.findTypeByTypeName(assertedTypeName), firstVariable = (0, _array.first)(variables), variable = firstVariable, variableName = variable.getName(), variableType = variable.getType();
    var assertedTypeEqualToOrSubTypeOfVariableType = variableType === null ? true : assertedType.isEqualToOrSubTypeOf(variableType);
    if (!assertedTypeEqualToOrSubTypeOfVariableType) {
        proofContext.error("The asserted type is not equal to or a sub-type of the '".concat(variableName, "' variable type."));
    } else {
        var derived = proofContext.isDerived();
        if (!derived) {
            var type = assertedType, name = variableName, variable1 = _variable.default.fromTypeAndName(type, name);
            proofContext.addVariable(variable1);
        }
        variableTypeAssertionVerified = true;
    }
    return variableTypeAssertionVerified;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJpZnkvc3RhdGVtZW50VHlwZUFzc2VydGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFZhcmlhYmxlIGZyb20gXCIuLi92YXJpYWJsZVwiO1xuXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuLi91dGlsaXRpZXMvYXJyYXlcIjtcbmltcG9ydCB7IG5vZGVBc1N0cmluZyB9IGZyb20gXCIuLi91dGlsaXRpZXMvc3RyaW5nXCI7XG5pbXBvcnQgeyBub2RlUXVlcnksIHR5cGVOYW1lRnJvbVR5cGVOb2RlIH0gZnJvbSBcIi4uL3V0aWxpdGllcy9xdWVyeVwiO1xuaW1wb3J0IHsgdmVyaWZ5VGVybUFzVmFyaWFibGUsIHZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzIH0gZnJvbSBcIi4uL3ZlcmlmeS90ZXJtXCI7XG5cbmNvbnN0IHRlcm1Ob2RlUXVlcnkgPSBub2RlUXVlcnkoXCIvdHlwZUFzc2VydGlvbi90ZXJtXCIpLFxuICAgICAgdHlwZU5vZGVRdWVyeSA9IG5vZGVRdWVyeShcIi90eXBlQXNzZXJ0aW9uL3R5cGVcIiksXG4gICAgICB0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5ID0gbm9kZVF1ZXJ5KFwiL3N0YXRlbWVudC90eXBlQXNzZXJ0aW9uIVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmVyaWZ5U3RhdGVtZW50VHlwZUFzc2VydGlvbihzdGF0ZW1lbnROb2RlLCBwcm9vZkNvbnRleHQpIHtcbiAgbGV0IHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IGZhbHNlO1xuXG4gIHByb29mQ29udGV4dC5iZWdpbihzdGF0ZW1lbnROb2RlKTtcblxuICBjb25zdCBzdGF0ZW1lbnRTdHJpbmcgPSBub2RlQXNTdHJpbmcoc3RhdGVtZW50Tm9kZSk7XG5cbiAgcHJvb2ZDb250ZXh0LmRlYnVnKGBWZXJpZnlpbmcgdGhlICcke3N0YXRlbWVudFN0cmluZ30nIHN0YXRlbWVudCB0eXBlIGFzc2VydGlvbi4uLmApO1xuXG4gIGNvbnN0IHR5cGVBc3NlcnRpb25Ob2RlID0gdHlwZUFzc2VydGlvbk5vZGVRdWVyeShzdGF0ZW1lbnROb2RlKTtcblxuICBpZiAodHlwZUFzc2VydGlvbk5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVGcm9tVHlwZU5vZGUodHlwZU5vZGUpLFxuICAgICAgICAgIHR5cGVQcmVzZW50ID0gcHJvb2ZDb250ZXh0LmlzVHlwZVByZXNlbnRCeVR5cGVOYW1lKHR5cGVOYW1lKTtcblxuICAgIGlmICghdHlwZVByZXNlbnQpIHtcbiAgICAgIHByb29mQ29udGV4dC5lcnJvcihgVGhlICR7dHlwZU5hbWV9IHR5cGUgaXMgbm90IHByZXNlbnQuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBwcm9vZkNvbnRleHQsIC8vL1xuICAgICAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgICAgIHZhcmlhYmxlcyA9IFtdLFxuICAgICAgICAgICAgdGVybVZlcmlmaWVkQXNWYXJpYWJsZSA9IHZlcmlmeVRlcm1Bc1ZhcmlhYmxlKHRlcm1Ob2RlLCB2YXJpYWJsZXMsIGNvbnRleHQpO1xuXG4gICAgICBpZiAodGVybVZlcmlmaWVkQXNWYXJpYWJsZSkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZlcmlmeVZhcmlhYmxlVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcHJvb2ZDb250ZXh0KTtcblxuICAgICAgICB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgPSB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZDsgIC8vL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uKHR5cGVBc3NlcnRpb25Ob2RlLCBwcm9vZkNvbnRleHQpO1xuXG4gICAgICAgIHR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7ICAvLy9cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZUFzc2VydGlvblZlcmlmaWVkKSB7XG4gICAgcHJvb2ZDb250ZXh0LmluZm8oYFZlcmlmaWVkIHRoZSAnJHtzdGF0ZW1lbnRTdHJpbmd9JyBzdGF0ZW1lbnQgdHlwZSBhc3NlcnRpb24uYCk7XG4gIH1cblxuICB0eXBlQXNzZXJ0aW9uVmVyaWZpZWQgP1xuICAgIHByb29mQ29udGV4dC5jb21wbGV0ZShzdGF0ZW1lbnROb2RlKSA6XG4gICAgICBwcm9vZkNvbnRleHQuaGFsdChzdGF0ZW1lbnROb2RlKTtcblxuICByZXR1cm4gdHlwZUFzc2VydGlvblZlcmlmaWVkO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlUZXJtVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB0ZXJtVHlwZUFzc2VydGlvblZlcmlmaWVkID0gZmFsc2U7XG5cbiAgY29uc3QgdHlwZXMgPSBbXSxcbiAgICAgICAgY29udGV4dCA9IHByb29mQ29udGV4dCwgLy8vXG4gICAgICAgIHRlcm1Ob2RlID0gdGVybU5vZGVRdWVyeSh0eXBlQXNzZXJ0aW9uTm9kZSksXG4gICAgICAgIHRlcm1WZXJpZmllZEFnYWluc3RDb25zdHJ1Y3RvcnMgPSB2ZXJpZnlUZXJtQWdhaW5zdENvbnN0cnVjdG9ycyh0ZXJtTm9kZSwgdHlwZXMsIGNvbnRleHQpO1xuXG4gIGlmICh0ZXJtVmVyaWZpZWRBZ2FpbnN0Q29uc3RydWN0b3JzKSB7XG4gICAgY29uc3QgdHlwZU5vZGUgPSB0eXBlTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKSxcbiAgICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgICBhc3NlcnRlZFR5cGVOYW1lID0gdHlwZU5hbWUsICAvLy9cbiAgICAgICAgICBhc3NlcnRlZFR5cGUgPSBwcm9vZkNvbnRleHQuZmluZFR5cGVCeVR5cGVOYW1lKGFzc2VydGVkVHlwZU5hbWUpLFxuICAgICAgICAgIGZpcnN0VHlwZSA9IGZpcnN0KHR5cGVzKSxcbiAgICAgICAgICB0ZXJtVHlwZSA9IGZpcnN0VHlwZSxcbiAgICAgICAgICBhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZUZXJtVHlwZSA9IGFzc2VydGVkVHlwZS5pc0VxdWFsVG9PclN1YlR5cGVPZih0ZXJtVHlwZSk7XG5cbiAgICBpZiAoIWFzc2VydGVkVHlwZUVxdWFsVG9PclN1YlR5cGVPZlRlcm1UeXBlKSB7XG4gICAgICBjb25zdCB0ZXJtU3RyaW5nID0gbm9kZUFzU3RyaW5nKHRlcm1Ob2RlKTtcblxuICAgICAgcHJvb2ZDb250ZXh0LmVycm9yKGBUaGUgYXNzZXJ0ZWQgdHlwZSBpcyBub3QgZXF1YWwgdG8gb3IgYSBzdWItdHlwZSBvZiB0aGUgJyR7dGVybVN0cmluZ30nIHRlcm0gdHlwZS5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlcm1UeXBlQXNzZXJ0aW9uVmVyaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVZhcmlhYmxlVHlwZUFzc2VydGlvbih0eXBlQXNzZXJ0aW9uTm9kZSwgcHJvb2ZDb250ZXh0KSB7XG4gIGxldCB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBwcm9vZkNvbnRleHQsIC8vL1xuICAgICAgICB2YXJpYWJsZXMgPSBbXSxcbiAgICAgICAgdGVybU5vZGUgPSB0ZXJtTm9kZVF1ZXJ5KHR5cGVBc3NlcnRpb25Ob2RlKTtcblxuICB2ZXJpZnlUZXJtQXNWYXJpYWJsZSh0ZXJtTm9kZSwgdmFyaWFibGVzLCBjb250ZXh0KTtcblxuICBjb25zdCB0eXBlTm9kZSA9IHR5cGVOb2RlUXVlcnkodHlwZUFzc2VydGlvbk5vZGUpLFxuICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lRnJvbVR5cGVOb2RlKHR5cGVOb2RlKSxcbiAgICAgICAgYXNzZXJ0ZWRUeXBlTmFtZSA9IHR5cGVOYW1lLCAgLy8vXG4gICAgICAgIGFzc2VydGVkVHlwZSA9IHByb29mQ29udGV4dC5maW5kVHlwZUJ5VHlwZU5hbWUoYXNzZXJ0ZWRUeXBlTmFtZSksXG4gICAgICAgIGZpcnN0VmFyaWFibGUgPSBmaXJzdCh2YXJpYWJsZXMpLFxuICAgICAgICB2YXJpYWJsZSA9IGZpcnN0VmFyaWFibGUsIC8vL1xuICAgICAgICB2YXJpYWJsZU5hbWUgPSB2YXJpYWJsZS5nZXROYW1lKCksXG4gICAgICAgIHZhcmlhYmxlVHlwZSA9IHZhcmlhYmxlLmdldFR5cGUoKTtcblxuICBjb25zdCBhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZWYXJpYWJsZVR5cGUgPSAodmFyaWFibGVUeXBlID09PSBudWxsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgOiAgLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0ZWRUeXBlLmlzRXF1YWxUb09yU3ViVHlwZU9mKHZhcmlhYmxlVHlwZSk7XG5cbiAgaWYgKCFhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZWYXJpYWJsZVR5cGUpIHtcbiAgICBwcm9vZkNvbnRleHQuZXJyb3IoYFRoZSBhc3NlcnRlZCB0eXBlIGlzIG5vdCBlcXVhbCB0byBvciBhIHN1Yi10eXBlIG9mIHRoZSAnJHt2YXJpYWJsZU5hbWV9JyB2YXJpYWJsZSB0eXBlLmApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRlcml2ZWQgPSBwcm9vZkNvbnRleHQuaXNEZXJpdmVkKCk7XG5cbiAgICBpZiAoIWRlcml2ZWQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBhc3NlcnRlZFR5cGUsICAvLy9cbiAgICAgICAgICAgIG5hbWUgPSB2YXJpYWJsZU5hbWUsICAvLy9cbiAgICAgICAgICAgIHZhcmlhYmxlID0gVmFyaWFibGUuZnJvbVR5cGVBbmROYW1lKHR5cGUsIG5hbWUpO1xuXG4gICAgICBwcm9vZkNvbnRleHQuYWRkVmFyaWFibGUodmFyaWFibGUpO1xuICAgIH1cblxuICAgIHZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB2YXJpYWJsZVR5cGVBc3NlcnRpb25WZXJpZmllZDtcbn1cbiJdLCJuYW1lcyI6WyJ2ZXJpZnlTdGF0ZW1lbnRUeXBlQXNzZXJ0aW9uIiwidGVybU5vZGVRdWVyeSIsIm5vZGVRdWVyeSIsInR5cGVOb2RlUXVlcnkiLCJ0eXBlQXNzZXJ0aW9uTm9kZVF1ZXJ5Iiwic3RhdGVtZW50Tm9kZSIsInByb29mQ29udGV4dCIsInR5cGVBc3NlcnRpb25WZXJpZmllZCIsImJlZ2luIiwic3RhdGVtZW50U3RyaW5nIiwibm9kZUFzU3RyaW5nIiwiZGVidWciLCJ0eXBlQXNzZXJ0aW9uTm9kZSIsInR5cGVOb2RlIiwidHlwZU5hbWUiLCJ0eXBlTmFtZUZyb21UeXBlTm9kZSIsInR5cGVQcmVzZW50IiwiaXNUeXBlUHJlc2VudEJ5VHlwZU5hbWUiLCJlcnJvciIsImNvbnRleHQiLCJ0ZXJtTm9kZSIsInZhcmlhYmxlcyIsInRlcm1WZXJpZmllZEFzVmFyaWFibGUiLCJ2ZXJpZnlUZXJtQXNWYXJpYWJsZSIsInZhcmlhYmxlVHlwZUFzc2VydGlvblZlcmlmaWVkIiwidmVyaWZ5VmFyaWFibGVUeXBlQXNzZXJ0aW9uIiwidGVybVR5cGVBc3NlcnRpb25WZXJpZmllZCIsInZlcmlmeVRlcm1UeXBlQXNzZXJ0aW9uIiwiaW5mbyIsImNvbXBsZXRlIiwiaGFsdCIsInR5cGVzIiwidGVybVZlcmlmaWVkQWdhaW5zdENvbnN0cnVjdG9ycyIsInZlcmlmeVRlcm1BZ2FpbnN0Q29uc3RydWN0b3JzIiwiYXNzZXJ0ZWRUeXBlTmFtZSIsImFzc2VydGVkVHlwZSIsImZpbmRUeXBlQnlUeXBlTmFtZSIsImZpcnN0VHlwZSIsImZpcnN0IiwidGVybVR5cGUiLCJhc3NlcnRlZFR5cGVFcXVhbFRvT3JTdWJUeXBlT2ZUZXJtVHlwZSIsImlzRXF1YWxUb09yU3ViVHlwZU9mIiwidGVybVN0cmluZyIsImZpcnN0VmFyaWFibGUiLCJ2YXJpYWJsZSIsInZhcmlhYmxlTmFtZSIsImdldE5hbWUiLCJ2YXJpYWJsZVR5cGUiLCJnZXRUeXBlIiwiYXNzZXJ0ZWRUeXBlRXF1YWxUb09yU3ViVHlwZU9mVmFyaWFibGVUeXBlIiwiZGVyaXZlZCIsImlzRGVyaXZlZCIsInR5cGUiLCJuYW1lIiwiVmFyaWFibGUiLCJmcm9tVHlwZUFuZE5hbWUiLCJhZGRWYXJpYWJsZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7K0JBYUE7OztlQUF3QkE7Ozs2REFYSDtxQkFFQztzQkFDTztxQkFDbUI7b0JBQ29COzs7Ozs7QUFFcEUsSUFBTUMsZ0JBQWdCQyxJQUFBQSxnQkFBUyxFQUFDLHdCQUMxQkMsZ0JBQWdCRCxJQUFBQSxnQkFBUyxFQUFDLHdCQUMxQkUseUJBQXlCRixJQUFBQSxnQkFBUyxFQUFDO0FBRTFCLFNBQVNGLDZCQUE2QkssYUFBYSxFQUFFQyxZQUFZLEVBQUU7SUFDaEYsSUFBSUMsd0JBQXdCLEtBQUs7SUFFakNELGFBQWFFLEtBQUssQ0FBQ0g7SUFFbkIsSUFBTUksa0JBQWtCQyxJQUFBQSxvQkFBWSxFQUFDTDtJQUVyQ0MsYUFBYUssS0FBSyxDQUFDLEFBQUMsa0JBQWlDLE9BQWhCRixpQkFBZ0I7SUFFckQsSUFBTUcsb0JBQW9CUix1QkFBdUJDO0lBRWpELElBQUlPLHNCQUFzQixJQUFJLEVBQUU7UUFDOUIsSUFBTUMsV0FBV1YsY0FBY1Msb0JBQ3pCRSxXQUFXQyxJQUFBQSwyQkFBb0IsRUFBQ0YsV0FDaENHLGNBQWNW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